/***********************************************************************
* Adaptive Simulated Annealing (ASA)
* Lester Ingber <ingber@ingber.com>
* Copyright (c) 1987-2016 Lester Ingber.  All Rights Reserved.
* ASA-LICENSE file has the license that must be included with ASA code.
***********************************************************************/

$Id: ASA-CHANGES,v 30.21 2016/02/02 15:49:39 ingber Exp ingber $

========================================================================
			CONTENTS

		@@CHANGES
		@@CONTRIBUTORS
		@@VERSION DATES
========================================================================
		@@CHANGES
========================================================================
23 Oct 15

asa.c
Fixed bug that prevented description line being inserted into
asa_exit_anytime when ASA_EXIT_ANYTIME is TRUE.

========================================================================
12 Oct 15

ASA-README.ms
Included reference to SSL WWW https:// pages.

========================================================================
24 Mar 15

ASA-README.ms
Converted a line of ISO-8859 font into UTF-8.

========================================================================
15 Jan 15

ASA-NOTES
Added to Section @@Equality and Inequality Constraints information on
paper by Hime Aguiar and colleagues addressing use of equality constraints
in ASA when inverse mappings of the equality space can be calculated.

========================================================================
7 Jan 15

ASA-README.ms
Updated references.

========================================================================
11 Oct 14

asa.c
Deleted unused parallel_id not in struct.

ASA-Makefile, ASA-README.ms, asa.c, asa_usr.c
Added print to asa_usr_out when ASA_FUZZY_PRINT is TRUE, from
FuzzyControl() and/or AlterQuench().

========================================================================
28 Jul 14

ASA-README.ms, asa.c, asa_usr_asa.h
Added OPTIONS->parallel_id to be available when ASA_PARALLEL is TRUE,
just before the call to user_cost_function().

========================================================================
8 Apr 14

ASA-README.ms, asa_usr.c asa_usr.h
Added code to restore regular annealing schedules under some conditions
when ASA_FUZZY is TRUE:
*ASA_FUZZY_Init_User_Quench_Cost_Scale
*ASA_FUZZY_Init_User_Quench_Param_Scale

========================================================================
21 Jan 14

asa.c, ASA-README.ms
When ASA_PARALLEL is TRUE, the do loop around generated states that
tests for invalid states is taken over, not within, blocks of parallel
generated states.

========================================================================
19 Jan 14

asa.c, asa.h, asa_usr.c, ASA-README.ms
Corrected and cleaned up some ASA_PARALLEL code.

========================================================================
6 Jan 14

asa.c
Cleaned up ASA_PARALLEL loop.

========================================================================
2 Jan 14

ASA-Makefile, ASA-README.ms, asa.c, asa.h, asa_usr.c, asa_usr_asa.h
Set up ASA to run OpenMP with ASA_PARALLEL.

========================================================================
24 Oct 13

ASA-README.ms
Updated references.

========================================================================
19 Oct 13

asa.c, ASA-README.ms
In the cost function, when User_Tangents is TRUE, the user should
test the incoming *cost_flag for a value of -1 (changed from FALSE) to
calculate tangents.  If ASA_QUEUE is TRUE, then the value of *cost_flag
is tested for FALSE in previous states in queue and an invalid statement
is available in the printout.

========================================================================
25 Sep 13

ASA-Makefile, ASA-README.ms
Since -mno-cygwin has been deprecated in Cygwin, there are comments to
use i686-pc-mingw32-gcc.exe, e.g.,
CC = /bin/i686-pc-mingw32-gcc.exe
to not use the cygwin1.dll library.

========================================================================
13 Sep 13

All files
All references to the ASA-LICENSE have been changed to reflect that the
information in the ASA-LICENSE file must be included with the ASA code,
not necessarily the file itself.

========================================================================
12 Sep 13

ASA-LICENSE, ASA-README.ms
The ASA-LICENSE has been replaced with a BSD 3-Clause License, as posted
on http://opensource.org/licenses/BSD-3-Clause .

========================================================================
13 Jun 13

ASA-README.ms
Updated references.

========================================================================
8 Apr 13

asa.c
Added existence test for "asa_exit_anytime".

========================================================================
2 Apr 13

asa.c, asa_usr.c, asa_usr_asa.h, ASA-Makefile
When USER_ASA_USR_OUT is TRUE, the user must define
OPTIONS->Asa_Out_Usr_File to override the USER_OUT default of asa_out.

========================================================================
24 Mar 13

asa.c
moved fflush() and fclose() out of TIME_CALC section.

asa_usr.c
Under fitloc() and calcf(), moved some ASA_RESOLUTION variables under
FITLOC_ROUND to avoid warnings of not used when FITLOC_ROUND is FALSE.

asa_usr_cst.c, asa_usr.c
When ASA_TEST is TRUE, removed parameter_upper_bound-parameter_lower_bound tests.

ASA-NOTES:
Section, @@Options for Large Spaces, changed a Program Option to
increase Temperature_Ratio_Scale (smaller negative exponent)

========================================================================
7 Aug 12

ASA-README.html
Fixed typos and obsolete links.

========================================================================
2 Jul 12

ASA-README.html
Fixed bug that left out RCS version.

========================================================================
13 Apr 12

ASA-README.ms
Emphasized that Simulated Annealing is NOT Simulated Quenching.

========================================================================
4 Feb 12

ASA-LICENSE, ASA-README.ms
Added https://code.google.com/p/adaptive-simulated-annealing to ASA-LICENSE.

========================================================================
29 Dec 11

ASA-Makefile
added filter for some ESC characters in .txt and .html files.

========================================================================
23 Dec 11

asa.c, asa_usr.c
Renamed some goto labels to include ASA in names, to avoid conflicts
with other codes.

========================================================================
10 Nov 11

asa.c, asa_usr.c
Added irrelevant code to stop "set but not used" warnings on Ubuntu.

AS-README.ms
Updated 2012 reference for paper.

========================================================================
27 Jul 11

asa.c
If the calculated *initial_cost_temperature is not set using
USER_INITIAL_COST_TEMP, and if it is essentially zero, then it is reset
to e = 2.718.  If ASA_PRINT is TRUE a warning is printed.

ASA-LICENSE
Corrected spelling typos.

========================================================================
25 Jul 11

ASA-NOTES
Modified section
@@Equality Constraints
to
@@Equality and Inequality Constraints
where the method of Lagrange multipliers is discussed for including
equality and inequality constraints.

========================================================================
15 Jun 11

ASA-README.ms
Updated references.

========================================================================
6 March 11

ASA-README.ms
ASA_FUZZY does not do well on ASA_TEST_POINT.  Added a Caution that is
appropriate for many other variants of SA:
Caution: Often ASA_FUZZY will turn on QUENCHing > 1, violating the proof
of ASA.  For many systems, this speeding up of the sampling process can
be a welcome efficiency, but in some systems global minima may be missed,
e.g., in systems with multiple scales.

ASA-README.html
fixed bug in formatting

========================================================================
5 March 11

ASA-README.ms, ASA-Makefile, asa.c, asa_usr.c, asa_usr.h
When ASA_FUZZY is set to TRUE, a modified fuzzy-logic algorithm
originally developed by Hime Junior performs an adaptive tuning of
selected ASA OPTIONS.  ASA_FUZZY has several adaptive parameters defined
in asa_usr_asa.h, and some fixed #define parameters in the several
subroutines at the bottom of asa_usr.c.  The default functions are set to
tune QUENCH_COST and QUENCH_PARAMETERS parameters, so these are tested
to be TRUE in the default asa_usr_asa.h.  If you change any defaults,
pay attention to sections labeled ASA_FUZZY at top and bottom sections
of asa_usr.c, and in asa_usr.h.

========================================================================
9 Feb 11

ASA-LICENSE, ASA-README.ms
Clause 5 was deleted, and Clause 6 was renumbered to
Clause 5, to follow guidelines of the "New BSD License",
http://en.wikipedia.org/wiki/BSD_License, beginning with Version 28.1.

========================================================================
14 Dec 10

asa_usr.c
Added free() and fclose() statements in SELF_OPTIMIZE functions to have
no errors reported under cppcheck.  These only occurred in places that
were returning fatal errors code anyway.

========================================================================
10 Dec 10

ASA-README.ms, ASA-Makefile, asa.c, asa_usr.c, asa_usr.h, asa_usr_asa.h, asa_usr_cst.h
When ADAPTIVE_OPTIONS is set to TRUE, it is possible to change relevant
OPTIONS in the USER_DEFINES struct in asa_usr_asa.h during run time,
by including an asa_adaptive_options file.  This can be very useful to
efficiently determine how to tune long runs.

========================================================================
16 Jul 10

ASA-LICENSE, ASA-README.ms
ftp is no longer supported to retrive ASA.

========================================================================
4 Jan 10

ASA-NOTES:
Noted that when using SUNPRO CC, the 'extern "C" {' line and its '}'
line should be commented out in [].h files.

asa_usr.c
Added (double) cast to test "if (fabs ((double) seed) > 0)".

========================================================================
4 Nov 09

ASA-README.ms:
Modified TRD reference.

========================================================================
3 Nov 09

ASA-README.ms:
The 2005 TRD report has been withdrawn as requested by the publisher of
"Handbook of Technical Trading Analysis" (Wiley, 2009) in which an
updated version appears.

========================================================================
19 Aug 09

ASA-README.ms:
Updated references.

========================================================================
25 Jun 09

asa_usr.c:
Added number_asa_usr_open to track multiple calls to asa_usr_out,
similar to number_asa_open in asa.c that tracks multiple calls to asa_out.

========================================================================
20 Jun 09

asa_usr.c:
If your USER_COST_FUNCTION modifies your other programs, and final calls
to asa() and/or fitloc() make additional modifications, you might run
a last call to USER_COST_FUNCTION().  An ASA_TEMPLATE is provided after
FITLOC for this purpose.

========================================================================
14 Apr 09

asa.c, asa_usr.c:
Added fscanf_ret= to all fscanf calls, to stop warnings under optimization
options on some Linux platforms.

ASA-Makefile, ASA-README.ms:
Added comment that if you use gcc across different levels of compiler
optimization on different platforms, you may wish to invoke -ffloat-store
to be sure to get the same precision in your results. This option is
added to ASA-Makefile.

Added comment for Cygwin that if -mno-cygwin flag has been removed,
use a mingw-targeted cross-compiler.

========================================================================
26 Jan 09

ASA-README.ms:
Added references to some code snippets in asa_examples.txt.

========================================================================
30 Dec 08

Updated Copyright in all files.

========================================================================
13 Sep 08

asa.c:
Moved fopen ("asa_exit_anytime", "w") up to initialization section.

========================================================================
24 Jul 08

ASA-README.ms, asa.c, asa_usr_asa.h:
When ASA_EXIT_ANYTIME is set to TRUE, the first call to asa() creates the
file asa_exit_anytime.  To  permit IMMEDIATE_EXIT before calculating the
next generated state, simply delete the file asa_exit_anytime, and asa()
will exit with code IMMEDIATE_EXIT.  This can be useful on long runs.

========================================================================
26 May 08

ASA-LICENSE, ASA-README.ms:
Added "or publication" to Condition 4.

========================================================================
24 Apr 08

Makefile:
Corrected collecting pages for ASA-README.ps and ASA-README.pdf.

========================================================================
8 Mar 08

ASA-README-ms, asa.c:
When calculating derivatives, an invalid cost function, i.e., returning
*cost_flag = FALSE from the cost function, will exit asa() with *exit_code
INVALID_COST_FUNCTION_DERIV.  Also, when calculating derivatives, no
extra test is performed to check that parameters are within their lower
and upper bounds (since meshes for derivatives may exceed these bounds).
If this is not desired, then within the cost function, within a test
for USER_OPTIONS->Locate_Cost == 3, a decision may be made whether to
return this *exit_code.

========================================================================
20 Feb 08

asa_usr.c, asa_usr.h:
Added OPTIONAL_DATA_PTR info to asa_main() ASA_TEMPLATE.

========================================================================
19 Feb 08

ASA-README.ms:
Added some examples for using OPTIONAL_DATA_PTR and Asa_Data_Ptr.

========================================================================
18 Feb 08

ASA-README.ms, asa_usr.c, asa_usr.h, asa_usr_asa.h:
To enable clean compilations under c++/g++, when using user-defined
USER[] functions, added HAVE_ANSI #defines for Cost_Schedule(),
Acceptance_Test(), Generating_Distrib(), Reanneal_Cost_Function(), and
Reanneal_Params_Function().  Used const void *OPTIONS_TMP as place-holder,
similar to use in some asa.c functions, in asa_usr_asa.h and asa_usr.c,
for USER_OPTIONS and RECUR_USER_OPTIONS in referring and referred
functions in asa_usr.c.

asa_usr.c:
Corrected dereferencing of cost_last and cost_best in
user_reanneal_cost().  Wrapped all code in user_reanneal_cost() in
#define ASA_TEMPLATE.

asa.c:
moved immediate_flag in asa() to prevent warning.

ASA-README.ms:
Added some reference papers on use of ASA.  There is now an RLaB
interface to ASA, which is referenced in Section @@RLAB Interface with
ASA in asa_contrib.txt.

========================================================================
26 Dec 07

Updated Copyright in all files.

ASA-README.ms:
Added some references.

========================================================================
9 Mar 07

ASA-README.ms:
Added comment on comparing algorithms to section Use of Documentation
for Tuning.

========================================================================
1 Feb 07

ASA-README.ms:
Updated information on files utils_code.txt and utils_code.html.

========================================================================
31 Jan 07

ASA-README.ms:
ASA is now also listed at http://asa-caltech.sourceforge.net
(http://asa-caltech.sf.net).

========================================================================
21 Nov 06

asa.c:
If Delta_X is set to 0, then no tangents are calculated.  No tangents
for any parameter are calculated if User_Delta_Parameter[] is 0.

========================================================================
20 Oct 06

ASA-NOTES:
Added 2 URLS to section @@FORTRAN Issues.

========================================================================
26 Sep 06

asa.c:
Changed reporting of "new best", from when MULTI_MIN is TRUE, to when
ASA_PRINT_MORE is TRUE.

========================================================================
25 Sep 06

ASA-NOTES:
Added section @@Some Reflections After a Score of Years.

========================================================================
23 Sep 06

asa.c:
Added another cast (double) tmp_var_int, which may be unnecessary for most
(all) systems.

========================================================================
16 Aug 06

asa.c:
When ASA_SAVE is TRUE, corrected size for Asa_Out_File to 80 in fread
and fwrite.

========================================================================
27 Jul 06

asa.c, asa.h:
Moved char exit_msg[160] from asa.h to asa.c to avoid compilation problems
on some systems with some applications that include asa.h in multiple files.

========================================================================
20 Jul 06

Makefile:
When using Cygwin to create a DLL, corrected target asadll: from
-Wl,--export-all-symbol to -Wl,--export-all .

========================================================================
17 Jul 06

ASA-README.html:
Fixed HTML warning re hr may not occur inside p.

========================================================================
13 Jul 06

asa.c, asa.h, asa_usr.c:
When using a DOS version of ASA, e.g., ASA.zip, on a Unix machine, some
systems do not process continuation "\" lines properly.  These lines
are now joined to long lines in the code.

========================================================================
3 May 06

asa_usr.c:
Deleted extra fclose() in ASA_TEMPLATE_SAVE.

========================================================================
26 Feb 06

ASA-README.ms, asa.c:
The final values in asa.c of *best_number_generated_saved and
*best_number_accepted_saved at the best cost function will be those of
the first instance of the final best value.

========================================================================
23 Feb 06

ASA-README.ms, asa.c:
When MULTI_MIN is set to TRUE and Multi_Specify is set to 0, and multiple
best cost functions are found, the parameters of the final cost function
reported will be the parameters of the last best cost function.

========================================================================
26 Jan 06

ASA-README.html:
Changed DOCTYPE to W3C.

========================================================================
13 Jan 06

ASA-README.ms:
Included statement that ASA will compile under C++ as well as under
C compilers.

========================================================================
2 Jan 06

asa.c:
Added test if (*initial_cost_temperature < EPS_DOUBLE) then exit asa()
with exit_code INVALID_COST_FUNCTION.

========================================================================
1 Jan 06

asa_usr.c:
Shortened recur_initialize_parameters_value to less than 31 chars, to
recur_initialize_params_value.

========================================================================
29 Nov 05

ASA-README.ms, asa.c:
When ASA_PIPE or ASA_PIPE_FILE are TRUE, the current_generated_state as
well as the best_generated_state are printed.

========================================================================
28 Nov 05

asa.c:
When ASA_QUEUE and ASA_RESOLTUION are TRUE, comparisons with a new
generated state are made relative to EPS_DOUBLE, since Queue_Resolution
= Coarse_Resolution.  When ASA_QUEUE is TRUE, dropped a decrement of
number_generated.

========================================================================
7 Oct 05

asa.c:
When MULTI_MIN is TRUE, asa_exit() calculates cost functions, and their
associated parameters, in descending order, to leave the final state as
the best state.

========================================================================
12 Sep 05

ASA-README.ms:
Referred Section on parameter_lower_bound to Section on
parameter_upper_bound.

========================================================================
26 Aug 05

ASA-README.ms:
Direct users to asa_examples.txt for an example of use of
OPTIONAL_DATA_PTR and MULTI_MIN.

========================================================================
22 Aug 05

ASA-CHANGES, ASA-LICENSE, ASA-Makefile, ASA-NOTES, ASA-README.ms:
Added ASA- prefix to CHANGES, LICENSE, Makefile, and NOTES to
prevent conflicts with other software.

========================================================================
7 Jul 05

asa.c:
"&" were left off save_queue and save_queue_indx in fread() and fwrite()
used when both ASA_QUEUE and ASA_SAVE are TRUE.

========================================================================
3 Apr 05

ASA-README.ms:
Enhanced details in Use of Documentation for Tuning.

========================================================================
1 Mar 05

NOTES:
In section @@Options for Large Spaces, changed decrease
Cost_Parameter_Scale_Ratio to increase Cost_Parameter_Scale_Ratio.


========================================================================
21 Jan 05

asa_usr.c:
Fixed placement of ASA_TEMPLATE_QUEUE's to account for choices in
ASA_QUEUE and ASA_RESOLUTION.

========================================================================
12 Jan 05

asa_usr.c:
Corrected asa_usr_out printout when MULTI_MIN is TRUE.

========================================================================
11 Jan 05

asa.c:
When MULTI_MIN is TRUE, tightened Multi_Grid[] test with -EPS_DOUBLE.

========================================================================
7 Jan 05

asa_usr.c:
When ASA_TEMPLATE_ASA_OUT_PID is TRUE, changed pid_file[] from
user_out_{pid} to asa_usr_out_{pid}.
Corrected recur_cost_function(), changing fprintf() to printf(), and
corrected asa_main() used with SELF_OPTIMIZE, defining user_exit_msg[].
Deleted ASA_SAMPLE from recur_cost_function().

asa_usr_asa.h:
If SELF_OPTIMIZE is TRUE, changed default of INCL_STDOUT to FALSE.

========================================================================
3 Jan 05

asa_usr_asa.h:
Wrapped #ifndef TIME_CALC if INCL_STDOUT is TRUE.

asa_usr_cst.c:
Wrapped #if TIME_CALC with #if FALSE in case printf() is not active.

ASA-README.ms, asa.c:
Added notes to set TIME_STD to TRUE and TIME_GETRUSAGE to FALSE under
Cygwin with -mno-cygwin.

asa.c:
Added initialization print_time() call when TIME_GETRUSAGE is FALSE.

========================================================================
1 Jan 05

Updated Copyright in all files.

========================================================================
12 Dec 04

ASA-README.ms, Makefile:
The Makefile can be used to create DLL functions for Windows.

========================================================================
6 Dec 04

asa_usr.h:
Exit_USER prototype out of place in HAVE_ANSI section.

asa.h, asa_usr.h, asa_usr_asa.h:
Added #ifdef __cplusplus braces.

========================================================================
23 Sep 04

asa.c:
Removed statement that had no effect.

ASA-README.ms, Makefile:
Fixed headers in ASA-README.pdf.  Deleted footers in ASA-README.html.

========================================================================
10 Jun 04

asa_usr.c:
In fitloc(), fixed bug in declaration of x.

========================================================================
13 May 04

Makefile:
Changed zip: Modified to convert all files except .pdf files to DOS.

========================================================================
12 May 04

Makefile:
Changed zip: in Makefile to drop -l flag which corrupts ASA-README.pdf.
Users will have to convert all unzipped files from Unix to Dos.

========================================================================
23 Feb 04

asa.c:
Changed casts in multi_compare() and sort_parallel() to enable compilation
under g++.

========================================================================
19 Feb 04

asa.c:
In asa_exit(), changed *curvature_flag to curvatureFlag, and removed
associated calloc() and free().

========================================================================
11 Feb 04

asa_usr.c:
Moved memory creation for USER_OPTIONS and OPTIONAL_DATA_PTR to top of
file to permit use of Asa_Data_Ptr for more OPTIONS.

========================================================================
10 Feb 04

asa.c:
Set default ptr_asa_out to NULL.

asa.c, asa.h:
added *multi_cost_qsort and *gener_block_state_qsort.

========================================================================
17 Jan 04

Makefile, ASA-README.ms:
Updated references.

All files:
Updated Copyright.

========================================================================
25 Jul 03

Makefile, asa.c, asa_usr.c, ASA-README.ms:
Some compilers on some systems under some levels of optimization will not
compile if stdout is present in the code.  All instances of stdout and
printf in the user and the asa modules can be commented out by setting
INCL_STDOUT to FALSE.  Note that this also will suppress some output
from such OPTIONS as ASA_PIPE, TIME_CALC, etc.

========================================================================
9 May 03

asa.c, asa_usr.c:
Changed use of LONG_INT in some calloc() to ALLOC_INT.

========================================================================
25 Apr 03

ASA-README.ms, asa_usr.c:
Added caution to examine parameters in fitloc(), passed on to simplex(),
when using FITLOC set to TRUE.

========================================================================
13 Apr 03

asa_usr_cst.c:
Corrected print pointer, active when TIME_CALC is TRUE.

========================================================================
22 Feb 03

Renamed files to facilitate their use in larger projects:
asa_user.h -> asa_usr_asa.h
user.c -> asa_usr.c
user.h -> asa_usr.h
user_cst.c -> asa_usr_cst.c
readme.ms -> ASA-README.ms
test_asa -> asa_test_asa
test_usr -> asa_test_usr

========================================================================
12 Feb 03

asa.c:
ASA_PIPE_FILE prints out first header line with a "%" as first character,
which can provide a useful comment signal to a graphics tool, replacing
the previous "#".

========================================================================
6 Jan 03

readme.ms:
Added section Generic ASA Interfaces

========================================================================
1 Jan 03

updated copyright in all files.

========================================================================
5 Nov 02

user.c, user_cst.c:
In cost_function(), removed (LING_INT) cast, and cast indices to ALLOC_INT.

========================================================================
31 Oct 02

readme.ms:
Added note that, when using MULTI_MIN, Most likely, the minimum of
USER_OPTIONS->Multi_Number and USER_OPTIONS->N_Accepted should be set
to USER_OPTIONS->Multi_Number for further use.

========================================================================
23 Oct 02

user.c:
Deleted static from *rand_seed and *recur_rand_seed which is a bug when
using ASA_LIB.

========================================================================
12 Oct 02

Updated copyright date and prepared docs on Cygwin.

========================================================================
14 Aug 02

user.c, user_cst.c:
In ASA_TEST in cost_function(), cast (LONG_INT) *parameter_dimension.

========================================================================
3 Jun 02

asa.c, asa.h, asa_user.h, Makefile, readme.ms, user.c:
Changed pre-compile OPTIONS MULTI_NUMBER to adaptive
USER_OPTIONS->Multi_Number.

========================================================================
22 Apr 02

asa.h, user.c, user.h:
To permit compilation under g++ as well as gcc, moved initializations
from user.h to user.c to avoid problems using user_cst.c, and changed
global exit_msg[] to user_exit_msg[] in user.c and to exit_msg[] in asa.h.

========================================================================
19 Apr 02

readme.ms:
The code is stable and therefore the ASA_List no longer is necessary.


========================================================================
5 Mar 02

asa.c, asa.h, readme.ms:
Print out values of parameters dropped out of sampling by setting
minimum = maximum.

========================================================================
29 Oct 01

readme.ms:
Changed ingber_fees.html to ingber_terms.html.

========================================================================
12 Oct 01

readme.ms:
Renamed ASA-README and ASA-README+ to ASA-README.txt and ASA-README+.txt.

========================================================================
11 Oct 01

NOTES, readme.ms:
Changed FILE.ps.gz references to FILE.pdf references.

Added ASA-README.pdf to source code.

========================================================================
14 Sep 01

NOTES, readme.ms:
Added info on using QUENCHing for large parameter dimensions.

========================================================================
27 Aug 01

readme.ms:
Added comment re if MULTI_NUMBER is larger than the actual number of
accepted states, then there will be a set of duplicate states returned
which likely should be filtered via a unique macro.

========================================================================
11 Aug 01

NOTES, readme.ms:
Added .txt suffix to 00index.txt, asa_contrib.txt, asa_examples.txt,
asa_new.txt, and ingber_fees.txt.

readme.ms:
Added info about ASA-README.pdf in the www.ingber.com archive.

========================================================================
1 Aug 01

asa.c, asa_user.h, Makefile, readme.ms:
When USER_ACCEPT_THRESHOLD is TRUE, a  simple alternative to the Boltzmann
function becomes available for the acceptance test, simply defining 
the probability of acceptance to be 1 if delta_cost <= cost_temp and
0 otherwise.

========================================================================
19 Jul 01

asa.c, asa.h, readme.ms, user.c, user.h, user_cst.c:
Setting the lower bound equal to the upper bound will remove a parameter
from consideration.  Whenever this occurs, within asa() the effective
dimension defining the size of the search space is reduced by the number
of parameters so removed.

========================================================================
21 Jun 01

asa.c:
Fixed bug in use of ASA_PRINT with MULTI_MIN.

========================================================================
14 Jun 01

asa.h, asa_user.h, user.h:
Added protective #define wrappers.

========================================================================
13 May 01

readme:
Changed to file utils_file_formats.txt.

========================================================================
4 May 01

readme:
Added user_cst.c to
gcc -g -DASA_TEST=TRUE -o asa_run user.c user_cst.c asa.c -lm

========================================================================
27 Mar 01

asa.c:
Put all calloc initializations before first call to cost function.
If the first call to cost function returns an invalid state, then memory
is correctly freed before exiting asa().

========================================================================
16 Mar 01

asa_user.h, user.c, user.h, readme.ms:
The default name of the cost function is cost_function.  This can be
changed in asa_user.h (or the Makefile) by defining USER_COST_FUNCTION.
When SELF_OPTIMIZE is TRUE, the default name of the recur cost function is
recur_cost_function.  This can be changed in asa_user.h (or the Makefile)
by defining RECUR_USER_COST_FUNCTION.  This of course requires compiling
in the new cost function(s) and prototype(s).

========================================================================
20 Feb 01

*.[ch]
Changed indenting to `gindent -br -brs -ce -cdw -nut -sob -pmt`.

========================================================================
25 Jan 01

readme.ms:
The background image file asa_back.jpg referenced in ASA\-README.html can
be downloaded as http://www.ingber.com/asa_back.jpg from the ASA archive.

========================================================================
24 Jan 01

readme.ms:
Added note on availability of support for ASA_PARALLEL in asa_contrib.

========================================================================
17 Jan 01

asa.c, asa.h, readme.ms:
When ASA_PARALLEL is TRUE, each block of generated states is sorted to
permit the lowest cost functions to pass first through the acceptance
test.

========================================================================
14 Jan 01

Makefile, NOTES, readme.ms, user.c, user_cst.c:
Changed user_cst.h to user_cst.c.

========================================================================
30 Dec 00

Updated copyright.

========================================================================
19 Dec 00

readme.ms, user.c, user.h:
Put SHUFFLE in user.h, and changed "256" random dimensions to SHUFFLE
in user.c.  Removed creation and freeing of memory for Random_Array as
this is pointed to static random_array.

========================================================================
18 Dec 00

asa.c:
Deleted extra fclose(ptr_save); line used when ASA_SAVE is TRUE.

asa.c, readme.ms:
When ASA_SAVE is set to TRUE, Number_Cost_Samples is set to 1 after
the initial run.

========================================================================
12 Dec 00

readme.ms:
Emphasized free use of code.

========================================================================
28 Nov 00

readme.ms:
Updated reference to utilities.

========================================================================
26 Nov 00

NOTES, readme.ms:
Merged all files under MISC.DIR into main ingber.com directory.

========================================================================
17 Nov 00

Changed indenting to version GNU indent 2.2.6.

========================================================================
24 Oct 00

readme.ms, user.h, user.c:
randflt() calls resetable_randflt() each time to implement the RNG.
This is to provide the capability of getting the same runs if the same
multiple calls to asa() are made, e.g., when using ASA_LIB set to TRUE.

========================================================================
19 Sep 00

user.c:
Changed initialization of random generator to enforce consistent
first random number generated upon multiple calls to asa_main() when
ASA_TEMPLATE_LIB is set to TRUE.  This changes test_asa and test_usr.

========================================================================
7 Sep 00

Makefile, asa_user.h, readme.ms, user.c:
Changed cast on Asa_Data_Ptr to OPTIONAL_PTR_TYPE.
========================================================================
21 Aug 00

NOTES, readme.ms:
Only RATFOR version of VFSR is included in asa_contrib.

========================================================================
2 Aug 00

NOTES:
Included reference to old 1987 RATFOR and FORTRAN VFSR code contained
in asa_contrib.

Makefile:
Added zip: target.

readme.ms:
ASA-shar is dropped from the archive, as ASA.tar.gz and ASA.zip are now
sufficient for practically all users.

========================================================================
29 Jul 00

readme.ms:
Included reference to old 1987 RATFOR and FORTRAN VFSR code contained
in asa_contrib.

========================================================================
21 Jul 00

readme.ms:
Changed reference to ASA code to Caltech Alumni Association, properly
given to the internet archive that first published the code and maintains
email addresses for the ASA_list

========================================================================
26 May 00

asa.c, user.c:
Fixed 2 leaks when MULTI_MIN is TRUE.

========================================================================
19 May 00

user.c:
Fixed OPTIONAL_DATA_PTR wrapper around data_ptr_flg.

========================================================================
13 May 00

user.c:
Fixed free() bug if data_ptr_flg is 0 in SELF_OPTIMIZE section.

========================================================================
10 May 00

user.c:
Updated SELF_OPTIMIZE section to be able to use asa_opt_recur file.

user.c, user.h:
Pass name of cost function to fitloc() so it can be used recursively.

asa.c, asa_user.c, readme.ms, user.c:
Modified ASA_SAVE to be effective at highest level of recursion.

========================================================================
9 May 00

asa_user.c, readme.ms, user.c:
Modified OPTIONAL_PTR_TYPE for multiple names at general levels of
recursion.

asa.c, asa_user.c, readme.ms, user.c:
Added OPTIONS->Asa_Recursive_Level.

========================================================================
8 May 00

user.c:
Added MULTI_MIN capability to SELF_OPTIMIZE section.

asa_user.c, readme.ms, user.c:
Modified OPTIONAL_PTR_TYPE for general levels of recursion.

========================================================================
5 May 00

user.c, readme.ms:
If OPTIONAL_DATA_PTR is being used for RECUR_USER_OPTIONS as well
as for USER_OPTIONS, do not create (or free) additional memory in
recur_cost_function() for Asa_Data_Dim_Ptr and Asa_Data_Ptr to be
passed to the inner cost_function(), but rather link pointers to those
in RECUR_USER_OPTIONS.  Typically, define separate structures within the
structure defined by Asa_Data_Ptr to access info depending on whether the
run in a particular level of cost function in this recursive operation.
In user.c, there are guidelines to set "#if TRUE" to "#if FALSE"
at these points of the code.

========================================================================
3 May 00

asa.c:
Updated changes to Asa_Data_Dbl when ASA_TEMPLATE_SELFOPT is TRUE.

========================================================================
4 Apr 00

asa.c:
Fixed bug in freeing multi_params when MULTI_MIN is TRUE.

========================================================================
15 Mar 00

asa.c:
Corrected reference to last_generated_state to last_saved_state.

========================================================================
28 Feb 00

user.c:
Sharpened accuracy of bound testing when FITLOC is TRUE.

========================================================================
25 Feb 00

asa.c, asa_user.c, readme.ms:
Changed from use of system() to popen() when ASA_SAVE or ASA_SAVE_BACKUP
is TRUE.

========================================================================
21 Jan 00

NOTES, readme.ms:
Added a section in NOTES, Some Tuning Guidelines.

asa.c:
Added the last_saved_state cost function to output from ASA_PIPE
and ASA_PIPE_FILE.

========================================================================
18 Jan 00

readme.ms:
Added short abstract to first page.

========================================================================
29 Dec 99

asa.c:
Corrected some pointer bugs when ASA_SAVE and MULTI_MIN are both TRUE.

========================================================================
28 Dec 99

asa.c, readme.ms, user.c:
Deleted Cauchy and Gaussian examples under USER_GENERATED_FUNCTION, as
extra care usually is needed by user the to handle parameter ranges.

========================================================================
26 Dec 99

asa.c:
Set default size of arrays created under ASA_QUEUE to 1 if Queue_Size
is initially zero, to permit proper freeing of memory when leaving asa()
in case Queue_Size is set to zero adaptively.

========================================================================
8 Dec 99

Makefile, asa.c, asa_user.h, readme.ms:
If ASA_SAVE_OPT is set to TRUE, when asa is restarted, if the file
asa_opt_save is present in the same directory as asa_opt, then new values
of ASA parameters and OPTIONS are read in after initializing to the
point of the last writing of asa_save, without requiring recompilation.

readme.ms:
Added note on availability of MATLAB interface in asa_contrib.

========================================================================
30 Nov 99

Makefile, readme.ms:
Use psselect to put contents after cover page in ASA-README.ps.

Makefile, asa.c, readme.ms:
Moved some OPTIONS to Printer Options section.

========================================================================
27 Nov 99

asa.c, asa_user.h, user.c:
Put array for temporary storage of exit_msg[] in asa_user.h.

========================================================================
25 Nov 99

asa.c, user.c:
Added char exit_msg[] for Exit_ASA() and Exit_USER() to avoid multiple
warnings of char* conversions under some compilers.

========================================================================
18 Nov 99

asa.c, readme.ms:
If ASA_QUEUE and ASA_PRINT_MORE are TRUE then, whenever a queued cost
function is used, this is recorded in asa_out.

========================================================================
16 Nov 99

asa.c, asa_user.h, readme.ms, user.c;
ASA_QUEUE and ASA_RESOLUTION may be used separately or together, creating
somewhat different sampling procedures.

========================================================================
14 Nov 99

asa_user.h, readme.ms:
When ASA_SAVE_BACKUP is TRUE, ASA_SAVE is automatically set to TRUE
in asa_user.h.

========================================================================
13 Nov 99

Makefile, asa_opt, asa.c, asa_user.h, readme.ms, user.c:
If ASA_SAVE is set to TRUE, when ASA_SAVE_BACKUP is set to TRUE, asa
saves enough information after each newly best accepted state to restart
from any previous best accepted state when that asa_save.{best_state}
is copied to asa_save.  The new asa_opt file (with modified first and
last lines) can be used to insert new code before restarting runs.

========================================================================
10 Nov 99

readme.ms:
Added more references to arrays to be developed under several OPTIONS,
adding more hyperlinks in ASA-README.html.

========================================================================
4 Nov 99

asa.c:
ASA_PIPE_FILE prints out first header line with a "#" as first character,
which can provide a useful comment signal to a graphics tool.

asa.h, asa_user.h:
Moved G_FIELD and G_PRECISION defines to asa_user.h.

========================================================================
21 Oct 99

asa.c:
fclose (ptr_asa_pipe).

========================================================================
19 Oct 99

Makefile, asa.c, asa_user.h, readme.ms:
When ASA_PIPE_FILE is set to TRUE, asa prints to asa_pipe lines of data
that can be used to examine run data.

========================================================================
30 Sep 99

user.c:
Added some more info around some TEMPLATEs.

Makefile, asa.c, asa_user.h, readme.ms, user.c:
Changed OPTIONAL_DATA, Asa_Data_Dim, and Asa_Data, to
OPTIONAL_DATA_DBL, Asa_Data_Dim_Dbl, and Asa_Data_Dbl.

========================================================================
29 Sep 99

Makefile, asa.c, asa_user.h, readme.ms:
Added OPTIONAL_DATA_PTR to return/pass additional array or structure
information of type OPTIONAL_PTR_TYPE to the user module from/through
the asa module.

Makefile, asa.c, asa_user.h, readme.ms:
Added ASA_PIPE to print to STDOUT lines of data after calls to the cost
function, which can be used to update databases or graphs in real time.

ASA-README.html:
Added asa_back.jpg file (asa_back.jpg.uu in the shar version).

========================================================================
21 Sep 99

asa.c, readme.ms, user.c:
Added comments re use of USER_ACCEPT_ASYMP_EXP to be used as a template
for USER_ACCEPTANCE_TEST.  Moved some declarations inside #if
statements to avoid unnecessary warnings of unused variables.

========================================================================
8 Sep 99

asa.c, asa.h, readme.ms:
Added INVALID_COST_FUNCTION_DERIV with an exit code of 9, to tell user
when an invalid cost function or parameter is developed within the
calculation of numerical derivatives, causing an asa() exit.

========================================================================
19 Aug 99

NOTES, readme.ms:
All .Z files changed to .gz files.  ASA is now available in ASA.tar.gz,
ASA.zip and ASA-shar formats.

========================================================================
28 Jul 99

Makefile:
Modified CC to use profile.

========================================================================
15 Feb 99

ASA-README.html:
Changed color of background for easier viewing.

========================================================================
7 Feb 99

Makefile, asa_user.h, readme.ms, user.c:
Added USER_OUT to permit naming of user output file, defaults to "user_out."

========================================================================
4 Feb 99

readme.ms, user.c:
If FITLOC is TRUE, a value of Fit_Local set >= 1 is required to enter
the local code.  If Fit_Local is set to 2, any better fit found by the
local code better than asa() is ignored if that local fit is achieved
by violating the ranges of the parameters.

========================================================================
27 Jan 99

asa.c:
Corrected a few casts used when ASA_SAVE is TRUE.

========================================================================
15 Jan 99

asa.c, asa.h, readme.ms:
Generalized the macro COST_FUNCTION_TEST to the function
cost_function_test() to return exit_code INVALID_COST_FUNCTION if the
user returns either an invalid cost function value or a parameter that
lies outside the proper range.

========================================================================
26 Sep 98

asa.c, asa.h, readme.ms, user.c, user.h:
CALLOC_FAILED = -1.  Calloc memory allocation has failed in asa.c.
This error will call Exit_ASA(), the location will be printed to
stdout, and asa() will return  the double -1 to the calling program.
In user.c, if asa() returns this *exit_code a warning will be printed
both to stdout and to user_out.

asa_main() now returns an integer.  main() or asa_main() returns 0 for
a normal run, -1 if any calloc allocation has failed in asa.c, or -2 if
any calloc allocation has failed in user.c.

initialize_parameters() and recur_initialize_parameters() also now
return integers, 0 for a normal run or -2 if any calloc allocation has
failed.

asa.c:
print_string() and print_string_index() return errors in user input
both to stdout and, if ASA_PRINT is TRUE, to ASA_OUT.

========================================================================
25 Sep 98

ASA-README.html:
Added links to parameters left out by previous macros.

========================================================================
24 Sep 98

ASA-README.html:
Added color to text and background.

========================================================================
12 Jul 98

asa.c:
More print statements added when MULTI_MIN is set to TRUE.

asa.c, asa_user.c, readme.ms, user.c:
If Multi_Specify is set to 0, the selection of best-generated states
includes all sampled instances of the cost functions.  If Multi_Specify
is set to 1, the selection of best-generated states is constrained to
include only those with different values of the cost function.

========================================================================
9 Jul 98

asa.c, readme.ms:
Included some commented alternative code under "cost-value-distinct
best-generated states" which can alter the default selection of all
best-generated states to including only those with different values of
the cost function.

asa.c, readme.ms:
Modified MULTI_MIN algorithm.  Added tests to ensure that Multi_Grid is
greater than EPS_DOUBLE, greater than Coarse_Resolution if
ASA_RESOLUTION is TRUE, and greater than Queue_Size if ASA_QUEUE is
TRUE.

========================================================================
8 Jul 98

asa.c, user.c:
Added print statements to user.c and corrected some code in asa.c when
MULTI_MIN is set to TRUE.

asa.c:
Modified parameters in multi_compare() for non-ANSI compilers.

asa.c, readme.ms:
If MULTI_MIN is TRUE and Curvature_0 is FALSE, all MULTI_NUMBER
curvatures are calculated.

asa.c, readme.ms:
Clarified calculation of the MULTI_NUMBER lowest best-generated sampled
values of the cost function.  Enhanced MULTI_MIN algorithm to include
Multi_Grid.

========================================================================
7 Jul 98

Makefile, asa.c, asa.h, asa_user.h, readme.ms, user.c:
When MULTI_MIN is set to TRUE, the lowest MULTI_NUMBER values of the
cost function and their parameters are saved.

========================================================================
18 Jun 98

readme.ms:
Deleted ftp.alumni.caltech.edu as only www.alumni.caltech.edu is up
most of the time.

========================================================================
29 May 98

readme.ms:
Fixed bug in numbering Contents pages in ASA-README.ps.

========================================================================
26 Apr 98

readme.ms:
Updated references.

========================================================================
9 Jan 98

asa.c, asa_user.h, readme.ms, user.c, user.c:
When FITLOC is TRUE, OPTIONS->Iter_Max determines the maximum
iterations of the cost_function () by simplex ().  This replaces
intermax.

========================================================================
8 Jan 98

user.c:
Added some declarations in calcf() when ASA_RESOLUTION set to TRUE.

========================================================================
28 Dec 97

user.c:
Added reference to simplex code.

========================================================================
18 Dec 97

Makefile, asa.c, asa_user.h, readme.ms, user.c:
When FITLOC is set to TRUE, FITLOC_PRINT controls printing in fitloc ()
and simplex () in the user module.

========================================================================
7 Dec 97

Makefile, asa.c, asa_user.h, readme.ms, user.c:
If FITLOC is set to TRUE and FITLOC_ROUND is TRUE, then each time
parameters are passed to or between the local routines, simplex (),
calcf (), and fitloc (), they are first processed by rounding integers
or respecting rounding according to ASA_RESOLUTION constraints prior to
any further calculations.

========================================================================
5 Dec 97

user.c:
Fixed return of information from fitloc().

========================================================================
1 Dec 97

asa.c:
Fixed bug in test for FITLOC OPTIONS settings.

========================================================================
30 Nov 97

asa.c, asa_user.h, readme.ms, user.c, user.h: 
When FITLOC is TRUE, OPTIONS->Penalty provides adaptive control of
weights for violations of constraints, exceeding boundaries, etc.
Some typos were corrected in the sections added for FITLOC.

Changed name of README's to ASA-README's.

========================================================================
29 Nov 97

Makefile, NOTES, asa.c, asa_user.h, readme.ms, user.c, user.h:
When FITLOC is set to TRUE, three subroutines become active to perform
a local fit after leaving asa ().  This can be useful to shunt asa ()
to a local code after the region of the global fit is known with some
confidence, which many times is an efficient procedure.

Changed the default of IO_PROTOTYPES to FALSE since newer operating
systems require this.

README.html is now bundled together with the ASA code.

========================================================================
7 Nov 97

asa.c, asa.h:
Removed ASA_PRINT constraints around TIME_CALC so time routines
can be used by the user module even when ASA_PRINT is FALSE.

========================================================================
27 Oct 97

readme.ms:
Updated ICONIP'96 reference.

========================================================================
28 Aug 97

asa.h:
Added NaN test to COST_FUNCTION_TEST(x).

asa.c:
Corrected test on Curvature_0.

========================================================================
26 Aug 97

asa.c, asa.h, readme.ms:
The exit flag INVALID_COST_FUNCTION is set to 8 when the user returns a
value of the cost function to asa () which is not a valid number, e.g.,
not between -MAX_DOUBLE and MAX_DOUBLE.

Updated Locate_Cost.  The value is printed out when exiting asa().

========================================================================
23 Aug 97

asa.c, readme.ms:
ASA_RESOLUTION acts at max and min boundaries similar to how integers
are treated.  ASA_RESOLUTION takes precedence over parameter_type []
when parameter_type [] is integral when calculating new generated
parameters.

========================================================================
6 Aug 97

NOTES:
Some exception fault "errors" on some PC compilers that have problems
handling too large and/or too small exponentials  can be circumvented
by setting CHECK_EXPONENT set to TRUE.

asa.c, asa.h, readme.ms:
An additional module for using TIME_CALC set to TRUE, setting
TIME_GETRUSAGE to FALSE, is more portable to compile across some
platforms, but it can require different parameters for timing results.

========================================================================
15 Jul 97

readme.ms:
Changed to Chicago address.

========================================================================
25 Jun 97

user.c:
Added alternative RNG.

========================================================================
20 Jun 97

readme.ms:
Filled out URLs for several files, e.g., so they will be active in
ASA-README.html.

========================================================================
17 Jun 97

readme.ms:
Separated fees from documentation.

========================================================================
14 Jun 97

readme.ms:
Clarified use of DEFINE_OPTIONS and OPTIONS.

========================================================================
8 Jun 97

readme.ms:
Included information on access-via-email.

========================================================================
6 Jun 97

readme.ms:
Corrected some typos in descriptions of OPTIONS_FILE_DATA and
RECUR_OPTIONS_FILE_DATA.

ASA-README.html:
Renamed from README.html.  This file will not be included with the
code, but made available in the archive.

========================================================================
5 Jun 97

README.html:
Removed <PRE>...</PRE> format.

========================================================================
4 Jun 97

README.html:
Added cross-references among subsections.

========================================================================
31 May 97

Makefile, readme.ms
Added README.html from README.  Corrected some header section titles.

========================================================================
29 May 97

readme.ms:
Added section Use of Documentation for Tuning.

========================================================================
18 May 97

readme.ms:
Added information on fees and contributions.

========================================================================
12 May 97

readme.ms:
Updated reference to ASA code.

========================================================================
8 May 97

readme.ms:
Updated URL information.

========================================================================
13 Apr 97

readme.ms:
Added info about private directory.

========================================================================
24 Mar 97

readme.ms:
Updated references.

========================================================================
2 Mar 97

readme.ms:
Changed format of README and README+.

========================================================================
3 Feb 97

readme.ms:
Changed a typo, using cost_exit instead of cost_flag.

========================================================================
10 Jan 97

asa.c, asa_user.h, readme.ms, user.c:
In asa_user.h, the OPTIONS *Best_Cost and *Best_Parameters are pointers
to the saved best state calculated in asa(), and Locate_Cost is set to
12 instead of 2 if newly generated parameters enter the cost function
just after a new best state is achieved.  The ASA_TEMPLATE just after
the comment MY_TEMPLATE_diminishing_ranges in user.c illustrates the
use.

asa.c, asa_user.h, readme.ms, user.c:
Similarly, in asa_user.h, the OPTIONS *Last_Cost (replacing Last_Cost,
used when USER_ACCEPTANCE_TEST is TRUE) and *Last_Parameters are
pointers to the last saved state calculated in asa().

========================================================================
30 Dec 96

readme.ms:
Updated references.

========================================================================
20 Dec 96

all files:
Updated Copyright notice to 1997.

========================================================================
9 Dec 96

asa.c, asa_user.c, readme.ms:
Locate_Cost is a flag set in asa(), telling at what point the cost
function is being called.

========================================================================
4 Dec 96

readme.ms:
Removed references to a_file.

========================================================================
30 Nov 96

asa.c, readme.ms:
Immediate_Exit saved upon entering cost_derivatives() or when
reannealing the cost temperature, and restored to that value upon
leaving.

========================================================================
22 Nov 96

NOTES, readme.ms:
Added section on Judging Importance-Sampling.

========================================================================
20 Nov 96

readme.ms:
updated references

========================================================================
13 Nov 96

CHANGES:
Added entries back to 1992.

readme.ms:
updated references

========================================================================
3 Nov 96

readme.ms:
Added reference to asa_contrib that contains source code for
doubly-linked and hashed lists that can be used for ASA_QUEUE.

========================================================================
15 Sep 96

NOTES, asa.c, readme.ms, user.c, user.h:
When USER_GENERATING_FUNCTION is true, the functions defined by
Generating_Distrib [user_generating_distrib(), and
recur_user_generating_distrib() if SELF_OPTIMIZE is TRUE] include the
passed array last_saved_parameter[].  This array contains all the last
saved parameters, which are sometimes required for algorithms requiring
decisions based on all current parameters.

========================================================================
11 Sep 96

readme.ms:
Updated references.

========================================================================
16 Aug 96

Makefile, NOTES, asa.c, asa_user.h, readme.ms:
Added QUENCH_PARAMETER_SCALE and QUENCH_COST_SCALE, to independently
control the influences of the quenching scales on the temperature
scales and the temperature indexes.

========================================================================
24 Jul 96

readme.ms:
Updated references.

========================================================================
3 Jul 96

readme.ms:
Updated references.

========================================================================
14 Jun 96

Makefile, asa_opt, readme.ms:
Added MY_TEMPLATE_[...] locations in Makefile and reformatted white
space in asa_opt to facilitate use of scripts to alter new versions of
ASA for user problems.

========================================================================
13 Jun 96

user.c:
Added 3 MY_TEMPLATE locations after calls to asa ().

========================================================================
10 June 96

asa.c, asa_user.h, readme.ms, user.c:
Changed all occurrences of MY_COST in user.c to distinct names of type
MY_TEMPLATE_[...] to aid user-defined insertions of code in user.c and
in asa_user.h when MY_TEMPLATE is set to TRUE (the default).

========================================================================
9 Jun 96

readme.ms, user.c:
If the value of seed fed to asa_seed() is less than 0, this signals the
default randflt() to initialize the array of seeds to be shuffled.
This is especially useful when using repeated calls to asa_main() when
ASA_LIB is TRUE.

asa.c:
Corrected bug in testing whether to bypass derivative calculations in
asa_exit().

========================================================================
22 May 96

readme.ms:
Updated references.

========================================================================
9 May 96

readme.ms:
Updated references.

========================================================================
2 May 96

readme.ms:
Changed location of directory for transferring private files from
LIMBO.DIR to public_html.  Such files now can be retrieved via WWW or
FTP.

readme.ms:
Corrected indenting of several items in Contents.

========================================================================
29 Apr 96

readme.ms:
Updated references.

========================================================================
22 Apr 96

Makefile, asa.c, asa_user.h, user.c, readme.ms:
When USER_ACCEPT_ASYMP_EXP is TRUE, an asymptotic form of the
exponential function as an alternative to the Boltzmann function
becomes available for the acceptance test.  A parameter
OPTIONS->Asymp_Exp_Param becomes available, with a default of 1.0
giving the standard Boltzmann function.

========================================================================
19 Apr 96

asa.c:
Made index_cost_constraint available when either USER_INITIAL_COST_TEMP
or USER_REANNEAL_COST is FALSE, and corrected test on
User_Cost_Temperature.

========================================================================
16 Apr 96

readme.ms:
Corrected some archive addresses.

========================================================================
10 Apr 96

Makefile, asa.c, asa.h, asa_user.h, readme.ms:
Moved MIN_EXPONENT and MAX_EXPONENT from static variables in asa.c to
#define's in asa.h.  When CHECK_EXPONENT is TRUE, EXPONENT_CHECK(x) in
asa() checks that an exponent x is within a valid range and, if not,
adjusts its magnitude to fit in the range.

========================================================================
8 Apr 96

user.c:
Changed rand_seed to recur_rand_seed when ASA_TEMPLATE_SELFOPT is TRUE.
Changed cast in fprintf for ALLOC_INT recur_v.

========================================================================
7 Apr 96

readme.ms:
Updated new ftpmail address.

========================================================================
6 Apr 96

Makefile, asa.c, asa_user.h, readme.ms, user.c:
When ASA_TEST_POINT is set to TRUE, the precise system referenced in
user.c in used instead of the ASA_TEST system used by many
researchers.  This system is solved in asa_examples.

========================================================================
4 Apr 96

asa.c:
Moved an #endif to its proper place!

========================================================================
12 Mar 96

NOTES, readme.ms:
Added comments on use of QUENCH_PARAMETERS OPTIONS to create a hybrid
global-local adaptive quenching search algorithm, e.g., together with
USER_REANNEAL_PARAMETERS set to TRUE.

========================================================================
29 Feb 96

readme.ms:
Deleted 0lower.dir as this was not being used.

========================================================================
12 Feb 96

readme.ms:
Corrected a couple of typos re location of new archive.

========================================================================
4 Feb 96

NOTES, readme.ms:
Removed pgp-2.6.2 info from commercial archive.

========================================================================
18 Jan 95

readme.ms:
Added reference to a new UTILS.DIR/CODE.DIR storing most of the code
described in the files in UTILS.DIR.

========================================================================
16 Jan 95

readme.ms:
Added reference to same file structure under ingber/ for both WWW and
FTP access.

========================================================================
15 Jan 95

asa.c, asa.h, asa_user.h, readme.ms:
Moved all FDLIBM code to MISC.DIR/asa_contrib.

asa.h:
Moved FDLIBM code to MISC.DIR/asa_contrib so that these routines can be
placed independently in the asa or the user module.

readme.ms:
Cleaned up a few typos.

========================================================================
13 Jan 96

NOTES, asa.c, readme.ms:
The file MISC.DIR/asa_contrib in the ASA archive contains some code
contributed by users; this file may evolve into an index for a separate
directory.  There is a CONTENTS of sections headers that can be used to
search on topics in your browser or editor.

The file MISC.DIR/asa_examples in the ASA archive contains some example
problems using ASA.  There is a CONTENTS of sections headers that can
be used to search on topics in your browser or editor.

========================================================================
10 Jan 96

NOTES:
Added some background correspondence to section on @@Quenching.

========================================================================
8 Jan 96

asa.c:
Cleaned up some printing statements in test_asa().  Bypass most
printing within asa_exit() if *exit_status = INVALID_USER_INPUT.

asa.c, asa.h:
Added print_string_index() to print out index with descriptive string
if *exit_status = INVALID_USER_INPUT.

========================================================================
6 Jan 96

user.c, user_cst.h:
In ASA_TEST, changed d[i] to d_i.

========================================================================
5 Jan 96

NOTES:
Added instructions on how to use quenching to solve the 12-dimensional
ASA_TEST problem.

user.c, user_cst.h:
Changed dimension statement for d[4] in ASA_TEST to permit easy
modifications of *parameter_dimension from asa_opt.

========================================================================
1 Jan 96
All files:
Updated Copyright notice to include 1996.

========================================================================
30 Dec 95

asa.c:
Use fabs when calculating standard deviations to avoid any problems
with roundoff.

Makefile, asa.h, asa.c, asa_user.h, readme.ms:
Removed use of MAX_INTEGER and INTEGER_TOO_LARGE.

========================================================================
29 Dec 95

asa.c:
When Number_Cost_Samples < -1 and when Reanneal_Cost > 1 or < -1, added
EPS_DOUBLE to the calculated cost temperature in case sampling selects
states all with same values of the cost function.

Makefile, asa.h, asa.c, asa_user.h, readme.ms:
Added DEFINE_OPTIONS MAX_INTEGER=99999 and *exit_code
INTEGER_TOO_LARGE=6.  These can give important control and feedback for
different tuning when reannealing.

========================================================================
19 Dec 95

asa.c, readme.ms:
When Reanneal_Cost < -1 or > 1, when periodically reannealing, the
initial and current cost temperatures or just the initial cost
temperature, resp., are calculated as a deviation over a sample of cost
functions.

========================================================================
17 Dec 95

NOTES, readme.ms:
Added comments to section on Efficiency Versus Necessity in the README
on the importance of doing homework on a system in addition to
implementing ASA.

========================================================================
15 Dec 95

NOTES, asa.c, readme.ms:
The NOTES contains some contributed code in the section @@Hashed Lists
for ASA_QUEUE.  This may be useful for some systems.

========================================================================
8 Dec 95

readme.ms:
Changed file name asa_new-X.Y back to asa_new, as some people were
having browser problems trying to locate previous versions of
asa_new-X.Y.

========================================================================
7 Dec 95

user.c:
Added credit for asa_seed().

readme.ms:
Added description of asa_seed().

readme.ms:
Changed publication date of asa95_lessons to asa96_lessons.

user.h:
Added main() prototype for ASA_TEMPLATE_LIB=TRUE.

asa_user.h:
Defined ASA_TEST=TRUE to be part of ASA_TEMPLATE=TRUE.

user.c:
Added printout to stdout in main() defined for ASA_TEMPLATE_LIB=TRUE.

========================================================================
6 Dec 95

asa.c:
Fixed bug in using STDOUT to print output to stdout.

NOTES, readme.ms, user.h, user.c:
When ASA_LIB is TRUE, the function asa_seed() becomes available to set
the initial random seed.  ASA_TEMPLATE_LIB=TRUE illustrates this use.

========================================================================
5 Dec 95

Makefile, asa.c, asa_user.h, readme.ms, user.h, user.c:
Added ASA_TEMPLATE_LIB permitting passing of parameters using asa_main().

asa.c:
Added test to check that initial parameters are within bounds.

========================================================================
1 Dec 95

readme.ms:
Corrected typos in section headers of Asa_Data_Dim_int.

========================================================================
20 Nov 95

readme.ms:
Mentioned availability of ASA-README.txt and ASA-README.ps.Z in the
archive.  Corrected typo in last section.

========================================================================
17 Nov 95

readme.ms:
Included LICENSE in the README.

========================================================================
16 Nov 95

asa.c, readme.ms:
When OPTIONS->Immediate_Exit is set to TRUE, asa() exits without
calculating any closing tangent or curvature arrays.

========================================================================
4 Nov 95

asa.c, readme.ms:
Modified Maximum_Cost_Repeat to permit a value of 0 to bypass this
test.

readme.ms:
Noted similar treatment of the cost temperature using
Number_Cost_Samples and Reanneal_Cost.

========================================================================
3 Nov 95

asa.c, readme.ms:
If Reanneal_Cost < -1, then the current cost temperature is calculated
as the deviation over a sample of -Reanneal_Cost number of cost
functions.

readme.ms:
Corrected description of calculation when Reanneal_Cost < -1.

========================================================================
1 Nov 95

asa.c:
Changed cast to produce integers in generate_new_state() from (int) to
(LONG_INT).

asa.c, asa_user.h, readme.ms, user.c:
When ASA_RESOLUTION is TRUE, Coarse_Resolution[] defines the resolution
of parameters in the fit.

========================================================================
29 Oct 95

asa.c:
Changed casts on some ASA_QUEUE parameters.
Added EPS_DOUBLE to tests using Queue_Resolution.
Put adaptive formatting for all %g printout, except for TIME_CALC.

readme.ms:
Noted utility of using Queue_Size = 0 for recursive fits, and the
possible compiler warnings of "uninitialized" this may generate.

========================================================================
29 Oct 95

Makefile, asa.c, asa_user.h, readme.ms, user.c:
When ASA_QUEUE is set to TRUE, a FIFO queue saves generated states, to
avoid extra cost function calculations.

========================================================================
28 Oct 95

readme.ms:
Added motivation for use of global optimization to Context section.

========================================================================
22 Oct 95

asa.c:
Corrected some comment statements in reanneal().

readme.ms:
Added markets96_momenta.ps to references.

========================================================================
4 Oct 95

asa.c, readme.ms:
The default reannealed initial cost temperature is taken to be the
minimum of the current initial cost temperature and the maximum of the
absolute values of the best and last cost functions and their
difference.

========================================================================
1 Oct 95

asa.c, readme.ms:
When reannealing the cost temperature, the current cost temperature is
set to the maximum of the current cost temperature and the absolute
value of the difference of the best and last values of the cost
function, constrained not to exceed the current initial cost
temperature.

asa.c, readme.ms, user.c, user.h:
When USER_REANNEAL_COST, added *current_cost_temperature to the
parameter list of Reanneal_Cost_Function(), and change default
reannealing algorithm as just above.

readme.ms:
Edited section on numerical derivatives.

========================================================================
30 Sep 95

asa.c:
Improved readability of output to ASA_OUT.

========================================================================
29 Sep 95

asa.c, asa.h:
Added valid_state_generated_flag and exit_status to list of items in
test_asa_options().  Enhanced printout of reason for invalid options.

readme.ms:
Emphasized that ASA_TEMPLATE, with no suffix, should not be set to
TRUE.

========================================================================
28 Sep 95

asa.c, asa_user.h:
Added some missing (double) casts to EPS_DOUBLE and SMALL_FLOAT.

asa.c, asa.h, readme.ms:
Added test_asa_options() to check parameters and OPTIONS for validity,
before the first call to the cost function, and to print out invalid
options.

asa.c:
Fixed warnings when ASA_PRINT is set to FALSE.

user.c:
Print out exit_code to user_out.

========================================================================
24 Sep 95

asa_opt, user.c, readme.ms:
If OPTIONS_FILE_DATA and QUENCH_COST are TRUE, then
*User_Quench_Cost_Scale is read in from asa_opt.  If OPTIONS_FILE_DATA,
QUENCH_COST, and QUENCH_PARAMETERS are TRUE, then
*User_Quench_Cost_Scale and User_Quench_Param_Scale[] all are read in
from asa_opt.

If RECUR_OPTIONS_FILE_DATA and QUENCH_COST are TRUE, then
*User_Quench_Cost_Scale is read in from asa_opt_recur.  If
RECUR_OPTIONS_FILE_DATA, QUENCH_COST, and QUENCH_PARAMETERS are TRUE,
then *User_Quench_Cost_Scale and User_Quench_Param_Scale[] all are read
in from asa_opt_recur.

readme.ms:
Stated that when Reanneal_Cost > 1 or < 1 it is the _initial_ cost
temperature that is being reannealed by being set by the sampled cost
functions.  Because of the fat tail of the parameter temperature
distributions, the current cost temperature is not being directly set
by the sampled cost functions.

========================================================================
16 Sep 95

asa_opt, user.c, readme.ms:
If OPTIONS_FILE_DATA, QUENCH_COST, and QUENCH_PARAMETERS are all TRUE,
then *User_Quench_Cost_Scale and User_Quench_Param_Scale[] all are
read in from asa_opt.

If RECUR_OPTIONS_FILE_DATA, QUENCH_COST, and QUENCH_PARAMETERS are all
TRUE, then *User_Quench_Cost_Scale and User_Quench_Param_Scale[] all
are read in from asa_opt_recur.

========================================================================
15 Sep 95

asa.c, asa.h, readme.ms:
The range of choices to control the initial and the reannealed values
of the cost temperature have been increased by the expanded use of
Number_Cost_Samples and Reanneal_Cost, resp.  The choices include
averaged absolute values or deviations of sampled cost functions.

asa.c, asa.h, readme.ms:
Added INVALID_USER_INPUT[7] to exit codes.

readme.ms:
Added URL format to all references.

========================================================================
14 Sep 95

asa.c, readme.ms:
If Number_Cost_Samples is initially -1, it is set to -2 in asa().

========================================================================
12 Sep 95

asa.c, asa.h, readme.ms, user.c:
When Reanneal_Cost > 1, the reannealed cost temperature is calculated
as the deviation over a sample of Reanneal_Cost number of cost
functions, i.e., the square-root of the difference of the squares of
the first and second moments normalized by the ratio of Reanneal_Cost
to Reanneal_Cost - 1.

asa.c:
When Number_Cost_Samples < -1, the initial cost temperature is
calculated as the deviation over a sample of -Number_Cost_Samples
number of cost functions, i.e., the square-root of the difference of
the squares of the first and second moments normalized by the ratio of
-Number_Cost_Samples to -Number_Cost_Samples - 1.

========================================================================
8 Sep 95

NOTES, readme.ms:
Minor editing changes.

========================================================================
1 Sep 95

readme.ms:
Added smni95_lecture.ps.Z.

CHANGES:
Bug in maintenance software kept deleting old VFSR version numbers in
VERSION DATES section that matched with new ASA version numbers.

========================================================================

19 Aug 95

asa_opt:
Entries used specifically for ASA_TEST are recorded, in case these are
written over during use for other problems.

========================================================================
25 Aug 95

user_cst.h:
Added explicit directions on how to use this file together with asa_opt.

========================================================================
19 Aug 95

user_cst.h:
Changed name of user_cst.c to user_cst.h to prevent possible confusion
when using some PC or Mac compilers to compile all *.c files.

user.c:
Added test to recognize asa_opt under fopen().

NOTES:
Added some info on placing asa_opt file under some PC and Mac compilers.

========================================================================
13 Aug 95

readme.ms:
Added note on the possible necessity of making a transformation of a
discrete parameters to a new parameter which can be expressed as a set
of sequential integers.

========================================================================
8 Aug 95

readme.ms:
Clarified use of Include_Integer_Parameters when used with
parameter_type[].

asa.c:
Fixed bug in cost_derivatives(), in one Include_Integer_Parameters
test, inside of a test of *curvature_flag, requiring adding braces.

========================================================================
6 Aug 95

asa_opt:
Added defaults for integer or real type in comments.

NOTES:
Added some dates to sections where some updates in other files might
give conflicting references.

========================================================================
4 Aug 95

user.c:
Test for values of pid > 99999 or < 0 when using
ASA_TEMPLATE_ASA_OUT_PID.

========================================================================
3 Aug 95

Makefile, asa.c, asa_user.h, readme.ms, user.c:
Added ASA_TEMPLATE_ASA_OUT_PID to permit numbering of asa_out__x and
user_out_x files, where x is the system pid.

Makefile:
Put in FALSE for defaults of ASA_TEMPLATEs.

Makefile, asa_user.h, readme.ms, user.h:
Moved include statement and prototype for ASA_TEMPLATE_ASA_OUT_PID to
user.h from asa_user.h.

========================================================================
15 Jul 95

readme.ms:
Cleaned up some formatting.

========================================================================
14 Jul 95

NOTES, readme.ms:
Added my PGP public key to the NOTES file.

========================================================================
6 Jul 95

readme.ms:
The section on Bug Reports and Help With ASA was expanded to include
statements on confidentiality of all queries, and on arrangements that
can be made to secure queries using the PGP cryptosystem and/or to
exchange large files using FTP.

========================================================================
2 Jul 95

Makefile, readme.ms:
Added user_cst.c to dependencies of user.o.

========================================================================
14 Jun 95

Makefile, NOTES, asa_user.h, readme.ms, user.c, user_cst.c:
Added user_cst.c containing cost_function() to the distribution as a
trimmed version of the ASA_TEST problem.  The default for COST_FILE is
now TRUE.  The version with more documentation and hooks for various
templates is cost_function() in user.c

readme.ms:
Added notes that N_Accepted and N_Generated typically will have values
less in the cost function than in the ASA_OUT file, since these are
only incremented after passing some tests back in asa().

========================================================================
9 Jun 95

asa_user.h:
Removed INT_ALLOC set to TRUE which slipped in during a test run.
Added MY_TEMPLATE example at top of file.

========================================================================
5 Jun 95

readme.ms:
Updated status of referenced paper.  Added information on construction
of individualized TEMPLATEs.

NOTES:
Added some information to FORTRAN Issues section.

========================================================================
30 May 95

user.c:
Corrected cast on read_long when INT_LONG is FALSE.

asa.c:
Corrected cast in fprintf statement for *seed.

readme.ms, user.c, user.h:
Changed cast on asa_main() to void().

========================================================================
30 May 95

readme.ms:
Updated names of some files in archive.

========================================================================
25 May 95

readme.ms:
Changed asa_new to asa_new-X.Y, where X and Y are current version
numbers.  Added to references those reprints available in archive.

========================================================================
23 May 95

readme.ms:
The new WWW address is http://www.alumni.caltech.edu/~ingber/.

========================================================================
16 May 95

readme.ms:
Added trailing slash to http://alumni.caltech.edu/~ingber/ as this was
causing Caltech server to make an extra connection each access not
using this slash.

========================================================================
30 Apr 95

NOTES, readme.ms:
Added section Number of Generated States Required, recommending use
of log-log plots to extrapolate to the number of generated states
required to achieve a global minimum.

========================================================================
23 Apr 95

Makefile, NOTES, asa.c, asa_user.c, readme.ms, user.c:
The special ASA_TEMPLATEs used for examples are now tagged with
{ASA_TEMPLATE_MULTIPLE, ASA_TEMPLATE_SELFOPT, ASA_TEMPLATE_SAMPLE,
ASA_TEMPLATE_PARALLEL, ASA_TEMPLATE_SAVE}; the sets of Pre-Compile
OPTIONS these use are defined in asa_user.h.

========================================================================
19 Apr 95

asa.c, readme.ms:
Modified reanneal() to set the scale of the annealing of the cost
temperature within the scale of the minimum of the current cost
temperature and the absolute values of the current best and last saved
minima.

user.c:
Added example in user_reanneal_cost() to illustrate bypassing the
resetting of the current cost temperature.

========================================================================
17 Apr 95

readme.ms:
Added 1995 ASA paper that has been accepted for publication.

========================================================================
16 Apr 95

asa.c, asa_user.c, user.c:
Changed {exp, log, pow} to {F_EXP, F_LOG, F_POW} to clean up code.  The
new functions select pre-compile choices between {exp, log, pow} and
{s_exp, s_log, s_pow}, depending on {FALSE, TRUE} selected for
{FDLIBM_EXP, FDLIBM_LOG, FDLIBM_POW}.

========================================================================
13 Apr 95

readme.ms:
In the User Options section, emphasis is placed on the ability to
calculate defaults when the Program Options or the DEFINE_OPTIONS pull
in new code.

asa.c, asa_user.h, readme.ms, user.c:
In reanneal(), the algorithm for rescaling the initial cost function
temperature is now taken to be the min of the initial cost temperature
and the max of {cost_best, cost_last, EPS_DOUBLE}, to handle cases
where at the time reanneal() is called the cost function might be at
zero or going from a positive value through zero on its way to a
negative value.

CHANGES, Makefile, NOTES, asa.c, asa_opt, asa_user.h, readme.ms, user.c:
Program Options used to trigger required settings of additional Program
Options of arrays in the user module, {User_Initial_Cost_Temp,
Ratio_Temperature_Scales, User_Initial_Parameters_Temps,
Delta_Parameters, Quench_Parameters, Quench_Cost}, were moved to
DEFINE_OPTIONS, {USER_INITIAL_COST_TEMP, RATIO_TEMPERATURE_SCALES,
USER_INITIAL_PARAMETERS_TEMPS, DELTA_PARAMETERS, QUENCH_PARAMETERS,
QUENCH_COST}, and they were removed from asa_opt.

========================================================================
12 Apr 95

asa.c, user.c, user.h:
In reanneal() in asa.c, added EPS_DOUBLE to calculation of
*initial_cost_temperature to prevent problems when cost_last goes to
zero when entering reanneal().  Such circumstances still require use of
Reanneal_Cost_Function to perform some alternative algorithm in
user_reanneal_cost() and recur_user_reanneal_cost().

Makefile, asa.c, asa_opt, asa_user.h, user.c, readme.ms:
Moved OPTIONS Maximum_Reanneal_Index and Reanneal_Rescale to
DEFINE_OPTIONS MAXIMUM_REANNEAL_INDEX and REANNEAL_SCALE, since they
likely are not ever used adaptively.  Maximum_Reanneal_Index  and
Reanneal_Rescale have been removed from asa_opt.

NOTES, readme.ms:
Moved discussion from NOTES to readme.ms on which options to put into
the Program Options and which to put into the DEFINE_OPTIONS.

========================================================================
6 Apr 95

readme.ms:
Put in caution statements for the FDLIBM codes:  "This code should
first be tested with the standard ASA_TEST OPTIONS to see if the
resulting asa_out file agrees with the test_asa file."

========================================================================
2 Apr 95

asa.c, readme.ms:
When OPTIONS->Acceptance_Frequency_Modulus is 0, *number_accepted is
not tested in the PERIODIC TESTING/REANNEALING/PRINTING SECTION.
When OPTIONS->Generated_Frequency_Modulus is 0, *number_generated is
not tested in the PERIODIC TESTING/REANNEALING/PRINTING SECTION.

========================================================================
26 Mar 95

asa.c, asa_user.h, readme.ms, user.c:
When FDLIBM_EXP is set to TRUE, a function defined s_exp() is used
instead of exp().

========================================================================
25 Mar 95

asa_user.h, asa.h:
Placed some FDLIBM_POW and FDLIBM_LOG info in more standard locations.

asa.c
Added defines FDLIBM_POW, FDLIBM_LOG, and SYSTEM_CALL to header of
asa_out.

========================================================================
24 Mar 95

NOTES, asa.c, asa_user.h, readme.ms, user.c:
When FDLIBM_POW is set to TRUE, a function defined s_pow() is used
instead of pow().
When FDLIBM_LOG is set to TRUE, a function defined s_log() is used
instead of log().

========================================================================
22 Mar 95

asa.c:
Took out extra fread and fwrite lines for User_Quench_Param_Scale,
invoked when ASA_SAVE is TRUE.

========================================================================
17 Mar 95

readme.ms:
Added 1995 ASA paper.

========================================================================
9 Mar 95

user.c:
From versions 1.5 through and possibly past 3.20, there likely was a
bug in not having memory allocated to USER_OPTIONS->Asa_Data before
memory was allocated to USER_OPTIONS.  While this occurred some time
ago, the fix should have been recorded in this file.

========================================================================
8 Mar 95

user.c:
Put in reference to Tsallis statistics for ASA_TEMPLATE used for
USER_ACCEPTANCE_TEST.

========================================================================
28 Feb 95

readme.ms, user.c:
Modified the power of the cost temperature in user_cost_schedule to
improve the accuracy of the ASA_TEMPLATE provided for ASA_SAMPLE.
Added a note to the README that the selected OPTIONS must also provide
for good convergence in the optimal region.

========================================================================
26 Feb 95

NOTES:
Included more information under Colville Examples.  Added sections on
Dynamic Hill Climbing (DHC) and Tsallis Statistics.

========================================================================
19 Feb 95

Makefile, NOTES, asa.h, readme.ms:
Changed G_F.G_P to G_FIELD.G_PRECISION for clarity.

========================================================================
18 Feb 95

Makefile, asa.c, asa.h, readme.ms:
The field width and precision of doubles is specified in asa as
G_F.G_P, e.g., as %gG_F.G_P or %g-G_F.G_P.  These two Printing
DEFINE_OPTIONS are available to change the default of 12.7.

asa.c, asa.h, readme.ms:
Added new *exit_code IMMEDIATE_EXIT to take effect when the new Program
Options OPTIONS->Immediate_Exit is set to TRUE.

NOTES:
Clarified some results obtained on the Shubert problem.

========================================================================
17 Feb 95

NOTES:
Added some statement about nature of adaptive interaction sometimes
required between the user and the system.  Added statement about
trade-off between using DEFINE_OPTIONS and Program Options to turn on
some Program Options.

readme.ms, test_asa, test_usr:
TIME_CALC has been left to its default of FALSE.

asa.c, readme.ms:
On exiting asa(), N_Accepted and N_Generated contain the values
obtained at the best value of the cost function.

========================================================================
16 Feb 95

readme.ms:
Corrected typos in discussion on SELF_OPTIMIZE so that
RECUR_OPTIONS_FILE and RECUR_OPTIONS_FILE_DATA are properly
referenced.

Makefile:
Removed redundant DEFINE_OPTIONS from examples.

asa.c, asa_user.h, readme.ms:
Added N_Generated to the OPTIONS.  N_Accepted and N_Generated are now
always active to help monitor the fit.

========================================================================
12 Feb 95

NOTES:
Added section Use of COST_FILE on Shubert Problem which was used on a
comparison of SA and taboo search.

========================================================================
11 Feb 95

NOTES, asa.c, asa_opt, asa_user.h, readme.ms, user.c:
Expanded Testing_Frequency_Modulus to Acceptance_Frequency_Modulus and
Generated_Frequency_Modulus to independently decide when to enter
testing section in the main annealing loop in asa().

========================================================================
11 Feb 95

readme.ms:
Added directions to change name of cost_function in user.h as well as
in user.c if this is desired when setting COST_FILE to TRUE.

========================================================================
10 Feb 95

readme.ms:
Explained that the Maximum_Cost_Repeat test, invoked when the the cost
function repeats itself within limits set by Cost_Precision before
quitting, is performed only when Acceptance_Frequency_Modulus is
invoked, in order to help prevent exiting prematurely in a local
minimum.

========================================================================
9 Feb 95

readme.ms:
Corrected typos referring to OPTIONS_FILE and OPTIONS_FILE_DATA under
discussion of COST_FILE.

========================================================================
8 Feb 95

asa.c, asa_user.c, readme.ms, user.c:
Added COST_FILE to permit using a separate file to define the cost
function.

========================================================================
8 Feb 95

CHANGES, readme.ms:
Added CONTENTS and section headers to facilitate using this file.

LICENSE:
Changed DISCLAIMER to caps & lower case instead of all caps.

========================================================================
7 Feb 95

asa.c:
Moved calculation of curr_cost_temp in accept_new_state() out of set of
initial tests when USER_ACCEPTANCE_TEST is TRUE.

asa.c, asa_user.h, readme.ms, user.c:
Added OPTIONS->Prob_Bias when ASA_SAMPLE is TRUE to permit calculation
of sampling statistics even when USER_ACCEPTANCE_TEST is TRUE.

========================================================================
5 Feb 95

All files:
The names of all OPTIONS were changed to caps & lower case to help
distinguish them from other DEFINES.

========================================================================
1 Feb 95

LICENSE:
Changed from use of GPL COPYING license to a simpler LICENSE, based in
part on a University of California License, whose intent is to protect
the integrity of the algorithm, promote widespread usage, and require
reference to current source code.

asa.c, readme.ms, user.c:
An approach to using ASA_SAMPLE to perform integrals was added to
sample() in user.c.  The OPTIONS->Bias_Acceptance calculation in the
user module now includes the complement of the Boltzmann test if the
new state is not accepted.  Warnings were placed in readme.ms to be
sure to copy code from the asa module to the user module if
USER_ACCEPTANCE_TEST is set to TRUE when other OPTIONS like ASA_SAMPLE
also are activated.

========================================================================
27 Jan 95

user.c:
Included example of calling acceptance criteria within the cost
function when both USER_ACCEPTANCE_TEST and ASA_TEMPLATE are TRUE.

========================================================================
25 Jan 95

Makefile, NOTES, asa.c, asa.h, asa_user.c, user.c, user.h, readme.ms:
When USER_ACCEPTANCE_TEST is TRUE, some additional variables become
available to the OPTIONS and STATE structures.  When applicable, this
permits an acceptance test within the user_cost-function() as well as
in the USER_OPTIONS->user_acceptance_test(), e.g., to decide if the
acceptance test will fail based on only a partial calculation of the
cost function.

asa.c:
Corrected several calls to fread and fwrite when ASA_SAVE is TRUE.

========================================================================
18 Jan 95

Makefile:
Modified target "doc:" to keep README+ instead of README+.uu.

NOTES:
Added section explaining the use of Temperature_Ratio_Scale and
Temperature_Anneal_Scale.

asa_opt:
Put NOTE at bottom to keep all comment lines with no extra "white"
spaces.

readme.ms:
Mentioned section just above in NOTES, and added more info on searching
for locations in user.c to place cost_function().

user.c:
Print out final cost function and parameters in user_out.

========================================================================
13 Jan 95

All files:
Added DEFINE_OPTIONS OPTIONS_FILE_DATA to permit reading most
initialization data from asa_opt.  This should suffice for most
applications, just requiring insertion of the user's cost_function into
user.c.  Similarly, RECUR_OPTIONS_FILE and RECUR_OPTIONS_FILE_DATA were
added for use when SELF_OPTIMIZE is TRUE.

Added comments around MY_COST locations.

========================================================================
12 Jan 95

All files:
Updated Copyright 1995 notices.

========================================================================
10 Jan 95

readme.ms:
Added note to consider a possible use of Quenching OPTIONS when
adaptively modifying the number of active parameters in the fit.

========================================================================
30 Dec 94

readme.ms:
Corrected typos in describing use of OPTIONS->User_Cost_Temperature.

========================================================================
20 Dec 94

user.c:
Included examples of Cauchy and Gaussian distributions in
[recur]_user_generating_function().

========================================================================
19 Dec 94

asa.c, asa.h, readme.ms, user.c, user.h:
Corrected use of commented modifications to
[recur_]user_generating_function() by passing init_param_temp_v which
can change during reannealing.

asa.c, asa.h, readme.ms, user.c, user.h:
For USER_ACCEPTANCE_TEST, added more parameters to
[recur_]user_acceptance_test() on the same order as given to
[recur_]user_generating_function().

========================================================================
18 Dec 94

Makefile, NOTES, asa.c, asa.h, asa_user.h, readme.ms, user.c, user.h:
Added USER_GENERATING_FUNCTION to permit using an alternative function
to the ASA distribution for generating new states.
Changed name of COST_PARAMETER_SCALE to Cost_Parameter_Scale_Ratio.

========================================================================
17 Dec 94

Makefile, NOTES, asa.c, asa.h, asa_user.h, readme.ms, user.c, user.h:
Added USER_ACCEPTANCE_TEST to permit using an alternative function to
the Boltzmann distribution for the acceptance test.

========================================================================
16 Dec 94

Makefile, NOTES, asa.c, asa.h, asa_opt, asa_user.h, readme.ms, user.c, user.h:
Added OPTIONS->Reanneal_Parameters and OPTIONS->Reanneal_Cost to
independently control reannealing of the cost temperature and the
parameter temperatures.
Added USER_REANNEAL_PARAMETERS and USER_REANNEAL_COST to control
reannealing of temperatures with user-defined functions in user.c.
Breaking out separate algorithms for the cost temperature can be very
useful for systems where the scales of the acceptance criteria do not
simply correlate the cost temperature with the current best value of
the cost function.

========================================================================
15 Dec 94

NOTES:
Added sub-topics for searches on keywords.  Added reference to use of
parameter_minimum[] and parameter_maximum[] in the README to discussion
of Equality Constraints.

readme.ms:
Added mention of use of searches on key words in files in browser or
editor.

========================================================================
13 Dec 94

NOTES:
Expanded discussion on Equality Constraints.

========================================================================
8 Dec 94

NOTES, readme.ms:
Added some comments addressing the possible use of the Quenching
OPTIONS to slow down annealing by setting User_Quench_Param_Scale[] to
values less than 1.

========================================================================
7 Dec 94

readme.ms:
Added example of use of adaptively using parameter_lower_bound[] and
parameter_upper_bound[] to efficiently check subsets of new
cost_parameters[] in cost_function() for correlated constraints.

NOTES:
Updated some comments to reflect recent changes in the code.

========================================================================
23 Nov 94

NOTES, readme.ms:
Added information to NOTES that reflects on recurring queries in ASA
correspondence.

========================================================================
13 Nov 94

asa.c, asa_user.h, readme.ms:
Corrected several casts used when ASA_SAVE is set to TRUE.

Makefile:
Added OPTIONAL_DATA_INT.

========================================================================
12 Nov 94

asa.c, asa.h, readme.ms:
Added SYSTEM_CALL[TRUE] to permit user to avoid system call in asa.c,
to copy asa_save to asa_save.old, on machines that do not permit these
commands.

========================================================================
8 Nov 94 [modified 14 Apr 95]

Makefile, asa.c, asa_user.h:
In Makefile, set USER_INITIAL_COST_TEMP and
USER_INITIAL_PARAMETERS_TEMPS to TRUE when ASA_SAVE and ASA_TEMPLATE
are TRUE, to bypass any calculations of the user cost function and use
of the random number generator before asa_save is read in.  This also
gives the user the option of saving all shuffled random seeds in the
user module.

asa.c:
When ASA_SAVE is TRUE, all OPTIONS are saved in case they have been
adaptively changed by the user.

asa.c, asa.h, asa_user.h, readme.ms, user.c, user.h:
Added the Program Option OPTIONAL_DATA_INT to save integer data if
required.

========================================================================
7 Nov 94

asa.c, asa.h, asa_user.h, readme.ms, user.c:
Added ASA_SAVE to recover runs from last best accepted state.

========================================================================
6 Nov 94

asa.c, asa.h, asa_user.h, readme.ms, user.c, user.h:
Pass the random seed, first defined in the user module, throughout the
asa() calls.

========================================================================
26 Oct 94

NOTES, readme.ms:
Added comments to direct people to NOTES for parallel code.

========================================================================
23 Oct 94

asa.c, asa.h, asa_user.h, readme.ms, user.c:
Corrected ASA_PARALLEL code by adding OPTIONS->Gener_Block.
Permit OPTIONS->Gener_Block_Max to be greater than number of
processors.

asa.c, readme.ms:
If and when OPTIONS->Gener_Mov_Avr is set to 0, then
OPTIONS->Gener_Block is not changed thereafter.

========================================================================
22 Oct 94

asa.c, asa.h, asa_user.h, readme.ms, user.c:
Introduced some hooks as a structure for a parallelized ASA.

========================================================================
20 Oct 94

user.c:
In the ASA_TEMPLATE for ASA_SAMPLE, User_Tangents is set to TRUE to
illustrate the use of this OPTIONS.

========================================================================
19 Oct 94

asa.c, asa_user.h, readme.ms, user.c:
Added OPTIONS->User_Tangents[FALSE] to permit user to calculate
tangents[] when User_Tangents is set to TRUE, instead of using the
default numerical evaluation.

asa.c:
The value of number_invalid_generated_states is now kept track of
during the calculation of derivatives.

========================================================================
13 Oct 94

asa.c, asa.h:
Created asa_print_options() to move printing of user's options to a
separate procedure, making it easier to read asa.c.

========================================================================
11 Oct 94

user.c:
Changed cast on kranf in randflt() to unsigned to permit use of
arbitrary values, e.g., that might arise from using task id's.

asa.c, asa.h:
For the sake of some efficiency, MIN_EXPONENT and MAX_EXPONENT,
arguments to the macro EXPONENT_CHECK(), were changed to static
variables.

asa.c:
A bug was corrected in one of the loops testing both
Sequential_Parameters and PARAMETER_RANGE_TOO_SMALL(), that could cause
a never-ending loop.

========================================================================
5 Oct 94

NOTES, readme.ms:
Added emphasis in OPTIONS FOR LARGE SPACES section that these
suggestions are to _speed up_ annealing/quenching, while some
suggestions in the README are to _slow down_ annealing.

========================================================================
3 Oct 94

Makefile, NOTES, readme.ms:
Used a more standard format for FLAGS, replacing CFLAGS with
CDEBUGFLAGS, CFLAGS and LDFLAGS.

========================================================================
30 Sep 94

NOTES:
Added simple routine to enable users to change random seed.

asa.c, asa.h, asa_user.h, readme.ms:
Completed ANSI prototypes for parameter calls to
*user_random_generator(...) and *user_cost_function(...), to enable
code to compile smoothly under C++.

========================================================================
30 Aug 94

readme.ms:
Added availability of code and papers via WWW
http://alumni.caltech.edu/~ingber/

========================================================================
19 Aug 94

readme.ms, user.c:
Added MY_COST guides for quick reference to insert user's own cost
function.

========================================================================
28 Jun 94

readme.ms:
Added acknowledgment of award from the Pittsburgh Supercomputing
Center through the National Science Foundation (NSF).

========================================================================
9 Jun 94

readme.ms:
Announced parallelizing ASA project.

========================================================================
6 Jun 94

user.c:
Deleted free statements for USER_OPTIONS->Cost_Schedule,
USER_OPTIONS->Reanneal_Params_Function, RECUR_USER_OPTIONS->Cost_Schedule,
RECUR_USER_OPTIONS->Reanneal_Params_Function which causes crashes on some
machines when USER_COST_SCHEDULE and USER_REANNEAL_PARAMETERS are used.

user.c:
Fixed memory leak when ASA_SAMPLE=TRUE.

========================================================================
4 Jun 94

NOTES:
Removed contributed code that had Copyright other than the GPL.

user.c:
Slowed down USER_COST_SCHEDULE in sample() when ASA_SAMPLE and
ASA_TEMPLATE are TRUE (template in Makefile) to permit better sampling
at all four local optima of the test function.

========================================================================
27 May 94

Makefile, asa.c, asa_user.h, readme.ms, user.c, user.h:
When ASA_SAMPLE is set to TRUE, data is collected by ASA during its
global optimization process to importance-sample the user's variable
Five OPTIONS become available to monitor the sampling: N_Accepted,
Bias_Acceptance, Bias_Generated, Average_Weights, and Limit_Weights.

========================================================================
4 May 94

NOTES:
Included more info on using time modules on PCs.

========================================================================
27 Apr 94

user.c:
Corrected test of argc to be argc > 1.  This caused problems on some
machines.

readme.ms:
Added information about asa_new.

========================================================================
19 Apr 94

readme.ms:
Corrected typo in defining range of RNG for acceptance criteria.

========================================================================
18 Apr 94

readme.ms:
Formatted Table of Contents to include section numbers.

========================================================================
17 Apr 94

asa.c, readme.ms, user.c:
Permit curvature calculations whenever tangents are calculated if
OPTIONS->Curvature_0 is set to -1.

========================================================================
16 Apr 94

readme.ms:
Reformatted page numbering of Table of Contents.

========================================================================
15 Apr 94

Makefile, readme.ms:
Include README+.uu instead of README+Z.uu in ASA-shar.

asa.h, asa_user.h:
Moved some TIME_CALC items from asa_user.h to asa.h.

========================================================================
13 Apr 94

user.c:
Placed comments on using 'ptr_out = stdout;' if printout is desired to
stdout instead of user_out.

========================================================================
10 Apr 94

asa.c, asa.h, readme.ms, user.h:
ASA can print to stdout if ASA_OUT or USER_OPTIONS->Asa_Out_File is set
to "STDOUT".  #include <string.h> was added to asa.h and user.h.

Makefile, asa.c, asa.h, asa_user.h, readme.ms, user.c, user.h:
Created asa_user.h to contain all common definitions and macros
previously repeated in asa.h and user.h.

asa.c, asa.h, asa_user.h, readme.ms, user.c, user.h:
The time module was redefined in the user and asa modules so that only
one copy of this code now resides in asa.c

asa.c:
At the risk of offending C purists, a goto EXIT_ASA was inserted at
several locations, eliminating over 300 lines of code, making this file
more readable (usually the rationale for _not_ using goto).

========================================================================
8 Apr 94

readme.ms:
Put in caution that passing asa.[13nl] which is the equivalent of
README[+] through man may strip out some items like \\"asa_out\\".

asa.c, asa.h, readme.ms, user.c, user.h:
Added Limit_Generated OPTION, but now permit either Limit_Acceptances
or Limit_Generated to take 0 to run without these constraints, e.g.,
which can be useful for machines that do not process large integers.

readme.ms:
Defined Table of Contents at end.

========================================================================
7 Apr 94

readme.ms:
Added an index of all headers.

========================================================================
6 Apr 94

The inclusion of user-defined functional changes in addition to ASA
parameter modifications justifies a change in the major version
number.

asa.c:
Made off-diagonal curvature calculation a bit more efficient.

NOTES, readme.ms:
Added some information on the use of USER_COST_SCHEDULE.

========================================================================
5 Apr 94

asa.c:
Curvatures are now calculated correctly at boundaries of specified
ranges.

asa.c:
Some initialization equations were copied into the main annealing loop
to permit greater adaptive use of Temperature_Ratio_Scale,
Temperature_Anneal_Scale, Cost_Parameter_Scale_Ratio, QUENCH_PARAMETERS
and QUENCH_COST OPTIONS.

readme.ms:
Added comment on using QUENCH_COST OPTION to slow down cost temperature
schedule.

asa.c, asa.h, readme.ms, user.c, user.h:
The function used for the cost_function temperature  schedule is of the
form test_temperature in asa.c.  You can define your own function of
test_temperature adaptively in user.c in Cost_Schedule() (and in
recur_Cost_Schedule() if SELF_OPTIMIZE is TRUE) by setting the
Pre-Compile DEFINE_OPTIONS USER_COST_SCHEDULE to TRUE.

========================================================================
31 Mar 94

readme.ms:
Added info on bitftp service and the current IP number of the Caltech
archive.

========================================================================
29 Mar 94

readme.ms:
README+ is only compressed and uuencoded in the ASA-shar[.Z] versions.

========================================================================
17 Mar 94

readme.ms:
Added some comments to the use of QUENCH_COST.

========================================================================
12 Mar 94

Makefile:
Added README+ to doc: compilation to give enhanced text.  This is
compressed and uuencoded to pass through shar.

========================================================================
11 Mar 94

Makefile:
Formatted README to include indents.

========================================================================
9 Mar 94

NOTES:
Added some comments to the FORTRAN section.

========================================================================
8 Mar 94

asa.c:
Added a missing *curvature_flag test to calculation of curvature[].

NOTES:
Added some instructions for calling FORTRAN cost functions from ASA.

========================================================================
4 Mar 94

readme.ms:
Added ASA.tar.Z version.

========================================================================
3 Mar 94

readme.ms:
Deleted IP number for ftp.alumni.caltech.edu as this is subject to
change.

========================================================================
17 Feb 94

asa.c, asa.h:
Reset Sequential_Parameters to its starting value on exiting asa().
This could be important when doing multiple runs.

========================================================================
16 Feb 94

user.c:
Clarified notation used in ASA test problem.

========================================================================
15 Feb 94

asa.c, asa.h, asa_opt, readme.ms, user.c, user.h:
Added adaptive Sequential_Parameters to OPTIONS.

NOTES, readme.ms, user.c:
Several small changes to reflect new ASA_LIB OPTION.

========================================================================
13 Feb 94

asa.c, asa.h, user.c, user.h:
Added Pre-Compile OPTION ASA_LIB to facilitate calls of asa() from
another program when this is set to TRUE.

user.h:
Removed extra main prototype when SELF_OPTIMIZE is TRUE and HAVE_ANSI
is FALSE.

========================================================================
9 Feb 94

NOTES, readme.ms:
Noted minor change of archive address to ftp.alumni.caltech.edu
[131.215.48.62].

========================================================================
3 Feb 94

asa.c, asa.g, user.c, user.h:
Reformatted files using GNU indent-1.9.1.

========================================================================
1 Feb 94

readme.ms:
Added directions for compiling the ASA test problem without the use of
the Makefile.

========================================================================
30 Jan 94

readme.ms:
The subdirectory TESTS has been eliminated, and replaced by the two
files test_asa and test_usr.

user.c:
I wrote the ASA test problem from scratch to closely follow its
published description.  It now runs a bit faster under gcc.

========================================================================
27 Jan 94

Makefile, asa.c, asa.h, readme.ms, user.c, user.h, TESTS/asa...:
Added Pre-Compile DEFINE_OPTIONS USER_REANNEAL_PARAMETERS.  When this is
TRUE, the user can define the reannealing function, adaptively if
required, in user.c in function user_reanneal() (and in
recur_user_reanneal() if SELF_OPTIMIZE is TRUE).

========================================================================
18 Jan 94

NOTES:
The section PAPERS USING ASA was broken out into a separate file,
asa_papers, in ftp.caltech.edu:pub/ingber.  This is to minimize
updating versions of the ASA directory due to changes in this section.

========================================================================
17 Jan 94

NOTES:
Updated locations of papers in section PAPERS USING ASA.

========================================================================
14 Jan 94

asa.c:
Deleted quench flags as they are now unnecessary.

========================================================================
13 Jan 94

asa.c, asa.h:
Fixed bug in use of OPTIONS->User_Temperature_Ratio.

readme.ms:
Corrected function parameter lists to agree with changes in user.c and
user.h.

========================================================================
12 Jan 94

user.c, user.h:
Cleaned up a few small memory leaks.  Removed several flags that could
be replaced by reference to USER_OPTIONS and RECUR_USER_OPTIONS.

========================================================================
11 Jan 94

NOTES, readme.ms:
Changed names of directories to those in newly overhauled archive.

========================================================================
10 Jan 94

NOTES:
Updated references in section PAPERS USING ASA.

========================================================================
8 Jan 94

readme.ms:
Added info that ASA.zip is now maintained in the ASA archive.

========================================================================
1 Jan 94

NOTES:
Under PAPERS USING ASA, added reference to paper by Tang, Tracy,
Boozer, deBrauw, and Brown.

========================================================================
13 Dec 93

user.c:
Corrected dimension of asa_file[].

========================================================================
26 Nov 93

ASA version 2.1:
Experimentation with SELF_OPTIMIZE, Quenching and ASA_TEMPLATEs has
progressed to a stage warranting a change in the major version number.

NOTES:
Added ASA-related papers available in the Caltech archive.

========================================================================
22 Nov 93

asa.c, user.c:
Clarified use of OPTIONAL_DATA in ASA_TEMPLATE when used with
SELF_OPTIMIZE.

readme.ms:
Added outline of use of each ASA_TEMPLATE.

Makefile:
Added comments on the use of the provided sets of DEFINE_OPTIONS.

========================================================================
17 Nov 93

user.c:
Cleaned up USER_ASA_OUT ASA_TEMPLATE string calls to work under Sun acc
without errors and under gcc without warnings.

========================================================================
16 Nov 93

NOTES:
Updated references to papers.

CHANGES:
Updated references.

========================================================================
15 Nov 93

asa.c, user.c:
More fixes to handle memory leaks.

========================================================================
14 Nov 93

asa.c, user.c:
Added free() calls to get rid of pesky memory leaks which arose under
SELF_OPTIMIZE.

Makefile:
Corrected DEFINE_OPTIONS to properly use USER_ASA_OUT and ASA_TEMPLATE
for multiple calls to asa.

========================================================================
12 Nov 93

asa.c:
Added modification to keep parameters within bounds when calculating
*tangents in cost_derivatives().

========================================================================
6 Nov 93

Makefile, readme.ms:
Changed packaged code to be in both ASA-shar.Z and ASA.tar.gz formats.

asa.c:
Added tests for integer parameters in generate_new_state(), in case
some system rounds differently.

========================================================================
4 Nov 93

Makefile, asa.c, asa.h, readme.ms, user.c, user.h, TESTS/asa...:
Added TIME_STD Pre-Compile Option to use Unix-standard macros for time
routines, as required by some systems, e.g., hpux.

========================================================================
3 Nov 93

NOTES:
Included papers by wu@mcrcim.mcgill.edu and gblais@mcrcim.mcgill.edu
under PAPERS USING ASA.

========================================================================
23 Oct 93

asa.c:
INT_ALLOC and INT_LONG defines had to be corrected around a few
fprintf statements.

readme.ms, TESTS:
On the Sun, gcc-2.5.0 update runs were performed.  Since the change in
definitions of MIN_DOUBLE and MAX_DOUBLE, setting SMALL_FLOAT=E-12 does
not agree with SMALL_FLOAT=E-18 and SMALL_FLOAT=E-20 (the latter two
agree), unless MIN_DOUBLE=E-18 also is set.

========================================================================
15 Oct 93

asa.c:
Added print statements for some additional OPTIONS.

readme.ms:
Due to the increased volume of interaction, I had to insert statements
that I cannot assume the task of mailing out hardcopies of code or
papers, and that my time assisting people with their queries on my
codes and papers must be limited to electronic mail correspondence.

========================================================================
14 Oct 93

Makefile, asa.c, asa.h, readme.ms, user.c, user.h:
Added ASA_TEST[FALSE] to be set to TRUE to use ASA test problem.  This
permits users to add their own problem without having to overwrite the
ASA test example.

Added ASA_TEMPLATE[FALSE] wrappers around tests associated with several
OPTIONS.  This permits use of these OPTIONS without having to delete
these extra tests.

========================================================================
18 Sep 93

user.c:
Added reference for RNG used in the user module.

========================================================================
24 Sep 93

NOTES:
Added reference to Wall Street Journal article mentioning ASA.

========================================================================
13 Sep 93

NOTES, TESTS/HP_gcc:
Added update on modifications available for HP machines.  Added HP_gcc
file in TESTS.

TESTS/SHRT2LNG:
Apparently this file was blanked out the past few versions, and has now
been restored.

========================================================================
2 Sep 93

NOTES:
Placed ftp locations in PAPERS USING ASA.

========================================================================
31 Aug 93

NOTES:
Added info on setting INT_ALLOC and INT_LONG to TRUE on a PC using MS
Quick C.

========================================================================
27 Aug 93

NOTES:
Added info on setting IO_PROTOTYPES to FALSE on a PC using Turbo C++.

========================================================================
18 Aug 93

NOTES, asa.c, asa.h, user.c, user.h:
Some minor changes to accommodate Turbo C.

========================================================================
16 Aug 93

readme.ms:
Used the standard /usr/ucb/fmt to format all paragraphs.

========================================================================
24 Jul 93

Minor editing corrections.

========================================================================
10 Jul 93

readme.ms:
Added more detail on sources of documentation and how to use a copy
of the README file as an asa manpage.

========================================================================
5 Jul 93

Makefile, asa.c, asa.h, TESTS/asa...:
Added ASA_PRINT_MORE Printing Option.

========================================================================
29 Jun 93

asa.c, asa.h, user.c, user.h:
Moved prototypes for getrusage() from .c to .h files, together with
other prototypes.

user.c:
Found a Bus error during run for some versions of gcc (2.2.2 on a
sparc/4.1.3) when using `#define ARRAY_LIMIT *parameter_dimension'
when 'if __GNUC__' is TRUE, so this was set to `#define ARRAY_LIMIT
*parameter_dimension 4'.

Makefile, asa.h, user.h, readme.ms, TESTS/*_*:
Set default of TIME_CALC to FALSE since it gives trouble on many
machines.

NOTES:
Added contributed code to permit time routines to work on HPs.

========================================================================
16 Jun 93

Makefile, asa.h, readme.ms, TESTS/asa...:
Changed definition of MIN_DOUBLE to smallest positive double.

========================================================================
12 Jun 93

NOTES:
Added short note on how to adapt user module to permit ASA to be
called from another code.

========================================================================
10 Jun 93

CHANGES:
Moved list of dates of modifications to bottom of file.  Included
dates of original RATFOR/FORTRAN code from 1987 and original C code
from 1991.

========================================================================
9 Jun 93

readme.ms:
Moved description of FUNCTION_REANNEAL_PARAMS to Pre-Compile section.
Elaborated on proper use of Pre-Compile Options.

========================================================================
8 Jun 93

Makefile, asa.c, asa.h, asa_opt, readme.ms, user.c, user.h, TESTS/...:
Changed name of MAX_FLOAT to MAX_DOUBLE.  Changed name of MIN_FLOAT
to MIN_DOUBLE.  Added EPS_DOUBLE to default to SMALL_FLOAT.  This is
considered a precursor to getting better contributions to defining
these values at a later date.  Made default of Cost_Precision to
1.0E-18, independent of these other values.  TESTS are not effected.

========================================================================
6 Jun 93

user.c:
Shortened the names of some variable asa_out* files to not exceed
8 characters.

asa.c, asa.h, readme.ms:
Added FUNCTION_REANNEAL_PARAMS in asa.h to give users more control over the
function determining reannealing.

========================================================================
5 Jun 93

Makefile, asa.c, readme.ms, TESTS/asa...:
Use SMALL_FLOAT for NO_PARAM_TEMP_TEST and NO_COST_TEMP_TEST (new names
for NO_P_TEMP_TEST and NO_C_TEMP_TEST) if they are TRUE.  Sharpened
tests of temperatures for NO_PARAM_TEMP_TEST and NO_COST_TEMP_TEST
set to FALSE.  Now all test cases agree in intermediate values.
TESTS/SUN_E-12 was deleted.

========================================================================
4 Jun 93

asa.c, asa.h, readme.ms, TESTS/asa...:
Added NO_P_TEMP_TEST and NO_C_TEMP_TEST Pre-Compile options for
testing purposes.

========================================================================
2 Jun 93

asa.c:
Fixed bug in reanneal() by placing some fabs() for some arguments
of pow().

Fixed bug in fclose() by placing statement at end of asa_exit().
This affected calculations with SELF_OPTIMIZE= TRUE.

user.c:
Edited SELF_OPTIMIZE=TRUE and USER_ASA_OUT=TRUE sections.

========================================================================
31 May 93

asa.c:
Adjusted initialization of *number_acceptances_saved = 0.

TESTS/:
All tests were updated.

user.c:
Added USER_ASA_OUT to SELF_OPTIMIZE=TRUE portion, and cleaned up
USER_ASA_OUT calls in SELF_OPTIMIZE=FALSE portions.

========================================================================
25 May 93

NOTES:
Added CONTENTS with SECTION_NAMES to search on topics.

========================================================================
29 May 93

Makefile, asa.c, asa.h, readme.ms, user.c, user.h, TESTS/asa...:
Added Pre-Compile Option USER_ASA_OUT to work with Program Option
*Asa_Out_File, to permit dynamic naming of asa() output files from
the user module.

========================================================================
24 May 93

NOTES, readme.ms:
Reorganized some references, and started list of ASA (p)reprints at
the bottom of this file, instead of increasing length of readme.ms.

asa.c:
Minor cleaning up of some statements, taking out extra parentheses.

========================================================================
22 May 93

longname.h:
Removed and made obsolete by changes in a few parameter names in the
asa module.

asa.c, asa.h, readme.ms, user.c, user.h, TESTS/asa...:
Changed all (*[a-zA-Z_]). constructs to [a-zA-Z_]-> to improve
readability.  The original form was to minimize notation for many
users, but the use of many *OPTIONS calls made this change more
reasonable.

========================================================================
17 May 93

asa.c:
Corrected typo bugs in reanneal() introduced when inserted
OPTIONS->User_Quench_Param_Scale[] factors.

========================================================================
16 May 93

asa.c, asa.h, asa_opt, readme.ms, user.c, user.h, TESTS/asa...:
Introduced two QUENCH_PARAMETERS and QUENCH_COST, to permit some
"quenching" especially in very large parameter spaces.

========================================================================
15 May 93

asa.h, user.c, user.h:
Added a __GNUC__ define.  This is useful to set ARRAY_LIMIT to
*parameter_dimension in user.c when using gcc.

asa.c, asa.h:
Removed some superfluous parameters from parameter lists.

========================================================================
15 May 93

asa.c:
Enforced fflush() for updated new best states for printout for large
parameter spaces.

readme:
ASA now can be obtained from ftp.caltech.edu where it can be maintained
in a timely manner.

========================================================================
14 May 93

asa.c:
Reorganized use of ASA_PRINT_INTERMED to be more useful for large
dimensions.

readme:
Added some comments to Program Options for large dimensions.

========================================================================
13 May 93

readme:
Updated instructions for retrieval of files.  The previous instructions
were too terse for some users.

========================================================================
11 May 93

asa.c, asa.h:
Deleted unused references to ASA_OPTIONS and ADAPTIVE define.

readme.ms:
Edited in several places and updated section on availability.

========================================================================
9 May 93

Makefile, asa.c, asa.h, readme.ms, user.c, user.h:
Added *Asa_Data to *OPTIONS when the Pre-Compile option OPTIONAL_DATA
is set to TRUE.  This permits additional information to be returned
to the user module from the asa module.  An example of usage is given
for the test problem when SELF_OPTIMIZE is TRUE.

========================================================================
8 May 93

Makefile, asa.h, readme.ms:
ASA_PRINT_INTERMED[=TRUE] is added as a Pre-Compile option.  This is
useful for large parameter spaces as well as when SELF_OPTIMIZE is
set to TRUE.

user.c:
The test problem is modified to set the dimension and indexing of
all arrays to correspond to *parameter_dimension.  This is useful to
easily change the test problem, e.g., to test large parameter spaces.

user.c:
Added some output at the end of a run when SELF_OPTIMIZE is TRUE,
in case ASA_PRINT is FALSE.

asa.c:
Closed off several fclose() statements used when SELF_OPTIMIZE is TRUE,
but ASA_PRINT is FALSE

========================================================================
7 May 93

asa.c:
Corrected allocation of memory to temperature_scale_parameters when
RATIO_TEMPERATURE_SCALES is set to TRUE.

========================================================================
5 May 93

readme.ms:
Latest updates of code and papers may be retrieved via anonymous ftp
from ftp.caltech.edu in the pub/ingber directory.

========================================================================
27 Apr 93

Makefile, asa.c, asa.h, readme.ms, user.h:
The cast on *number_parameters is set by ALLOC_INT which defaults to
the cast of LONG_INT.  On some machines, ALLOC_INT might have to be
set to TRUE to set this cast to int if there is a strict requirement
to use an unsigned int for calloc.

========================================================================
5 Apr 93

vfsr.c:
Removed old code that was inadvertently left in, with an fclose()
call for NORMAL exit.  This prevented printing to the same file when
requesting multiple calls to vfsr() from the user module.  Conditionals
were added to have printout distinguish between multiple calls and
recursive calls.  Thanks to Graham Campbell <campbell@ams.sunysb.edu>
for finding this bug.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
NOTES:
Thanks to Eric Grosse <ehg@research.att.com> for suggesting that we can
trim down the size of the code by editing the NOTES to keep it current.

========================================================================
2 Apr 93

NOTES, readme.ms:
Added some code for precise exiting of vfsr on demand, contributed
by Walter Roberson <roberson@hamer.ibd.nrc.ca>.

========================================================================
29 Mar 93

NOTES:
Mentioned apparent need to link with -ldl on some HP's.  The problem
was solved by Walter Roberson <roberson@hamer.ibd.nrc.ca>.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
readme.ms, user.c, user.h, vfsr.c, vfsr.h, vfsr_opt:
Extensive reordering was performed on all function calls to have them
appear more logically grouped.

========================================================================
27 Mar 93

readme.ms:
Mentioned FTPmail as alternative source for getting files if Netlib
or Statlib cannot be accessed.

Formatted README for pagination to facilitate printing on an ascii
printer.

========================================================================
24 Mar 93

Makefile, user.c, user.h, vfsr.c, vfsr.h:
Added template to illustrate how to use vfsr to self-optimize its
Program Options using SELF_OPTIMIZE=TRUE.

========================================================================
22 Mar 93

Makefile, readme.ms user.c, user.h, vfsr.c, vfsr.h, vfsr_opt, TESTS/...:
Rewrote code to pass only local pointer-parameters to and within the
vfsr module.  This is required if anyone wishes to write a user module
to use vfsr recursively, e.g., for self-optimization.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
user.c, vfsr.c:
Removed unnecessary headers for each routine.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Makefile, user.c, user.h, vfsr.c, vfsr.h, vfsr_opt:
Removed ADAPTIVE_OPTIONS, as now Program Options are either defined
in user.c or read in from vfsr_opt using OPTIONS_FILE=TRUE.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
NOTES:
Placed code contributed by Barak Cohen <bardak@ccsg.tau.ac.il> which
can be used on PCs to replace our timing modules.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
vfsr.c:
It was pointed out by Bill Wong <bgwong@holonet.net> that some
machines can have problems assigning a double too large for long int.
We have taken his advice and used temp_dbl in reanneal() to avoid
these problems.

========================================================================
17 Mar 93

NOTES:
Entered "disclaimer" about VFSR being ready as is for recursive use.
On our TODO list is a rewrite dispensing with global parameters.

========================================================================

16 Mar 93

vfsr.c:
The cast on index_cost_repeat was corrected to int.  Thanks to Bill
Wong <bgwong@holonet.net> for finding this error.

vfsr.c:
index_cost_repeat should be reset to 0 whenever a new best state
is found.  Thanks to Walter Roberson <roberson@hamer.ibd.nrc.ca>
for finding this bug.

========================================================================
15 Mar 93
user.h, vfsr.h, vfsr.c:
The cast on MAXIMUM_REANNEAL_INDEX was changed to LONG_INT, as
was originally intended.  Without this change, the default value
of 50000 causes VFSR to fail on some PC's.  Thanks to Barak Cohen
<bardak@ccsg.tau.ac.il> for bringing this problem to our attention.

========================================================================
7 Mar 93

readme.ms:
To avoid confusion between the GNU Public License (GPL) in our COPYING
file and the popular imprecise term "public domain," a modified
statement now is included:
   Please read the copy of this license contained in this directory.
   Our intent is to make this code publicly available to the widest
   audience while maintaining the integrity of the basic algorithm.

========================================================================
28 Feb 93

readme.ms:
Included a brief description of the VFSR algorithm.

========================================================================
26 Feb 93

Makefile, readme.ms:
Inserted a brief discussion on the algebra behind the Program Options
used for annealing.  Equations are set in README.ps.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
TESTS/v..., readme.ms, user.h, user.c, vfsr.c, vfsr.h:
Individual scales for reannealing can be set by the user by setting
both Pre-Compile Options ADAPTIVE_OPTIONS and RATIO_TEMPERATURE_SCALES
to TRUE, and initializing (*USER_OPTIONS).user_temperature_ratio[]
in the user module.

The same approach is now taken to set initial parameter
or cost temperatures, i.e., by initializing the
(*USER_OPTIONS).user_parameter_temperature array or
(*USER_OPTIONS).user_cost_temperature in the user module.
This replaces the kludge of using the previous "hooks."

========================================================================
25 Feb 93

readme.ms:
All descriptions of the DEFINE_OPTIONS in the Makefile are now repeated
in the README[.ps] documentation.  Several people stated they were
initially confused by not seeing any description of these options in
the primary documentation.

========================================================================
24 Feb 93

NOTES:
Added some email correspondence which outlines how vfsr could be used
recursively to optimize its Program Options in a given system, or to
optimize other optimizers.

========================================================================
23 Feb 93

readme.ms:
Added stress that the Makefile contains a short description of the
DEFINE_OPTIONS, and that it should be considered an extension of the
README and README.ps files.  The three methods of passing the Program
Options were broken up into separate sections to stress this feature.

========================================================================
17 Feb 93

readme.ps:
Cleaned up some problems in formating under refer and grefer.
Thanks to Yuan Liu <liu@cs.umd.edu> and James Clark <jjc@ai.mit.edu>
for their help.

========================================================================
16 Feb 93

readme.ps, user.h, vfsr.h:
Added REAL_NO_REANNEAL (-2) and INTEGER_NO_REANNEAL (2) choices to
parameter_type[] to make choices for this parameter more explicit
and user-friendly.  The cast on parameter_type was set back to int.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Makefile, TESTS/v..., readme.ms, user.h, user.c, vfsr.h, vfsr.c:
Increments used in numerical derivatives of individual parameters
can now be set adaptively.  If both Pre-Compile ADAPTIVE_OPTIONS
and DELTA_PARAMETERS are TRUE, then a pointer delta_parameter in the
OPTIONS structure passes these values, overriding the value of DELTA_X.

This leaves parameter_type with 4 alternatives: REAL_TYPE (< 0, but
for compatability 0 still works), INTEGER_TYPE (> 0), REAL_NO_REANNEAL
(-2), and INTEGER_NO_REANNEAL (2).

========================================================================
14 Feb 93

readme.ms:
In the Makefile section, more explicit information was inserted on
the three alternative methods of passing the Program Options.

========================================================================
13 Feb 93

TESTS/v..., readme.ms, user.h, user.c, vfsr.c, vfsr.h:
Added flexibility to parameter_type[].  Most users need only
be concerned that real-valued parameters must be designated by
negative integers and integer-valued parameters must be designated
by positive integers.

Some users may find it useful to include additional information.  If
the absolute value of the parameter_type[] is +-2, +-4, +-6, +-8, then
no derivatives are calculated for this parameter, effectively excluding
it from being reannealed or having its curvature[] calculated.  (This
only effects integer-valued parameters if INCLUDE_INTEGER_PARAMETERS is
set to TRUE.)  If the absolute value is greater than 9, that value is
used to multiply DELTA_X for that variable; therefore, we have set the
cast on *parameter_type to be LONG_INT.  This flexibility can be used
to exclude discontinuous functions from derivative operations, to have
DELTA_X for integer-valued functions be integral, etc.  Odd numbers +-5
and +-7, are reserved for specific user-defined options, as are even
numbers +-6 and +-8 that require bypassing derivative calculations.
(We will keep the other numbers for future VFSR enhancements.)

The utility of having some user-defined flexibility was highlighted
by some correspondence with Bob Goldstein <u09872@uicvm.uic.edu>
and Brooke Paul Anderson <brooke@cco.caltech.edu>.

vfsr.c:
Corrected calculation of diagonal curvatures.

========================================================================
12 Feb 93

readme.ms:
Inserted comment that Makefile is a convenience, not a necessity,
to use VFSR, and that care should be taken to pass the correct
DEFINE_OPTIONS when compiling the files.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
NOTES:
An example of some parameter tuning on a specific problem.

========================================================================
6 Feb 93

vfsr_opt:
Changed name of options_file to vfsr_opt for easier identification
in users' libraries and to truncate this filename to 8 characters.

Other filenames shortened to 8 characters were SHORT2LONG -> SHRT2LNG,
CONVEX_cc -> CONVX_cc, COPYING-LIB -> COPYING.

========================================================================
5 Feb 93

Makefile, options_file, user.c, vfsr.h:
Changed default MAXIMUM_REANNEAL_INDEX=50000 from 100000000 to avoid
problems on machines that cannot handle long int.  Results are not
changed in TESTS.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Makefile, readme.ms, user.[ch], vfsr.[ch], TESTS:
Added CURVATURE_0=FALSE to DEFINE_OPTIONS.  When CURVATURE_0=TRUE,
then only a one-dimensional array, curvature[0], need be passed to
the vfsr module.  This can help when dealing with very large parameter
spaces where the curvature calculations are not required.  curvature[0]
is still maintained a hook for USER_INITIAL_COST_TEMP=TRUE in any case.

The general problem was emphasized by Bob Goldstein
<u09872@uicvm.uic.edu>.

========================================================================
3 Feb 93

Makefile, vfsr.h, user.c:
Set default of TEMPERATURE_ANNEAL_SCALE=1000.0, freeing it from the
previous default of TEMPERATURE_ANNEAL_SCALE=LIMIT_ACCEPTANCES/10.0.

NOTES:
Comments on setting some VFSR options in case premature convergence
is suspected.  Thanks to Wu Kenong <wu@mcrcim.mcgill.edu> for checking
over some of the details.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Makefile, options_file, user.c, user.h:
Added options_file and OPTIONS_FILE=FALSE.  If both
ADAPTIVE_OPTIONS=TRUE and OPTIONS_FILE=TRUE, then the Program Options
are read in from options_file.  This permits more efficient testing
of various Program Options.

This feature was in the original VFSR code, and was added here at
the suggestion of Davyd Norris <daffy@physics.monash.edu.au>.

========================================================================
31 Jan 93

NOTES:
Comments on how to effect an early exit using ADAPTIVE_OPTIONS=TRUE.

========================================================================
27 Jan 93

The issue of balancing user-friendly code versus flexibility for
different machines was re-visited at the suggestion of Davyd Norris
<daffy@physics.monash.edu.au>.

We have gone back to using SMALL_FLOAT as a measure of "smallness"
to avoid several underflow and overflow problems.  This is a general
measure of precision to be expected in log and divide operations in
vfsr.c, and is _not_ equivalent to defining the number of significant
figures of precision.  We expect experts who require this detail
to be able to use the flexibility of the present code to tune it to
their own requirements.

We have retained MAX_FLOAT and MIN_FLOAT for use in EXPONENT_CHECK, but
have made these definitions correspond to typical machine definitions.
We have defined the defaults as MIN_FLOAT=-1.0/SMALL_FLOAT and
MAX_FLOAT=1.0/SMALL_FLOAT.  Variables max_exponent and min_exponent
are now calculated once in vfsr.c, speeding up calculations.

========================================================================
26 Jan 93

vfsr.c:
Corrected rounding algorithm for integers in generate_new_state().
Thanks to Wu Kenong <wu@mcrcim.mcgill.edu> for pointing out this bug.

========================================================================
25 Jan 93

readme.ms, user.c, user.h, vfsr.c, vfsr.h:
*OPTIONS is an optional parameter that can be passed if
ADAPTIVE_OPTIONS=TRUE in the Makefile.  When ADAPTIVE_OPTIONS=FALSE
(the default), all changes in default Program Options DEFINE_OPTIONS
are defined in the Makefile.  (Compiler Options and Printing Options
always are to be set in the Makefile.)  When ADAPTIVE_OPTIONS=TRUE,
all Program Options are defined in the structure OPTIONS, permitting
adaptive changes during repeated searches, or at different recursive
levels of VFSR optimization.  As illustrated in the user module,
if ADAPTIVE_OPTIONS=FALSE, only the typedef int for DEFINES must be
specified to use this format.

This additional flexibility was possessed by the VFSR code before
its public release, and has been useful in some systems requiring
recursive calls to vfsr().

========================================================================
24 Jan 93

TESTS/..., vfsr.c:
Changed format for printing out doubles from 10.5 to 12.7.

NOTES:
Placed some comments on use of DEFINE_OPTIONS for recursive nesting
of VFSR calls.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Makefile, readme.ms, vfsr.c, vfsr.h:
Added additional exit criteria, TOO_MANY_INVALID_STATES, based on
new DEFINE_OPTION, LIMIT_INVALID_GENERATED_STATES (default 1000).

========================================================================
22 Jan 93

NOTES:
Added some comments about using VFSR on systems with constraints and
fine-tuning the DEFINE_OPTIONS.

========================================================================
21 Jan 93

CHANGES, Makefile, readme.ms, vfsr.c, vfsr.h:
Added USER_INITIAL_PARAMETERS_TEMPS=FALSE and to Makefile to permit
user to input initial individual parameter temperatures into *tangents
array.

Added USER_INITIAL_COST_TEMP=FALSE to Makefile to permit user to
input initial cost temperature into curvature[0].

These additional features, discussed in the original VFSR paper and
implemented in the original code, were put back in as suggested by
correspondence with Zbigniew Michalewicz <zbyszek@mosaic.uncc.edu>
and Wu Kenong <wu@mcrcim.mcgill.edu>.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
TEST..., vfsr.c:
Added new DEFINE_OPTIONS to list to be printed out in vfsr_out.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
vfsr.c, vfsr.h:
Added separate time routines for independent tracking of vfsr
calculations.

========================================================================
15 Jan 93

vfsr.c:
Put in specific test to skip reannealing for integer parameters if
the default INCLUDE_INTEGER_PARAMETERS=FALSE.  Previously, it had to
be assumed that tangents[] would be 0 for these cases.

========================================================================
14 Jan 93

Makefile, NOTES, vfsr.c:
SMALL_FLOAT was added to the denominator of the calculation of
delta_cost, to properly handle cases of small current_cost_temperature.

TESTS/..., readme.ms:
This changes the intermediate calculations, causing longer runs after
the best minimum is found, in the test cases for SMALL_FLOAT=E-18/E-20,
but does not affect the final answers or the values of the generating
and acceptance points at the global minimum.  However, now the test
problems do not crash on the Convex for SMALL_FLOAT=E-18, but still do
crash for SMALL_FLOAT=E-20 due to a "Floating exception."

Makefile, user.h, vfsr.h, vfsr.c:
Hooks were placed in user.h and vfsr.h to set machine-dependent
SMALL_FLOAT to MACHEPS, MIN_FLOAT to MIN_REAL, and MAX_FLOAT to
MAX_REAL.  Corresponding DEFINE_OPTIONS were added to Makefile.
To maintain user-friendly and portable code across platforms, we
have set the defaults in terms of SMALL_FLOAT; this agrees with our
previous test results.

Makefile, vfsr.h, vfsr.c:
A DEFINE_OPTIONS was added because some machines, e.g., PC's,  may
choke on `long int' as used in vfsr.c to handle some large dimensions.
Setting INT_LONG=FALSE will use only `int'.

NOTES:
A entry was placed in NOTES explaining the preference for setting all
options in the Makefile, rather than introducing a new initialization
file.

Thanks to Davyd Norris <daffy@physics.monash.edu.au> for finding
this bug, running many test cases on various machines, and causing
us to reevaluate the above issues.

========================================================================
13 Jan 93

user.c, user.h, vfsr.c, vfsr.h:
As previously mentioned in vfsr.h, the original VFSR code passed the
parameter bounds in the cost function, permitting additional adaptive
changes in the search by virtue of decisions made in this calculation.
E.g., setting a lower bound equal to the upper bound of a parameter
has the effect of taking it out of consideration of the search.
This feature has been put back into the code, at the modest expense
of now requiring parameter bounds to be passed by the cost function.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
user.c:
Switched order of "if" tests for PRINT_FREQUENCY to avoid division
by zero.

Thanks to Wu Kenong <wu@mcrcim.mcgill.edu> for pointing out this bug.

========================================================================

12 Jan 93

Makefile, user.c, user.h:
A TIME_CALC=TRUE option was added to DEFINE_OPTIONS.  Several
people were having compilation problems on Mac's and PC's because
of differences in locations of and macro definitions in the time
include files.  Since the relevant code is in the user module, and
not in the vfsr module of our primary concern, we feel the best fix
is just to include this option, where TIME_CALC=FALSE will simply
ignore all this code.

Thanks to Lee Hon Man <89299465@CPHKVX.CPHK.HK> for stressing these
problems in the user module.

========================================================================
20 Dec 92

Makefile, user.c, vfsr.c, vfsr.h:
Changes were made in casts to make the code more portable to 16-bit
machines and to machines that might hold only to the strict ANSI
standards, by changing int -> long int for those variables that might
get large.

Thanks to Davyd Norris <daffy@physics.monash.edu.au> for bringing
this necessity to our attention.  Davyd has pointed out that compiler
"warnings" still are issued, e.g., truncation of some integers on PC's,
but we feel that we only can spend time addressing actual "errors"
in the vfsr module that will actually impair implementation of the
VFSR algorithm.

========================================================================
19 Dec 92

NOTES:
Added some email correspondence from Cygnus, who give support to GNU
products, clarifying some issues in the COPYING-LIB license.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

NOTES:
Added some comments on VFSR use in the presence of complex constraints.

========================================================================
18 Dec 92

NOTES, CHANGES:
Corrected confusing typo that misidentified [m sub i] and [n sub i]
in published papers with their correct implementation in vfsr.c:
TEMPERATURE_ANNEAL_SCALE [n sub i]
TEMPERATURE_RATIO_SCALE  [m sub i]
Some examples calculating these quantities were placed in NOTES.

Thanks to Wu Kenong <wu@mcrcim.mcgill.edu> for pointing out this bug.

========================================================================
17 Dec 92

readme.ms
Inserted  statement:
Since VFSR has not been applied extensively to many systems, it is
certain that there is much research to be done on determining optimal
or even reasonable VFSR parameters, e.g., the set of DEFINE_OPTIONS,
for different classes of systems, especially in higher dimensional
spaces of user parameters.  A major purpose of placing this code in
the public domain is to motivate more of this research, and thus make
the code more useful to a wider audience.

========================================================================
16 Dec 92

VFSR.DIR, Makefile, longname.h, readme.ms:
To accommodate some PC/DOS systems, some changes in name were made.
Since many such systems do not distinguish case, there is a problem
using `sh vfsr' to get the VFSR directory.  Therefore, the name of
the VFSR directory has been changed to VFSR.DIR.

TESTS, Makefile:
The names of files on DOS systems cannot exceed 8 characters plus
3 as a suffix.  The names of the files in TESTS were shortened even
more than previously to permit their unique extraction under `sh vfsr'.

========================================================================
13 Dec 92

Makefile:
On some Dec and Convex machines `make' gets confused by backslashes
("\") at the end of commented lines ("#").  These were taken out of all
commented option lines.

========================================================================
12 Dec 92

NOTES:
Took out names and email addresses of correspondents, as they contact
us without knowing that we might include their comments in this file.

========================================================================
10 Dec 92

readme.ms:
Took %N(S) issue number entries out of file, since references
as formatted here make unclear the distinction between %N and %V
(volume) entries using grefer defaults.  Otherwise, a separate macro
file would have to be included, standard with refer or grefer usage.
This macro file typically would have some control characters, e.g, ^G,
and this could cause problems for some people accessing vfsr via email.

========================================================================
9 Dec 92

vfsr.c:
In the routine cost_derivatives(), there are three places where a
division by a parameter can cause problems when it has value zero
within machine precision.  This did not affect the particular test
problem.  A value of SMALL_FLOAT has been added to those denominators
to prevent any future problems.

Thanks to Leslie Picardo <picardo@alpha.ces.cwru.edu> for finding
this bug.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
readme.ms:
As suggested in the GNU Library General Public License in the
COPYING-LIB file, postal addresses for both authors were inserted.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
NOTES:
Added some correspondence relating to setting parameters for high
dimensions.

========================================================================
8 Dec 92

CHANGES, user.c, vfsr.c
Set up headers to automate updating Modification History whenever a
new version is created.

========================================================================
7 Dec 92

vfsr now is in STATLIB as well as NETLIB, permitting interactive or
email retrieval.

========================================================================
6 Dec 92

all files:
Set up a patch macro for all revisions past v6.25.  Changed format of
this file to use "=" and "+" as separators of changes not to conflict
with diff separators.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
readme.ms, vfsr.c:
The RCS Id string containing version number, and values of all
DEFINE_OPTIONS in the Makefile are now printed out in VFSR_OUT (when
VFSR_PRINT is at its default of TRUE).

vfsr.h, vfsr.c:
The exit code is now passed to vfsr_exit to be printed at the bottom
of VFSR_OUT together with the other summary information.

These changes will help decifer bug reports.

========================================================================
5 Dec 92

vfsr.c:
The present code gives incorrect annealing for negative cost functions.
During the rewrite, an "fabs" was dropped that had insured that the
initial cost temperature would always be positive.  (For example,
during reannealing, at a few places the absolute value of the cost
is taken when used to examine the temperature.)  This bug incorrectly
reverses the acceptance criteria.  The solution is to change:
202c202
<       sampled_cost_sum += current_generated_state.cost;
---
>       sampled_cost_sum += fabs(current_generated_state.cost);

Thanks to Cullen Schaffer <schaffer@marna.hunter.cuny.edu> for finding
this bug.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Makefile, vfsr.c, vfsr.h:
Added ACTIVATE_REANNEAL (default TRUE) to permit overriding
reannealing.  This is a simple addition in one place:

#if ACTIVATE_REANNEAL           /* set to FALSE to skip reannealing */
            /* calculate tangents, not curvatures, to reanneal */
            curvature_flag = FALSE;
            cost_derivatives(user_cost_function);
            reanneal();
#endif

========================================================================
3 Dec 92

Makefile, vfsr.c, vfsr.h:
Changed names of some options to more properly reflect their use as
described in the original 1989 VFSR paper.  Comments were placed in
the Makefile.  The code variables are the logs of the variables in
the paper given in brackets.
TEMPERATURE_SCALE_WEIGHT_PARAM -> TEMPERATURE_ANNEAL_SCALE [n sub i]
TEMPERATURE_SCALE_WEIGHT       -> TEMPERATURE_RATIO_SCALE  [m sub i]


Added COST_PARAMETER_SCALE if user want to override default (1.0)
of resulting cost and parameter temperature scales.

Added INCLUDE_INTEGER_PARAMETERS if user wants to override default
(FALSE) to include integer parameters in derivative and reannealing
calculations.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
vfsr.c
Changed "if" to "while" in reanneal to take care of large indices.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
vfsr.c:
Added some comments on expecting some old instead of current printed
values at very end of vfsr_out if a "premature" call to vfsr_exit.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Makefile, vfsr.c, vfsr.h, readme.ms:
Added USER_INITIAL_PARAMETERS.  Default (FALSE) is to let vfsr
calculate first generated point subject to user's constraints, likely
the most typical case in complex problems.  A statement to this effect
was put into readme.ms.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
readme.ms:
Some people were confused over the GNU COPYING-LIB file, and so the
following statement was added:

Our intent is to make this code available in the public domain to the
widest audience while maintaining the integrity of the basic algorithm.

========================================================================
2 Dec 92

Makefile, vfsr.h, vfsr.c:
Added COST_PRECISION option in Makefile to let user set precision
required of cost function if exiting because MAXIMUM_COST_REPEAT has
been reached.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
user.c, vfsr.c:
Just list Modification History at the top of each file, instead of
in each separate function.  This CHANGES file will include details
of all changes.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
vfsr.c:
An extraneous block of code, a copy of some code at the beginning
of vfsr(), was somehow placed at the end.  This returned nonsense to
the calling routine in cases of *exit_code=NORMAL_EXIT=0.  No changes
were made in TESTS.

The following lines should be deleted from v6.20 in vfsr.c
442,463d441
<     /* copy best parameters and print out results */
<     VFOR(index_v) {
< #if VFSR_PRINT
< 	fprintf(ptr_vfsr_out, "%d\t ", index_v);
< #endif
< 	current_parameter_temperature[index_v] =
< 	    initial_parameter_temperature[index_v] =
< 	    ((double) INITIAL_PARAMETER_TEMPERATURE);
<
< 	/* set the best and last state to the current generated state */
< 	best_generated_state.parameter[index_v] =
< 	    last_saved_state.parameter[index_v] =
< 	    current_generated_state.parameter[index_v];
<
< #if VFSR_PRINT
< 	fprintf(ptr_vfsr_out, "%g\t %g\t %g\t %d\n",
< 		parameter_minimum[index_v],
< 		parameter_maximum[index_v],
< 		current_generated_state.parameter[index_v],
< 		parameter_type[index_v]);
< #endif
<     }

The errors caused by this problem were first discovered by Jacob
Engelbrecht <engel@virus.fki.dth.dk>.

========================================================================
28 Nov 92
gcc-2.3.2 was installed on ingber, so this was used to recalculate
files in TESTS.  gcc-2.3.2 was just a bit faster than gcc-2.3.1.

The Dec machine used in TESTS turned out to be a 3100, not a 5100,
so the names of the appropriate files were changed in TESTS.

========================================================================
27 Nov 92

user.c:
Passed compiler options into main to print out in user_out.

========================================================================
vfsr.c:
sampled_cost_sum was incorrectly declared as int instead of
double.  This caused a crash on one machine due to the large
size of the test cost function.  Also, the cast was changed
to (double) NUMBER_COST_SAMPLES for the initial calculation of
current_generated_state.cost.  (In fact, some code during reannealing
is necessary to avoid such large integers.)

Since this alters the initial cost temperature, the sampling changes,
and the values in vfsr_out are changed.  This just happens to
make the code more "efficient" for this particular set of starting
values.  A new set of test runs was placed in TESTS, but including
SMALL_FLOAT=1.0E-12 instead of SMALL_FLOAT=1.0E-16 to permit some
comparison with a run on a Convex-C120.

Thanks to Jacob Engelbrecht <engel@virus.fki.dth.dk> for first
discovering this error.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
TESTS, Makefile:
shortened names and deleted periods in names of TESTS files to
accommodate some machines.  Older more descriptive long names are
in VFSR/TESTS/SHORT2LONG_NAMES.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Added this file, CHANGES, and a NOTES file to include more
documentation that might be of interest to users.

========================================================================
25 Nov 92

vfsr.[ch]:
Changed void to return double final_cost.  Error introduced in r5 by
passing value instead of pointer. r4 passed pointer but was considered
confusing for some to pass address.

vfsr.[ch]:
Reverted to scheme of r4, wherein one g_[...] variable and several
g_[...] addresses were used in parameter list of vfsr() to make this
local [...] information global to several other small internal vfsr
routines.

user.[ch]:
Changed names of all parameters in user.c passed to vfsr to be
different than those used in vfsr.  This should help to catch any
errors such as the one above involving final_cost.

These changes appear to speed up the program; results were the same.

Thanks to Dan Adler <adan@tudor.com> for first discovering this
blunder.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Added int *exit_status to return reason for exiting vfsr.  A warning
was put in readme.ms not to rely solely on this info.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Acknowledgment to Mark Johnson <mark@microunity.com> added to user.c.

========================================================================
5 Nov 92

Over several revisions, the core of VFSR was extracted out of previous
codes used since 1987, and global name changes were made.  Tests were
run using cost functions from old problems to check the new code.  The
old code had some very good checks performed by fitting a Lagrangian
representation of a set of nonlinear multivariate stochastic
differential equations (SDE's).  I.e., (a) data was generated from the
SDE's; (b) the coefficients were arbitrarily changed; (c) the
Lagrangian representation was processed by VFSR to find the original
coefficients, within the accuracy permitted by the variances of the
original SDE's.  Since then, there have been many different tests, such
as those referenced in the README.

========================================================================
Jan 1991

Created C-language version of VFSR.

========================================================================
1987

Created RATFOR/FORTRAN version of VFSR.

========================================================================
		@@CONTRIBUTORS
========================================================================

Acknowledgments to people who have contributed to the ASA code:

Ahmed Ouenes		<ouenes@baervan.nmt.edu>
Alan Cabrera		<adc@sanwabgk.com>
Amir Atiya		<amir@alumni.caltech.edu>
Barak Cohen		<goman@netvision.net.il>
Bill Wong		<bgwong@holonet.net>
Bruce Rosen		<rosen@ringer.cs.utsa.edu>
Burkhard Volkemer	<buv@vsnhd1.cern.ch>
Ceren Kayalar		<ckayalar@sabanciuniv.edu>
Cullen Schaffer		<schaffer@marna.hunter.cuny.edu>
Dan Adler		<adan@tudor.com>
David Hough		<david.hough@eng.sun.com>
David Zuhn		<zoo@cygnus.com>
Davyd Norris		<daffy@sci.monash.edu.au>
Dietmar Auferkorte	<dietmar.auferkorte@fernuni-hagen.de>
Edward Peschko		<peschko@mermaid.micro.umn.edu>
Eric Grosse		<ehg@research.att.com>
Felipe Almeida Lessa	<felipe.lessa@gmail.com>
Geoff Kuenning		<geoff@itcorp.com>
Giacomo Indiveri	<giacomo@dibe.unige.it>
Graham Campbell		<campbell@ams.sunysb.edu>
Guy Carpenter		<guy@tfrc.csiro.au>
Heather Sherman		<heather@cco.caltech.edu>
Helmut Jarausch		<jarausch@igpm.rwth-aachen.de>
Hime Junior		<hime@engineer.com>
Hope Pioro		<hpioro@bank-banque-canada.ca>
Ion Georgiades		<iong@videotron.ca>
Jacob Engelbrecht	<engel@virus.fki.dth.dk>
Jacques Mequin		<jmequin@tif.ti.com>
James Clark		<jjc@ai.mit.edu>
John Dean		<john_c_dean@bankone.com>
John Johnson		<john.johnson@epcos.com>
John Selverian		<selveria@rd.sylvania.com>
Knut Buettner		<buettner@aix03.fk.bgt.de>
Kevin Burton		<kburton@noran.com>
Lee Hon Man		<89299465@cphkvx.cphk.hk>
Leslie Picardo		<picardo@alpha.ces.cwru.edu>
Magne Myrtveit		<magne@myrtveit.com>
Mark Johnson		<mjohnson@netcom.com>
Matthew O'Hara		<mattman@cml.berkeley.edu>
Matthias Kirst		<matt@clondiag.com>
Micah Altman		<micah@cco.caltech.edu>
Paul Teetor		<e3uprt@fnma.com>
Radu Mondescu		<rmondescu@drwtrading.com>
Ravi Bansal		<xbansal@suned.zoo.cs.yale.edu>
Shinichi Sakata		<shinichi.sakata@gmail.com>
Sonja Zwissler		<zwissler@askdonald.ask.uni-karlsruhe.de>
Steve Danauskas		<steved@uchicago.edu>
Steven Gillispie	<steve_gillispie@oscar.rad.washington.edu>
Thomas Binder		<binder@iue.tuwien.ac.at>
Thomas Marston Morse	<morse@chinook.uoregon.edu>
Timothy Burns		<tim@isis.usi.utah.edu>
Walter Roberson		<roberson@hamer.ibd.nrc.ca>
Wolfram Gloger		<wmglo@dent.med.uni-muenchen.de>
Wu Kenong		<wu@mcrcim.mcgill.edu>
Yuan Liu		<liu@cs.umd.edu>
Zening Ge		<zg11@midway.uchicago.edu>

========================================================================
		@@VERSION DATES
========================================================================
* Modification History:
*	02 Feb 16:	Version	30.21
*	02 Feb 16:	Version	30.20
*	02 Feb 16:	Version	30.19
*	27 Jan 15:	Version	30.18
*	27 Jan 15:	Version	30.17
*	27 Jan 15:	Version	30.16
*	11 Oct 14:	Version	30.15
*	11 Oct 14:	Version	30.14
*	11 Oct 14:	Version	30.13
*	11 Oct 14:	Version	30.12
*	11 Oct 14:	Version	30.11
*	28 Jul 14:	Version	30.10
*	28 Jul 14:	Version	30.9
*	28 Jul 14:	Version	30.8
*	09 Apr 14:	Version	30.7
*	21 Jan 14:	Version	30.6
*	21 Jan 14:	Version	30.5
*	19 Jan 14:	Version	30.4
*	06 Jan 14:	Version	30.3
*	06 Jan 14:	Version	30.2
*	04 Jan 14:	Version	30.1
*	19 Oct 13:	Version	29.6
*	19 Oct 13:	Version	29.5
*	19 Oct 13:	Version	29.4
*	13 Sep 13:	Version	29.3
*	13 Sep 13:	Version	29.2
*	12 Sep 13:	Version	29.1
*	12 Sep 13:	Version	28.16
*	08 Apr 13:	Version	28.15
*	26 Mar 13:	Version	28.14
*	07 Aug 12:	Version	28.13
*	02 Jul 12:	Version	28.12
*	13 Apr 12:	Version	28.11
*	11 Apr 12:	Version	28.10
*	04 Feb 12:	Version	28.9
*	29 Dec 11:	Version	28.8
*	29 Dec 11:	Version	28.7
*	16 Oct 11:	Version	28.6
*	27 Jul 11:	Version	28.5
*	09 Mar 11:	Version	28.4
*	09 Mar 11:	Version	28.3
*	09 Mar 11:	Version	28.2
*	09 Feb 11:	Version	28.1
*	15 Dec 10:	Version	27.6
*	14 Dec 10:	Version	27.5
*	10 Dec 10:	Version	27.4
*	10 Dec 10:	Version	27.3
*	10 Dec 10:	Version	27.2
*	10 Dec 10:	Version	27.1
*	08 Dec 10:	Version	26.40
*	16 Jul 10:	Version	26.39
*	04 Jan 10:	Version	26.38
*	04 Nov 09:	Version	26.37
*	03 Nov 09:	Version	26.36
*	15 Apr 09:	Version	26.35
*	26 Jan 09:	Version	26.34
*	30 Dec 08:	Version	26.33
*	13 Sep 08:	Version	26.32
*	24 Jul 08:	Version	26.31
*	24 Apr 08:	Version	26.30
*	08 Mar 08:	Version	26.29
*	20 Feb 08:	Version	26.28
*	19 Feb 08:	Version	26.27
*	18 Feb 08:	Version	26.26
*	18 Feb 08:	Version	26.25
*	26 Dec 07:	Version	26.24
*	31 Jan 07:	Version	26.23
*	23 Nov 06:	Version	26.22
*	21 Nov 06:	Version	26.21
*	26 Sep 06:	Version	26.20
*	25 Sep 06:	Version	26.19
*	27 Jul 06:	Version	26.18
*	20 Jul 06:	Version	26.17
*	20 Jul 06:	Version	26.16
*	19 Jul 06:	Version	26.15
*	13 Jul 06:	Version	26.14
*	12 May 06:	Version	26.13
*	26 Feb 06:	Version	26.12
*	25 Feb 06:	Version	26.11
*	23 Feb 06:	Version	26.10
*	23 Feb 06:	Version	26.9
*	26 Jan 06:	Version	26.8
*	02 Jan 06:	Version	26.7
*	01 Jan 06:	Version	26.6
*	29 Nov 05:	Version	26.5
*	28 Nov 05:	Version	26.4
*	07 Oct 05:	Version	26.3
*	26 Aug 05:	Version	26.2
*	23 Aug 05:	Version	26.1
*	07 Jul 05:	Version	25.28
*	03 Apr 05:	Version	25.27
*	02 Mar 05:	Version	25.26
*	22 Jan 05:	Version	25.25
*	12 Jan 05:	Version	25.24
*	11 Jan 05:	Version	25.23
*	07 Jan 05:	Version	25.22
*	07 Jan 05:	Version	25.21
*	03 Jan 05:	Version	25.20
*	03 Jan 05:	Version	25.19
*	03 Jan 05:	Version	25.18
*	12 Dec 04:	Version	25.17
*	06 Dec 04:	Version	25.16
*	23 Sep 04:	Version	25.15
*	26 Jul 04:	Version	25.14
*	10 Jun 04:	Version	25.13
*	13 May 04:	Version	25.12
*	12 May 04:	Version	25.11
*	23 Feb 04:	Version	25.10
*	19 Feb 04:	Version	25.9
*	11 Feb 04:	Version	25.8
*	10 Feb 04:	Version	25.7
*	17 Jan 04:	Version	25.6
*	25 Jul 03:	Version	25.5
*	24 Jun 03:	Version	25.4
*	22 Apr 03:	Version	25.3
*	13 Apr 03:	Version	25.2
*	22 Feb 03:	Version	25.1
*	06 Jan 03:	Version	24.3
*	23 Oct 02:	Version	24.2
*	03 Jun 02:	Version	24.1
*	22 Apr 02:	Version	23.13
*	19 Apr 02:	Version	23.12
*	05 Mar 02:	Version	23.11
*	15 Nov 01:	Version	23.10
*	13 Nov 01:	Version	23.9
*	29 Oct 01:	Version	23.8
*	12 Oct 01:	Version	23.7
*	11 Oct 01:	Version	23.6
*	14 Sep 01:	Version	23.5
*	11 Aug 01:	Version	23.4
*	01 Aug 01:	Version	23.3
*	20 Jul 01:	Version	23.2
*	19 Jul 01:	Version	23.1
*	21 Jun 01:	Version	22.12
*	15 May 01:	Version	22.11
*	13 May 01:	Version	22.10
*	04 May 01:	Version	22.9
*	17 Apr 01:	Version	22.8
*	27 Mar 01:	Version	22.7
*	16 Mar 01:	Version	22.6
*	05 Mar 01:	Version	22.5
*	25 Jan 01:	Version	22.4
*	25 Jan 01:	Version	22.3
*	17 Jan 01:	Version	22.2
*	14 Jan 01:	Version	22.1
*	30 Dec 00:	Version	21.10
*	19 Dec 00:	Version	21.9
*	18 Dec 00:	Version	21.8
*	18 Dec 00:	Version	21.7
*	12 Dec 00:	Version	21.6
*	28 Nov 00:	Version	21.5
*	26 Nov 00:	Version	21.4
*	24 Oct 00:	Version	21.3
*	24 Oct 00:	Version	21.2
*	19 Sep 00:	Version	21.1
*	07 Sep 00:	Version	20.25
*	21 Aug 00:	Version	20.24
*	04 Aug 00:	Version	20.23
*	02 Aug 00:	Version	20.22
*	02 Aug 00:	Version	20.21
*	02 Aug 00:	Version	20.20
*	29 Jul 00:	Version	20.19
*	21 Jul 00:	Version	20.18
*	26 May 00:	Version	20.17
*	19 May 00:	Version	20.16
*	12 May 00:	Version	20.15
*	10 May 00:	Version	20.14
*	10 May 00:	Version	20.13
*	09 May 00:	Version	20.12
*	09 May 00:	Version	20.11
*	08 May 00:	Version	20.10
*	06 May 00:	Version	20.9
*	03 May 00:	Version	20.8
*	04 Apr 00:	Version	20.7
*	15 Mar 00:	Version	20.6
*	01 Mar 00:	Version	20.5
*	28 Feb 00:	Version	20.4
*	25 Feb 00:	Version	20.3
*	21 Jan 00:	Version	20.2
*	19 Jan 00:	Version	20.1
*	29 Dec 99:	Version	19.13
*	28 Dec 99:	Version	19.12
*	26 Dec 99:	Version	19.11
*	08 Dec 99:	Version	19.10
*	08 Dec 99:	Version	19.9
*	30 Nov 99:	Version	19.8
*	30 Nov 99:	Version	19.7
*	27 Nov 99:	Version	19.6
*	25 Nov 99:	Version	19.5
*	18 Nov 99:	Version	19.4
*	17 Nov 99:	Version	19.3
*	14 Nov 99:	Version	19.2
*	13 Nov 99:	Version	19.1
*	13 Nov 99:	Version	18.8
*	11 Nov 99:	Version	18.7
*	07 Nov 99:	Version	18.6
*	06 Nov 99:	Version	18.5
*	21 Oct 99:	Version	18.4
*	19 Oct 99:	Version	18.3
*	30 Sep 99:	Version	18.2
*	29 Sep 99:	Version	18.1
*	22 Sep 99:	Version	17.26
*	09 Sep 99:	Version	17.25
*	08 Sep 99:	Version	17.24
*	08 Sep 99:	Version	17.23
*	25 Aug 99:	Version	17.22
*	19 Aug 99:	Version	17.21
*	17 Aug 99:	Version	17.20
*	15 Feb 99:	Version	17.19
*	15 Feb 99:	Version	17.18
*	07 Feb 99:	Version	17.17
*	04 Feb 99:	Version	17.16
*	27 Jan 99:	Version	17.15
*	15 Jan 99:	Version	17.14
*	26 Sep 98:	Version	17.13
*	26 Sep 98:	Version	17.12
*	26 Sep 98:	Version	17.11
*	25 Sep 98:	Version	17.10
*	24 Sep 98:	Version	17.9
*	12 Jul 98:	Version	17.8
*	09 Jul 98:	Version	17.7
*	09 Jul 98:	Version	17.6
*	08 Jul 98:	Version	17.5
*	08 Jul 98:	Version	17.4
*	08 Jul 98:	Version	17.3
*	08 Jul 98:	Version	17.2
*	07 Jul 98:	Version	17.1
*	19 Jun 98:	Version	16.21
*	18 Jun 98:	Version	16.20
*	29 May 98:	Version	16.19
*	26 Apr 98:	Version	16.18
*	09 Apr 98:	Version	16.17
*	06 Mar 98:	Version	16.16
*	05 Mar 98:	Version	16.15
*	12 Feb 98:	Version	16.14
*	31 Jan 98:	Version	16.13
*	23 Jan 98:	Version	16.12
*	22 Jan 98:	Version	16.11
*	09 Jan 98:	Version	16.10
*	08 Jan 98:	Version	16.9
*	29 Dec 97:	Version	16.8
*	18 Dec 97:	Version	16.7
*	07 Dec 97:	Version	16.6
*	05 Dec 97:	Version	16.5
*	01 Dec 97:	Version	16.4
*	30 Nov 97:	Version	16.3
*	30 Nov 97:	Version	16.2
*	29 Nov 97:	Version	16.1
*	07 Nov 97:	Version	15.25
*	03 Nov 97:	Version	15.24
*	27 Oct 97:	Version	15.23
*	16 Sep 97:	Version	15.22
*	28 Aug 97:	Version	15.21
*	28 Aug 97:	Version	15.20
*	26 Aug 97:	Version	15.19
*	26 Aug 97:	Version	15.18
*	23 Aug 97:	Version	15.17
*	06 Aug 97:	Version	15.16
*	06 Aug 97:	Version	15.15
*	31 Jul 97:	Version	15.14
*	15 Jul 97:	Version	15.13
*	03 Jul 97:	Version	15.12
*	25 Jun 97:	Version	15.11
*	20 Jun 97:	Version	15.10
*	17 Jun 97:	Version	15.9
*	14 Jun 97:	Version	15.8
*	08 Jun 97:	Version	15.7
*	06 Jun 97:	Version	15.6
*	06 Jun 97:	Version	15.5
*	06 Jun 97:	Version	15.4
*	05 Jun 97:	Version	15.3
*	04 Jun 97:	Version	15.2
*	01 Jun 97:	Version	15.1
*	29 May 97:	Version	14.16
*	22 May 97:	Version	14.15
*	22 May 97:	Version	14.14
*	22 May 97:	Version	14.13
*	18 May 97:	Version	14.12
*	12 May 97:	Version	14.11
*	11 May 97:	Version	14.10
*	08 May 97:	Version	14.9
*	13 Apr 97:	Version	14.8
*	24 Mar 97:	Version	14.7
*	11 Mar 97:	Version	14.6
*	02 Mar 97:	Version	14.5
*	22 Feb 97:	Version	14.4
*	03 Feb 97:	Version	14.3
*	10 Jan 97:	Version	14.2
*	10 Jan 97:	Version	14.1
*	30 Dec 96:	Version	13.19
*	26 Dec 96:	Version	13.18
*	21 Dec 96:	Version	13.17
*	09 Dec 96:	Version	13.16
*	04 Dec 96:	Version	13.15
*	30 Nov 96:	Version	13.14
*	22 Nov 96:	Version	13.13
*	22 Nov 96:	Version	13.12
*	21 Nov 96:	Version	13.11
*	14 Nov 96:	Version	13.10
*	03 Nov 96:	Version	13.9
*	16 Sep 96:	Version	13.8
*	15 Sep 96:	Version	13.7
*	11 Sep 96:	Version	13.6
*	16 Aug 96:	Version	13.5
*	24 Jul 96:	Version	13.4
*	24 Jul 96:	Version	13.3
*	03 Jul 96:	Version	13.2
*	14 Jun 96:	Version	13.1
*	13 Jun 96:	Version	12.30
*	10 Jun 96:	Version	12.29
*	09 Jun 96:	Version	12.28
*	09 Jun 96:	Version	12.27
*	22 May 96:	Version	12.26
*	22 May 96:	Version	12.25
*	09 May 96:	Version	12.24
*	02 May 96:	Version	12.23
*	02 May 96:	Version	12.22
*	29 Apr 96:	Version	12.21
*	23 Apr 96:	Version	12.20
*	19 Apr 96:	Version	12.19
*	16 Apr 96:	Version	12.18
*	10 Apr 96:	Version	12.17
*	08 Apr 96:	Version	12.16
*	07 Apr 96:	Version	12.15
*	06 Apr 96:	Version	12.14
*	04 Apr 96:	Version	12.13
*	17 Mar 96:	Version	12.12
*	12 Mar 96:	Version	12.11
*	02 Mar 96:	Version	12.10
*	29 Feb 96:	Version	12.9
*	28 Feb 96:	Version	12.8
*	13 Feb 96:	Version	12.7
*	09 Feb 96:	Version	12.6
*	18 Jan 96:	Version	12.5
*	17 Jan 96:	Version	12.4
*	15 Jan 96:	Version	12.3
*	15 Jan 96:	Version	12.2
*	13 Jan 96:	Version	12.1
*	10 Jan 96:	Version	11.28
*	08 Jan 96:	Version	11.27
*	08 Jan 96:	Version	11.26
*	06 Jan 96:	Version	11.25
*	05 Jan 96:	Version	11.24
*	05 Jan 96:	Version	11.23
*	05 Jan 96:	Version	11.22
*	30 Dec 95:	Version	11.21
*	29 Dec 95:	Version	11.20
*	29 Dec 95:	Version	11.19
*	19 Dec 95:	Version	11.18
*	17 Dec 95:	Version	11.17
*	08 Dec 95:	Version	11.16
*	07 Dec 95:	Version	11.15
*	07 Dec 95:	Version	11.14
*	07 Dec 95:	Version	11.13
*	07 Dec 95:	Version	11.12
*	05 Dec 95:	Version	11.11
*	05 Dec 95:	Version	11.10
*	01 Dec 95:	Version	11.9
*	20 Nov 95:	Version	11.8
*	17 Nov 95:	Version	11.7
*	16 Nov 95:	Version	11.6
*	04 Nov 95:	Version	11.5
*	04 Nov 95:	Version	11.4
*	03 Nov 95:	Version	11.3
*	03 Nov 95:	Version	11.2
*	03 Nov 95:	Version	11.1
*	01 Nov 95:	Version	10.23
*	30 Oct 95:	Version	10.22
*	30 Oct 95:	Version	10.21
*	29 Oct 95:	Version	10.20
*	28 Oct 95:	Version	10.19
*	22 Oct 95:	Version	10.18
*	22 Oct 95:	Version	10.17
*	04 Oct 95:	Version	10.16
*	01 Oct 95:	Version	10.15
*	01 Oct 95:	Version	10.14
*	01 Oct 95:	Version	10.13
*	30 Sep 95:	Version	10.12
*	29 Sep 95:	Version	10.11
*	29 Sep 95:	Version	10.10
*	29 Sep 95:	Version	10.9
*	28 Sep 95:	Version	10.8
*	28 Sep 95:	Version	10.7
*	28 Sep 95:	Version	10.6
*	24 Sep 95:	Version	10.5
*	24 Sep 95:	Version	10.4
*	16 Sep 95:	Version	10.3
*	15 Sep 95:	Version	10.2
*	15 Sep 95:	Version	10.1
*	14 Sep 95:	Version	9.8
*	13 Sep 95:	Version	9.7
*	13 Sep 95:	Version	9.6
*	08 Sep 95:	Version	9.5
*	03 Sep 95:	Version	9.4
*	01 Sep 95:	Version	9.3
*	29 Aug 95:	Version	9.2
*	25 Aug 95:	Version	9.1
*	21 Aug 95:	Version	8.14
*	19 Aug 95:	Version	8.13
*	13 Aug 95:	Version	8.12
*	08 Aug 95:	Version	8.11
*	06 Aug 95:	Version	8.10
*	04 Aug 95:	Version	8.9
*	03 Aug 95:	Version	8.8
*	03 Aug 95:	Version	8.7
*	29 Jul 95:	Version	8.6
*	15 Jul 95:	Version	8.5
*	06 Jul 95:	Version	8.4
*	06 Jul 95:	Version	8.3
*	02 Jul 95:	Version	8.2
*	15 Jun 95:	Version	8.1
*	09 Jun 95:	Version	7.17
*	05 Jun 95:	Version	7.16
*	30 May 95:	Version	7.15
*	30 May 95:	Version	7.14
*	25 May 95:	Version	7.13
*	25 May 95:	Version	7.12
*	16 May 95:	Version	7.11
*	04 May 95:	Version	7.10
*	30 Apr 95:	Version	7.9
*	23 Apr 95:	Version	7.8
*	19 Apr 95:	Version	7.7
*	19 Apr 95:	Version	7.6
*	17 Apr 95:	Version	7.5
*	16 Apr 95:	Version	7.4
*	14 Apr 95:	Version	7.3
*	14 Apr 95:	Version	7.2
*	12 Apr 95:	Version	7.1
*	02 Apr 95:	Version	6.32
*	26 Mar 95:	Version	6.31
*	25 Mar 95:	Version	6.30
*	24 Mar 95:	Version	6.29
*	24 Mar 95:	Version	6.28
*	24 Mar 95:	Version	6.27
*	17 Mar 95:	Version	6.26
*	09 Mar 95:	Version	6.25
*	08 Mar 95:	Version	6.24
*	28 Feb 95:	Version	6.23
*	26 Feb 95:	Version	6.22
*	19 Feb 95:	Version	6.21
*	18 Feb 95:	Version	6.20
*	18 Feb 95:	Version	6.19
*	18 Feb 95:	Version	6.18
*	18 Feb 95:	Version	6.17
*	17 Feb 95:	Version	6.16
*	17 Feb 95:	Version	6.15
*	17 Feb 95:	Version	6.14
*	16 Feb 95:	Version	6.13
*	16 Feb 95:	Version	6.12
*	16 Feb 95:	Version	6.11
*	14 Feb 95:	Version	6.10
*	11 Feb 95:	Version	6.9
*	11 Feb 95:	Version	6.8
*	09 Feb 95:	Version	6.7
*	08 Feb 95:	Version	6.6
*	08 Feb 95:	Version	6.5
*	07 Feb 95:	Version	6.4
*	05 Feb 95:	Version	6.3
*	01 Feb 95:	Version	6.2
*	01 Feb 95:	Version	6.1
*	27 Jan 95:	Version	5.13
*	26 Jan 95:	Version	5.12
*	18 Jan 95:	Version	5.11
*	13 Jan 95:	Version	5.10
*	13 Jan 95:	Version	5.9
*	12 Jan 95:	Version	5.8
*	30 Dec 94:	Version	5.7
*	20 Dec 94:	Version	5.6
*	19 Dec 94:	Version	5.5
*	19 Dec 94:	Version	5.4
*	18 Dec 94:	Version	5.3
*	17 Dec 94:	Version	5.2
*	16 Dec 94:	Version	5.1
*	15 Dec 94:	Version	4.12
*	13 Dec 94:	Version	4.11
*	08 Dec 94:	Version	4.10
*	23 Nov 94:	Version	4.9
*	13 Nov 94:	Version	4.8
*	12 Nov 94:	Version	4.7
*	08 Nov 94:	Version	4.6
*	07 Nov 94:	Version	4.5
*	06 Nov 94:	Version	4.4
*	05 Nov 94:	Version	4.3
*	23 Oct 94:	Version	4.2
*	23 Oct 94:	Version	4.1
*	23 Oct 94:	Version	3.25
*	22 Oct 94:	Version	3.24
*	20 Oct 94:	Version	3.23
*	19 Oct 94:	Version	3.22
*	14 Oct 94:	Version	3.21
*	01 Oct 94:	Version	3.20
*	31 Aug 94:	Version	3.19
*	19 Aug 94:	Version	3.18
*	28 Jun 94:	Version	3.17
*	09 Jun 94:	Version	3.16
*	06 Jun 94:	Version	3.15
*	04 Jun 94:	Version	3.14
*	31 May 94:	Version	3.13
*	27 Apr 94:	Version	3.12
*	27 Apr 94:	Version	3.11
*	19 Apr 94:	Version	3.10
*	18 Apr 94:	Version	3.9
*	17 Apr 94:	Version	3.8
*	16 Apr 94:	Version	3.7
*	15 Apr 94:	Version	3.6
*	10 Apr 94:	Version	3.5
*	10 Apr 94:	Version	3.4
*	08 Apr 94:	Version	3.3
*	07 Apr 94:	Version	3.2
*	06 Apr 94:	Version	3.1
*	05 Apr 94:	Version	2.32
*	05 Apr 94:	Version	2.31
*	31 Mar 94:	Version	2.30
*	29 Mar 94:	Version	2.29
*	17 Mar 94:	Version	2.28
*	16 Mar 94:	Version	2.27
*	11 Mar 94:	Version	2.26
*	10 Mar 94:	Version	2.25
*	09 Mar 94:	Version	2.24
*	08 Mar 94:	Version	2.23
*	04 Mar 94:	Version	2.22
*	03 Mar 94:	Version	2.21
*	17 Feb 94:	Version	2.20
*	16 Feb 94:	Version	2.19
*	16 Feb 94:	Version	2.18
*	15 Feb 94:	Version	2.17
*	13 Feb 94:	Version	2.16
*	10 Feb 94:	Version	2.15
*	03 Feb 94:	Version	2.14
*	01 Feb 94:	Version	2.13
*	31 Jan 94:	Version	2.12
*	28 Jan 94:	Version	2.11
*	21 Jan 94:	Version	2.10
*	17 Jan 94:	Version	2.9
*	16 Jan 94:	Version	2.8
*	13 Jan 94:	Version	2.7
*	12 Jan 94:	Version	2.6
*	12 Jan 94:	Version	2.5
*	09 Jan 94:	Version	2.4
*	21 Dec 93:	Version	2.3
*	04 Dec 93:	Version	2.2
*	26 Nov 93:	Version	2.1
*	22 Nov 93:	Version	1.59
*	17 Nov 93:	Version	1.58
*	16 Nov 93:	Version	1.57
*	15 Nov 93:	Version	1.56
*	14 Nov 93:	Version	1.55
*	14 Nov 93:	Version	1.54
*	12 Nov 93:	Version	1.53
*	11 Nov 93:	Version	1.52
*	06 Nov 93:	Version	1.51
*	26 Oct 93:	Version	1.50
*	23 Oct 93:	Version	1.49
*	15 Oct 93:	Version	1.48
*	15 Oct 93:	Version	1.47
*	14 Oct 93:	Version	1.46
*	29 Sep 93:	Version	1.45
*	24 Sep 93:	Version	1.44
*	17 Sep 93:	Version	1.43
*	14 Sep 93:	Version	1.42
*	01 Sep 93:	Version	1.41
*	18 Aug 93:	Version	1.40
*	16 Aug 93:	Version	1.39
*	28 Jul 93:	Version	1.38
*	24 Jul 93:	Version	1.37
*	10 Jul 93:	Version	1.36
*	05 Jul 93:	Version	1.35
*	04 Jul 93:	Version	1.34
*	30 Jun 93:	Version	1.33
*	29 Jun 93:	Version	1.32
*	16 Jun 93:	Version	1.31
*	12 Jun 93:	Version	1.30
*	10 Jun 93:	Version	1.29
*	09 Jun 93:	Version	1.28
*	08 Jun 93:	Version	1.27
*	06 Jun 93:	Version	1.26
*	06 Jun 93:	Version	1.25
*	05 Jun 93:	Version	1.24
*	04 Jun 93:	Version	1.23
*	02 Jun 93:	Version	1.22
*	02 Jun 93:	Version	1.21
*	31 May 93:	Version	1.20
*	31 May 93:	Version	1.19
*	29 May 93:	Version	1.18
*	25 May 93:	Version	1.17
*	25 May 93:	Version	1.16
*	24 May 93:	Version	1.15
*	22 May 93:	Version	1.14
*	17 May 93:	Version	1.13
*	16 May 93:	Version	1.12
*	16 May 93:	Version	1.11
*	15 May 93:	Version	1.10
*	14 May 93:	Version	1.9
*	14 May 93:	Version	1.8
*	13 May 93:	Version	1.7
*	11 May 93:	Version	1.6
*	09 May 93:	Version	1.5
*	08 May 93:	Version	1.4
*	07 May 93:	Version	1.3
*	05 May 93:	Version	1.2
*	20 Apr 93:	Version	1.1	first ASA release
*	05 Apr 93:	VFSR	9.4
*	04 Apr 93:	VFSR	9.3
*	22 Mar 93:	VFSR	9.1
*	05 Mar 93:	VFSR	8.2
*	27 Feb 93:	VFSR	8.1
*	18 Feb 93:	VFSR	7.7
*	15 Feb 93:	VFSR	7.6
*	07 Feb 93:	VFSR	7.4
*	04 Feb 93:	VFSR	7.3
*	01 Feb 93:	VFSR	7.1
*	28 Jan 93:	VFSR	6.46
*	18 Jan 93:	VFSR	6.40
*	01 Jan 93:	Version	1.0	development stage of ASA
*	30 Dec 92:	VFSR	6.38
*	17 Dec 92:	VFSR	6.35
*	13 Dec 92:	VFSR	6.34
*	09 Dec 92:	VFSR	6.33
*	07 Dec 92:	VFSR	6.30
*	03 Dec 92:	VFSR	6.25
*	30 Nov 92:	VFSR	6.20
*	19 Nov 92:	Beta VFSR
*	05 Nov 92:	Initial C-language GNU version of VFSR
*	Jan 1991:	Created C-language version of VFSR
*	1987:		Created RATFOR/FORTRAN version of VFSR
========================================================================
##
# /***********************************************************************
# * Adaptive Simulated Annealing (ASA)
# * Lester Ingber <ingber@ingber.com>
# * Copyright (c) 1987-2016 Lester Ingber.  All Rights Reserved.
# * ASA-LICENSE file has the license that must be included with ASA code.
# ***********************************************************************/
#
## $Id: ASA-Makefile,v 30.21 2016/02/02 15:49:40 ingber Exp ingber $

## ********************************************************************
## First read ASA-README, then examine this ASA-Makefile and ASA-NOTES.
## ********************************************************************

MANIFEST = \
	ASA-CHANGES \
	ASA-LICENSE \
	ASA-Makefile \
	ASA-NOTES \
	ASA-README.html \
	ASA-README.ms \
	ASA-README.pdf \
	ASA-README.ps \
	ASA-README+.txt \
	ASA-README.txt \
	asa_test_asa \
	asa_test_usr \
	asa_usr.c \
	asa_usr.h \
	asa_usr_cst.c \
	asa.c \
	asa.h \
	asa_usr_asa.h \
	asa_opt

###
###		USER OPTIONS
### The policy is to try to have the asa module (not necessarily
### the user module) compile without "errors" (not necessarily without
### "warnings").  Some additional modifications may be needed on your
### machine; e.g., you might have to comment out the `#include <stdlib.h>'
### line in asa_usr_asa.h.  See the current ASA-NOTES file for any
### updates on some standard implementations.

###
## Defaults for various options are given below.  These can be
## overridden using DEFINE_OPTIONS.  If you include several options,
## separate them by a white space or place them conveniently on several
## lines; if the latter, be sure each line to be continued ends in a "\"
## (backslash).

DEFINE_OPTIONS = -DASA_TEST=TRUE # -DMY_TEMPLATE=TRUE

## This will run the ASA problem.
#DEFINE_OPTIONS = -DASA_TEST=TRUE
##
## This ASA_TEMPLATE will number the ASA_OUT file according to the
## system pid.  See asa_usr.h or possible changes you may have to make in the
## include file and the prototype for getpid(), as well as for the set of
## DEFINE_OPTIONS this example turns on.  (You might also have to change
## the int declaration of pid_int in asa_usr.c as well.)
#DEFINE_OPTIONS = -DASA_TEMPLATE_ASA_OUT_PID=FALSE
##
## This ASA_TEMPLATE will run the ASA test problem multiple times, and
## separate the runs into different files.  See asa_usr_asa.h for the set
## of DEFINE_OPTIONS this example turns on.
#DEFINE_OPTIONS = -DASA_TEMPLATE_MULTIPLE=FALSE
##
## This ASA_TEMPLATE illustrates the use of SELF_OPTIMIZE=TRUE.  See
## asa_usr_asa.h for the set of DEFINE_OPTIONS this example turns on.
#DEFINE_OPTIONS = -DASA_TEMPLATE_SELFOPT=FALSE
##
## This will run the ASA_SAMPLE problem.  See asa_usr_asa.h for the set of
## DEFINE_OPTIONS this example turns on.
#DEFINE_OPTIONS = -DASA_TEMPLATE_SAMPLE=FALSE
##
## This will run the ASA_QUEUE problem.  See asa_usr_asa.h for the set of
## DEFINE_OPTIONS this example turns on.
#DEFINE_OPTIONS = -DASA_TEMPLATE_QUEUE=FALSE
##
##This will run the ASA_PARALLEL code.  See asa_usr_asa.h for the set of
## DEFINE_OPTIONS this example turns on.
#DEFINE_OPTIONS = -DASA_TEMPLATE_PARALLEL=FALSE
##
## These will run the ASA_SAVE problem.  See asa_usr_asa.h for the set of
## DEFINE_OPTIONS this example turns on.
#DEFINE_OPTIONS = -DASA_TEMPLATE_SAVE=FALSE
##

###
###		Pre-Compile Options
###
## You can elect to read in the Program Options from asa_opt by
## setting OPTIONS_FILE=TRUE.  OPTIONS_FILE=TRUE can be set here or
## in asa_usr_asa.h.
#-DOPTIONS_FILE=TRUE

## If OPTIONS_FILE is set to TRUE, then also setting OPTIONS_FILE_DATA
## to TRUE will read in most initialization data from asa_opt.
#-DOPTIONS_FILE_DATA=TRUE

## You can elect to read in the Program Options from asa_opt by setting
## RECUR_OPTIONS_FILE=TRUE.  RECUR_OPTIONS_FILE=TRUE can be set here or in
## asa_usr_asa.h.
#-DRECUR_OPTIONS_FILE=FALSE

## If RECUR_OPTIONS_FILE is set to TRUE, then also setting
## RECUR_OPTIONS_FILE_DATA to TRUE will read in most initialization data
## from asa_opt.
#-DRECUR_OPTIONS_FILE_DATA=FALSE

## If COST_FILE is set to TRUE, then your own file for the cost
## function can be read into asa_usr.c.
#-DCOST_FILE=TRUE

## Setting ASA_LIB=TRUE will facilitate your running asa() as a library
## call from another program, calling asa_main() in asa_usr.c.  In the
## templates, provided, all initializations and cost function definitions
## are set up in asa_usr.c.
#-DASA_LIB=FALSE

## If ASA_TEMPLATE_LIB=TRUE, then asa_main() returns information to an
## example main() in asa_usr.c.  This illustrates how you provide the
## appropriate memory in your main().
#-DASA_TEMPLATE_LIB=FALSE

## If you do _not_ have an ANSI compiler set this to FALSE.
## If you use HAVE_ANSI=FALSE, change CC and CDEBUGFLAGS below.
#-DHAVE_ANSI=TRUE

## Most newer operating systems do not like any other I/O prototyping
## other than those in their own include files.  Other machines, like a
## Dec\-3100 under Ultrix complain that the ANSI I/O prototypes were
## inconsistent.  A Sun under 4.1.x gcc gave warnings if no I/O prototypes
## were present.  The defaults in asa_usr_asa.h use newer system prototypes.
## IO_PROTOTYPES=TRUE will uncomment out declarations for such items as
## fprintf, fflush, fclose, exit, and fscanf.
#-DIO_PROTOTYPES=FALSE

## Some systems do not have the time include files used here; others
## have different scales for time.  Setting TIME_CALC=TRUE will permit
## use of the time routines.
#-DTIME_CALC=FALSE
 
## Some systems, e.g., hpux, use other Unix-standard macros to access
## time.  Setting TIME_STD=TRUE when using TIME_CALC=TRUE will use these
## time routines instead.
#-DTIME_STD=FALSE

## Some smaller systems choke on `long int' and this option can be
## set to INT_LONG=FALSE to turn off warnings and possibly some errors.
#-DINT_LONG=TRUE

## Some machine may not permit the dimension of calloc be anything
## but int; in this case define INT_ALLOC=TRUE.  The default of FALSE
## is to set the dimension to that of LONG_INT, determined by INT_LONG.
#-DINT_ALLOC=FALSE

## You can define SMALL_FLOAT to better correlate to your own machine's
## maximum precision here if you know it.
#-DSMALL_FLOAT=1.0E-18

## You can define your own machine's minimum positive doubles here
## if you know it.

#-DMIN_DOUBLE=SMALL_FLOAT

## You can define your own machine's maximum doubles here if you
## know it.
#-DMAX_DOUBLE=1.0/SMALL_FLOAT

## You can define your own machine's maximum precision here if you
## know it.
#-DEPS_DOUBLE=SMALL_FLOAT

## When CHECK_EXPONENT is TRUE, EXPONENT_CHECK(x) in asa() checks that
## an exponent x is within a valid range and, if not, adjusts its
## magnitude to fit in the range.
#-DCHECK_EXPONENT=FALSE

## When parameter temperatures are less than SMALL_FLOAT, do not exit,
## and set them to SMALL_FLOAT.
#-DNO_PARAM_TEMP_TEST=FALSE

## When the cost temperature is less than SMALL_FLOAT, do not exit,
## and set it to SMALL_FLOAT.
#-DNO_COST_TEMP_TEST=FALSE

## You can try to use asa to self-optimize its own Program Options
## be setting SELF_OPTIMIZE=TRUE.  This can be very CPU-expensive as
## well as being dependent on your definition of recur_cost_function.
#-DSELF_OPTIMIZE=FALSE

## To use the ASA test problem, set ASA_TEST to TRUE.
#-DASA_TEST=FALSE

## To use the enhanced ASA test problem, set ASA_TEST_POINT to TRUE.
#-DASA_TEST_POINT=FALSE

## To  permit IMMEDIATE_EXIT before calculating the next generated state,
## by deleting the file asa_exit_anytime, set ASA_EXIT_ANYTIME to TRUE.
#-DASA_EXIT_ANYTIME=FALSE

## Setting USER_INITIAL_COST_TEMP to TRUE permits you to specify the
## initial cost temperature.  This can be useful in problems where you
## want to start the search at a specific scale.
#-DUSER_INITIAL_COST_TEMP=FALSE

## Different rates of parameter annealing can be set with
## RATIO_TEMPERATURE_SCALES set to TRUE.
#-DRATIO_TEMPERATURE_SCALES=FALSE

## Setting USER_INITIAL_PARAMETERS_TEMPS to TRUE permits you to specify
## the initial parameter temperatures.  This can be useful in constrained
## problems, where greater efficiency can be achieved in focussing the
## search than might be permitted just by setting upper and lower bounds.
#-DUSER_INITIAL_PARAMETERS_TEMPS=FALSE

## Different increments, used during reannealing to set each
## parameter's numerical derivatives, can be set with DELTA_PARAMETERS set
## to TRUE.
#-DDELTA_PARAMETERS=FALSE

## QUENCH_PARAMETERS permits you to alter the basic algorithm to
## perform selective "quenching," i.e., faster temperature cooling than
## permitted by the ASA algorithm.  This can be very useful, e.g., to
## quench the system down to some region of interest, and then to perform
## proper annealing for the rest of the run.
#-DQUENCH_PARAMETERS=FALSE

## If QUENCH_COST is set to TRUE, the scale of the power of the
## temperature schedule used for the acceptance function can be altered in
## a similar fashion to that described above when QUENCH_PARAMETERS is set
## to TRUE.
#-DQUENCH_COST=FALSE

## When QUENCH_PARAMETERS is TRUE, if QUENCH_PARAMETERS_SCALE is TRUE,
## then the temperature scales and the temperature indexes are affected by
## User_Quench_Param_Scale[].  When QUENCH_PARAMETERS is TRUE, if
## QUENCH_PARAMETERS_SCALE is FALSE, only the temperature indexes are
## affected by User_Quench_Param_Scale[].
#-DQUENCH_PARAMETERS_SCALE=TRUE

## When QUENCH_COST is TRUE, if QUENCH_COST_SCALE is TRUE, then the
## temperature scale and the temperature index are affected by
## User_Quench_Cost_Scale[0].  When QUENCH_COST is TRUE, if
## QUENCH_COST_SCALE is FALSE, only the temperature index is affected by
## User_Quench_Cost_Scale[0].
#-DQUENCH_COST_SCALE=TRUE

## To use testing templates in the asa_usr.c and asa.c files, associated
## with several OPTIONS, set ASA_TEMPLATE to TRUE.
#-DASA_TEMPLATE=FALSE

## It can be useful to return additional information to the user
## module from the asa module.  When OPTIONAL_DATA_DBL is set to TRUE, an
## additional pointer, *Asa_Data_Dbl,  is available in DEFINES *OPTIONS to
## gather such data.
#-DOPTIONAL_DATA_DBL=FALSE

## It can be useful to return additional integer information to the
## user module from the asa module.  When OPTIONAL_DATA_INT is set to
## TRUE, an additional pointer, *Asa_Data_Int,  is available in DEFINES
## *OPTIONS to gather such data.
#-DOPTIONAL_DATA_INT=FALSE

## It can be useful to return/pass additional array information to the
## user module from/through the asa module.  When OPTIONAL_DATA_PTR is set
## to TRUE, an additional pointer, *Asa_Data_Ptr, of type
## OPTIONAL_PTR_TYPE is available in DEFINES *OPTIONS to gather such data.
#-DOPTIONAL_DATA_PTR=FALSE

## The function used for the cost_function temperature  schedule is of
## the form test_temperature in asa.c.  You can define your own function
## of test_temperature adaptively in asa_usr.c in user_cost_schedule() (and
## in recur_user_cost_schedule() if SELF_OPTIMIZE is TRUE) by setting
## USER_COST_SCHEDULE to TRUE.
#-DUSER_COST_SCHEDULE=FALSE

## The standard Boltzmann probability distribution is used for the
## acceptance test.  You can adaptively change this using Asymp_Exp_Param
## by setting USER_ACCEPT_ASYMP_EXP to TRUE.
#-DUSER_ACCEPT_ASYMP_EXP=FALSE

## The standard Boltzmann probability distribution is used for the
## acceptance test.  You can change this by setting USER_ACCEPT_THRESHOLD
## to TRUE.
#-DUSER_ACCEPT_THRESHOLD=FALSE

## The standard Boltzmann probability distribution is used for the
## acceptance test.  You can adaptively change this with your own function
## in asa_usr.c in user_acceptance_test() (and in
## recur_user_acceptance_test() if SELF_OPTIMIZE is TRUE) by setting
## USER_ACCEPTANCE_TEST to TRUE.
#-DUSER_ACCEPTANCE_TEST=FALSE

## The ASA generating probability distribution us used to generate new
## states.  You can adaptively change this with your own function in
## asa_usr.c in user_generating_distrib() (and in
## recur_user_generating_distrib() if SELF_OPTIMIZE is TRUE) by setting
## USER_GENERATING_FUNCTION to TRUE.
#-DUSER_GENERATING_FUNCTION=FALSE

## If you wish to adaptively control the algorithm controlling
## reannealing of the cost function, this can be done in asa_usr.c in
## user_reanneal_cost() (and in recur_user_reanneal_cost() if
## SELF_OPTIMIZE is TRUE) by setting USER_REANNEAL_COST to TRUE.
#-DUSER_REANNEAL_COST=FALSE

## The macro used for reannealing parameter temperatures
## #define FUNCTION_REANNEAL_PARAMS(temperature, tangent, max_tangent) \
##  (temperature * (max_tangent / tangent))
## is defined in asa.h.  If you wish to adaptively control this function
## it can be defined in asa_usr.c in user_reanneal_params() (and in
## recur_user_reanneal_params() if SELF_OPTIMIZE is TRUE) by setting
## USER_REANNEAL_PARAMETERS to TRUE.
#-DUSER_REANNEAL_PARAMETERS=FALSE

## MAXIMUM_REANNEAL_INDEX is the maximum index (number of steps) at
## which the initial temperature and the index of the temperature are
## rescaled to avoid losing machine precision.
#-DMAXIMUM_REANNEAL_INDEX=50000

## REANNEAL_SCALE is the reannealing scale used when
## MAXIMUM_REANNEAL_INDEX is exceeded.
#-DREANNEAL_SCALE=10

## When ASA_SAMPLE is set to TRUE, data is collected by asa to
## importance-sample the users' variable space.
#-DASA_SAMPLE=FALSE

## When ADAPTIVE_OPTIONS is set to TRUE, it is possible to change relevant
## OPTIONS in the USER_DEFINES struct in asa_usr_asa.h during run time,
## by including an asa_adaptive_options file.
#-DADAPTIVE_OPTIONS=FALSE

## When ASA_QUEUE is set to TRUE, a FIFO queue saves generated states,
## to avoid extra cost function calculations.
#-DASA_QUEUE=FALSE

## When ASA_RESOLUTION is set to TRUE, Coarse_Resolution[] defines the
## resolution of parameters in the fit.
#-DASA_RESOLUTION=FALSE

## When ASA_FUZZY is set to TRUE, several subroutines become available to
## perform an adaptive tuning of selected ASA OPTIONS.
#-DASA_FUZZY=FALSE

## When ASA_FUZZY_PRINT is set to TRUE, the local fitting routines
## print out from the user module.
#-DASA_FUZZY_PRINT=FALSE

## When FITLOC is set to TRUE, three subroutines become available to
## shunt asa() over to a local simplex optimization.
#-DFITLOC=FALSE

## If FITLOC is set to TRUE and FITLOC_ROUND is TRUE, then each time
## parameters are passed to or between the local routines, they are first
## processed by rounding integers or respecting rounding according to
## ASA_RESOLUTION constraints.
#-DFITLOC_ROUND=TRUE

## When FITLOC is set to TRUE and FITLOC_PRINT is TRUE, the local
## fitting routines print out from the user module.
#-DFITLOC_PRINT=TRUE

## When MULTI_MIN is set to TRUE, the lowest Multi_Number values of the
## cost function and their parameters are saved.
#-DMULTI_MIN=FALSE

## When ASA_PARALLEL is set to TRUE, ASA is run in parallel-processor
## mode.
#-DASA_PARALLEL=FALSE

## When FDLIBM_POW is set to TRUE, a user-defined function s_pow() is
## used instead of pow().  This may be desirable on some machines when a
## speed-up can be realized.
#-DFDLIBM_POW=FALSE

## When FDLIBM_LOG is set to TRUE, a user-defined function s_log() is
## used instead of log().  This may be desirable on some machines when a
## speed-up can be realized.
#-DFDLIBM_LOG=FALSE

## When FDLIBM_EXP is set to TRUE, a user-defined function s_exp() is
## used instead of exp().  This may be desirable on some machines when a
## speed-up can be realized.
#-DFDLIBM_EXP=FALSE

###
###		Printing Options
###
## Setting ASA_PRINT to FALSE will suppress all printing within asa.
#-DASA_PRINT=TRUE

## The name of the output file containing all printing from asa If you
## wish to attach a process number use ASA_OUT=\"asa_out_$$$$\" If
## ASA_OUT=\"STDOUT\" then ASA will print to stdout.
#-DASA_OUT=\"asa_out\"

## The name of the output file containing all printing from asa_usr.c If you
## wish to attach a process number use USER_OUT=\"asa_usr_out_$$$$\" If
## USER_OUT=\"STDOUT\" then asa_usr.c will print to stdout.
#-DUSER_OUT=\"asa_usr_out\"

## Some compilers on some systems under some levels of optimization will not
## compile if stdout is present in the code.  All instances of stdout and
## printf in the user and the asa modules can be commented out by setting
## INCL_STDOUT to FALSE.  Note that this also will suppress some output
## from such OPTIONS as ASA_PIPE, TIME_CALC, etc.
#-DINCL_STDOUT=TRUE

## If your wish to have the printing from asa be sent to a file
## determined dynamically from the user module, set USER_ASA_OUT to
## TRUE, and define the Program Option *Asa_Out_File in the user module.
## (This overrides any ASA_OUT settings.)  In asa_usr.c, if
## USER_OPTIONS->Asa_Out_File = "STDOUT";, then ASA will print to stdout.
#-DUSER_ASA_OUT=FALSE

## If your wish to have the printing from asa_usr be sent to a file
## determined dynamically from the user module, set USER_ASA_USR_OUT to
## TRUE, and define the Program Option *Asa_Usr_Out_File in the user module.
## (This overrides any USER_OUT settings.)
#-DUSER_ASA_USR_OUT=FALSE

## Setting ASA_PRINT_INTERMED to FALSE will suppress intermediate
## printing within asa.
#-DASA_PRINT_INTERMED=TRUE

## Setting ASA_PRINT_MORE to TRUE will print out more intermediate
## information, e.g., new parameters whenever a new minimum is reported.
#-DASA_PRINT_MORE=FALSE

## The field width and precision for doubles is specified as
## G_FIELD.G_PRECISION.
#-DG_FIELD=12
#-DG_PRECISION=7

## When ASA_SAVE is set to TRUE, asa saves enough information after
## each newly best accepted state to restart from that point.
#-DASA_SAVE=FALSE

## If ASA_SAVE is set to TRUE, when ASA_SAVE_BACKUP is set to TRUE,
## asa saves enough information after each newly best accepted state to
## restart from any previous best accepted state when that
## asa_save.{best_state} is copied to asa_save.
#-DASA_SAVE_BACKUP=FALSE

## If ASA_SAVE_OPT is set to TRUE, when asa is restarted, if the file
## asa_opt_save is present in the same directory as asa_opt, then new values
## of ASA parameters and OPTIONS are read in after initializing to the
## point of the last writing of asa_save, without requiring recompilation.
#-DASA_SAVE_OPT=FALSE

## When ASA_PIPE is set to TRUE asa prints to STDOUT lines of
## data that can be used to update databases or charts.
#-DASA_PIPE=FALSE

## When ASA_PIPE_FILE is set to TRUE asa prints to asa_pipe lines of
## data that can be used to examine run data.
#DASA_PIPE_FILE=FALSE

## When SYSTEM_CALL is set to FALSE, asa avoids popen calls, e.g.,
## as in asa.c when ASA_SAVE is set to TRUE, to copy asa_save to
## asa_save.old.  This is useful on machines that do not permit these
## commands.
#-DSYSTEM_CALL=TRUE

###
###		Compiler Choices
###
## If HAVE_ANSI=TRUE use this block; otherwise, use the K&R block below.
## The gnu C compiler is the default.
## The use of -ffloat-store with gcc/g++ is to maintain the same level of
## precision across levels of compiler optimization on different platforms.
#CC = g++
CC = gcc
CDEBUGFLAGS = -g -Wall -ffloat-store # -Wno-unused-but-set-variable # MY_TEMPLATE_flags
##
## If you use your system's ANSI compiler, e.g., named cc, use this block.
## Sun's ANSI compiler is named acc, so use CC = acc for this one.

#CC = acc
#CDEBUGFLAGS = -O

## If HAVE_ANSI=FALSE use this K&R block, or the next block with gcc
#CC = cc
#CDEBUGFLAGS = -O
#
#CC = gcc
#CDEBUGFLAGS = -traditional -g -O -Wall -ffloat-store

## If you wish to include some profile statistics
#CC = gcc -pg
#CDEBUGFLAGS = -g -Wall -ffloat-store

## If using gcc with ASA_PARALLEL and _OPENMP using gcc
#CC = gcc -fopenmp
#CDEBUGFLAGS = -g -Wall -ffloat-store # MY_TEMPLATE_flags

CFLAGS = $(CDEBUGFLAGS) $(DEFINE_OPTIONS)
## Under Cygwin, using ASA_LIB set TRUE and INCL_STDOUT set FALSE,
## use the following to produce a DLL with asa_dll: below
## CC = /bin/i686-pc-mingw32-gcc.exe

LDFLAGS =

all:
	make compile
	make run
#	make profile

###
###		Document Formatting
###
doc:
## Use groff if you have it; add pep or colcrt to delete extra
## formatting.  Under groff, using `more' or `less' presents an enhanced
## text.  The following is used on Cygwin.
## Otherwise, standard UNIX macros are fine.
## The next 2 lines use standard UNIX utilities
#	refer -e -P -n ASA-README.ms | tbl | nroff -ms > ASA-README+.txt
#	refer -e -P -n ASA-README.ms | tbl | nroff -ms | pep > ASA-README.txt
##
## Similarly, you may format your own PostScript ASA-README.ps.
##
	groff -wall -R -t -Tascii -ms ASA-README.ms > ASA-README+.txt
	cat ASA-README+.txt | sed -e "s/\[1m//g" | sed -e "s/\[0m//g" | sed -e "s/\[4m//g" | sed -e "s/\[24m//g" | sed -e "s/\[22m//g" > ASA-README.txt
	groff -wall -R -t -e -ms ASA-README.ms > tp.ASA-README.ps
	psselect -p1,58-,2-56 tp.ASA-README.ps > ASA-README.ps
	rm tp.ASA-README.ps
	ps2pdf ASA-README.ps
	HTML/xread_html
	chmod 644 ASA-README*

###
###		Other Standard Arguments to Make
###
# MY_TEMPLATE_macros
#
## If COST_FILE is set to FALSE, asa_usr_cst.c may be deleted.  If the
## name asa_usr_cst.c is changed, then this might be changed here as well.
USEROBJS = asa_usr.o asa_usr_cst.o # the name of the calling object files
ASAOBJS = asa.o # the ASA optimization object file
ASA_USER_INCL = asa.h asa_usr.h
# MY_TEMPLATE_OBJS =
# MY_TEMPLATE_incl =
# Use this 2-line compile instead of the next one if using MY_TEMPLATE_OBJS
#compile: $(USEROBJS) $(ASAOBJS) $(MY_TEMPLATE_OBJS)
#	@$(CC) $(LDFLAGS) -o asa_run $(USEROBJS) $(ASAOBJS) $(MY_TEMPLATE_OBJS) -lm
compile: $(USEROBJS) $(ASAOBJS)
	@$(CC) $(LDFLAGS) -o asa_run $(USEROBJS) $(ASAOBJS) -lm

$(USEROBJS): asa_usr.h # MY_TEMPLATE_user_incl
$(ASAOBJS): asa.h
$(ASA_USER_INCL): asa_usr_asa.h
# MY_TEMPLATE_depends

profile:
	gprof -z asa_run > asa_profile

## CC and CFLAGS are passed into main, to be recorded in asa_usr_out.
## If "." is not in the path, use "./asa_run" instead of "asa_run" .
## Use a low value of nice for runs that are time- and CPU-intensive.
run:
	asa_run $(CC) $(CFLAGS) # MY_TEMPLATE_run
#	./asa_run $(CC) $(CFLAGS) # MY_TEMPLATE_run
#	nice -19 asa_run $(CC) $(CFLAGS)
#	profile

clean:
	rm -f *\.o asa_run* asadll* # MY_TEMPLATE_clean core gmon.out

realclean:
	rm -f *\.o asa_run* asa_usr_out* asa_out* core asa_save* asa_rcur asa_sfop \
	asa_exit_anytime asa_[A-D]_[a-d] asa_pipe asadll* # MY_TEMPLATE_realclean gmon.out

docclean:
	rm -f ASA-README.txt ASA-README.ps ASA-README.pdf

tgz:
	mkdir ASA ; cp $(MANIFEST) ASA ; tar cBf - ASA | gzip --best > ASA.tar.gz ; rm -rf ASA

## Prepare DOS-zip using UNIX-zip
zip:
	mkdir ASA ; cp $(MANIFEST) ASA ; u2d ASA/*[^f] ; zip -rq9 ASA ASA ; rm -rf ASA

# under Cygwin change CC to
## CC = /bin/i686-pc-mingw32-gcc.exe
dllmodule = asadll
obj_libs = $(MY_TEMPLATE_OBJS) $(USEROBJS) $(ASAOBJS)
dependency_libs =  # -lm is a dummy /usr/lib/mingw/libm.a with Cygwin
#dependency_libs = -lm
# compiling without main(), using ASA_LIB, gives warning to be ignored.
asadll:
	make -i compile
	$(CC) $(CFLAGS) -shared -o ${dllmodule}.dll \
	-Wl,--out-implib=${dllmodule}.lib \
	-Wl,--compat-implib \
	-Wl,--add-stdcall-alias \
	-Wl,--enable-stdcall-fixup \
	-Wl,--enable-auto-import \
	-Wl,--enable-auto-image-base \
	-Wl,--whole-archive ${obj_libs} \
	-Wl,--export-all \
	-Wl,--output-def=${dllmodule}.def \
	-Wl,--no-whole-archive ${dependency_libs}

/***********************************************************************
* Adaptive Simulated Annealing (ASA)
* Lester Ingber <ingber@ingber.com>
* Copyright (c) 1987-2016 Lester Ingber.  All Rights Reserved.
* ASA-LICENSE file has the license that must be included with ASA code.
***********************************************************************/

$Id: ASA-NOTES,v 30.21 2016/02/02 15:49:41 ingber Exp ingber $

========================================================================
			CONTENTS (Search on these words)

NOTE:  I have attempted to specifically date sections where some
updates in other files might give conflicting references.

@@SOME USER FRIENDLY ISSUES
	@@Original ASA Comments
	@@Some Reflections After a Score of Years
@@SOME SA/ASA COMMENTS
	@@General Comments
	@@Parameter-Temperature Scales
	@@Equality and Inequality Constraints
	@@Number of Generated States Required
@@TUNING FOR SOME SYSTEMS
	@@Tuning
	@@Some Tuning Guidelines
	@@Quenching
	@@Options for Large Spaces
	@@Shunting to Local Codes
	@@Judging Importance-Sampling
@@SPECIAL COMPILATIONS/CODE
	@@Tsallis Statistics
	@@Dynamic Hill Climbing (DHC)
	@@FORTRAN Issues
	@@Specific Machines/Architectures

========================================================================
========================================================================
@@SOME USER FRIENDLY ISSUES

========================================================================
	@@Original ASA Comments

I do not give out any info I receive from users unless they
specifically permit me to do so; that way many people do ask questions
and give me info/feedback on the code they might not give otherwise.
In order to get maximum feedback without unduly bothering researchers,
I also have decided not to make the ASA_list an open forum, but rather
an efficient moderated medium to gather information.

While I agree the code should become more user friendly, my first
priority for the time I have is to make the code more powerful.  I
figure that such algorithms are usually most useful only for really
hard problems, and if a group can't enough help from me via e-mail,
well then they might have to consult an expert.  I think the best
answer is to someday get someone to work to produce a graphical user
interface, embedding knowledge gained by helping many people, into some
menu-driven program that can guide a user at various stages of the
search.

In ASA, I have broken out all user OPTIONS into plain view.  Many of
these are counterparts to parameters "hidden" in other codes.  The
downside of having this control is that it can be bewildering at
first.  The upside is that people have been able to solve hard problems
they could not solve any other way.

The easiest way for many users to quickly use ASA likely is to invoke
the COST_FILE OPTIONS (the default), illustrated in the section Use of
COST_FILE on Shubert Problem below.  The ASA-README files give further
instructions on alternative ways of compiling the code.

========================================================================
	@@Some Reflections After a Score of Years

In response to:

Andreas Schuldei 9/25/2006 6:55 AM:
> Hi!
> 
> I used your ASA code about 10-6 years ago with good results and
> want to thank you for providing it.
> 
> however even back then i noticed that it was in urgent need of a
> good refactoration. 
> 
> http://en.wikipedia.org/wiki/Refactor
> 
> I encourage you to go over your code and split it up in more
> readable chunks. todays compilers are pretty good at optimizing
> the result so it will not impact your programs performance.
> 
> In the meantime i also became more involved in free software. I
> think you would get more contributions (e.g. doing this
> refactoration) from other people if you used the GPL as a
> license. 
> 
> Again, thank you very much for your excellt program.
> 
> /andreas

Andreas:

Hi.

I agree about the refactoration, but I don't agree about the GPL license:

When I first wrote the code it was in broken into multiple files which
were easy to take care of.  I made the decision, which feedback has
shown to be a good one, to make the code look less formidable to many
users by aggregating the code into just a few files.   The code is used
widely across many disciplines, but often by expert people or groups
without computer science skills, and often tuning can be accomplished by
tweaking the parameter file and not having to deal with the .c files
very much.

Even if I choose to keep just a few files, I just do not have the time
to rewrite the code into better code similar to how I write code now,
20 years later (I first wrote the VFSR code in 1987).  However, for me
at least, the structure of the code makes it very easy to maintain, and
I been able to be responsive to any major changes that might come up.
The ASA-CHANGES files reflects this.

I have led teams of extremely bright and competent math-physics and
computer-science people in several disciplines over the years, and I
have also seen how code that may be written in exemplary languages,
whether C, Java, C++, python, etc., nonetheless can be rotten to
maintain if it is not written in a "functional" manner that better
reflects the underlying algebra or physical process, e.g., as most
people would program in an algebraic language like Macsyma/Maxima,
Maple, etc.  In many of these projects, we had no problem using ASA.
This does not excuse a lot of the clumsy writing in ASA, but it does
reflect on the difference between code that is just well-written but not
flexible and robust to maintain.

By now, ASA represents a lot of feedback from thousands of users.  A
major strength of the code is that it has well over 100 tuning OPTIONS,
albeit in many case only a few are usually required.  This is the nature
of sampling algorithms, and I have broken out all such code-specific
parameters into a top-level meta-language that is easy for an end-user
to handle.  Other very good sampling algorithms do not give such robust
tuning, and too often do not work on some complex systems for some users
just for this reason.  This also has added a lot of weight to the code,
but since most of these ASA OPTIONS are chosen at pre-compile time, this
does not affect the executables in typical use.  I have had at least
half a dozen exceptional coders start to rewrite the code into another
language, e.g., C++, Java, Matlab, etc., but they gave up when faced
with integrating all the ASA OPTIONS.  (There is no way I could
influence them to start or stop such projects.)  I think all these
OPTIONS are indeed necessary for such a generic code.

Re the GPL license, I instead chose a Berkeley UNIX-type license.  I
felt and still feel, similar to many other people who make code
available at no charge to others, that the GPL license is just too
cumbersome and onerous.  I have made my code available at no charge to
anyone or any company, subject to very simple terms.  If some user
contributions do not quite fit into the code per se, I have put or
referenced their contributions into the asa_contrib.txt or ASA-NOTES
files.  I do not think this has stymied people from contributing to the
code.

I very much appreciate your writing to me.

Lester

========================================================================
========================================================================
@@SOME SA/ASA COMMENTS

========================================================================
	@@General Comments

"Adaptive" in Adaptive Simulated Annealing refers to adaptive options
available to a user to tune the ASA algorithm to optimize the code for
applications to specific systems.  While the default options may
suffice for many applications, this is not intended to imply that the
code will automatically adaptively seek the best tuning options.  (The
SELF_OPTIMIZE OPTIONS theoretically may do well in some cases to
automate this, but it likely is too CPU expensive.)  Rather, the
intention is to recognize that nonlinear systems typically are quite
non-typical, and such tuning is often essential as part of an
interaction between the user and the system as knowledge of the system
is gained by successive stages of applying the algorithm.  The section
Efficiency Versus Necessity in the ASA-README also discusses this.

Simulated annealing (SA) algorithms vary in how fast the temperature
schedule can be implemented to satisfy a (weakly) ergodic search, to
reasonably statistically sample the parameter space.  The Boltzmann SA
algorithm (BA) requires a very slow schedule, so people usually "cheat"
and apply a faster schedule, thereby in practice defining "simulated
quenching" (SQ) rather than SA.  This voids the SA proof, and while it
may work well on some problems, as might some other "greedy"
algorithms, making it a valuable tool on such occasions, it likely
will fail on some other problems that would yield to the proven
temperature schedule.

There are SA algorithms that are proven to statistically sample the
space effectively that are exponentially (fast SA, FSA) and also
exponentially exponentially (adaptive SA, ASA) faster than the standard
BA algorithm.  This usually implies that the rejection rate is higher
to accept new points, but in practice this rate increases only modestly
across problems relative to BA, thus truly taking advantage of the
faster sampling temperature.  Of course, SQ can also be applied to
these SA algorithms, and such accelerations can be useful in large
dimensional spaces.

I think the bottom line is this:  If you don't know anything about your
system, and it is very important to find the global optimal point, then
using SA at least gives you some statistical guarantee that you will
not get stuck at a local optimal point.  This also requires some common
sense.  If you start out a very low temperature, or some equivalent set
of such algorithm parameters, you may make it impractical to get a fit
within any practical time or within practical machine precision.  Thus,
even here, there still may be some "art" required to find a decent set
of starting conditions.  I think this is the nature of nonlinear
systems, that they are often so different, that defies using algorithms
as "black boxes" as can be done for (quasi-)linear systems.

ASA can often do very well in the beginning stages of broad search, as
well as in the end stages of sharpening the precision of the final
answer.  A good way to see this is to plot the log of the number of
generated points versus the log of the value of the cost function or
"cost procedure."  However, some problems do not show such a clean
division, and then ASA can be even more important.

A good way of including constraints is to test them in your cost
function and return a non-valid flag as soon as any are not satisfied.
Then the penalty part of your cost function is not exactly part of the
cost function being minimized.  This often is more efficient than
including penalty functions explicitly as part of the cost function,
which works well with ASA.

Concerning reannealing in ASA, if too radical a reannealing procedure
is taken, i.e., much more radical than the linear rescaling in the
present code, then this can be self-defeating.  For example, consider
how difficult/impossible it might be to say that a given dimension is
the most sensitive one early in a search, when it might turn out to be
the least sensitive one in the end stages of the search.  So, some
compromise seems to be to take a regularly selected moderate approach,
and I chose the acceptance criteria (every set number of accepted
points) to be better at gauging the changing sensitivity of the search
than the generating criteria (number of generated points).

The parameter temperatures determine the "effective" width of the ASA
distribution to select new generated points about the current optimal
point.  When used in conjunction with the proper annealing schedule,
this ensures a statistical covering of the parameter space, as given by
the simple proof in the ASA papers.  (See the section Judging
Importance-Sampling below for more info.)

Most discussions on SA focus on the cost temperature, and the analogy
to metallic cooling/annealing.  They do not properly address the issue
of the annealing schedule, and the necessity of satisfying the guide to
statistical ergodicity.  If they neglect this, then their resulting
algorithm is really "just" another quasi-local algorithm, which belongs
in the class I call "simulated quenching" (SQ), without establishing
any statistical certainty of being able to find the global optimal
point.  That said, SQ techniques still can be very useful and
powerful.

In ASA, one of the most useful control for some people has been
USER_COST_SCHEDULE, which permits just about anything for the cost
temp.  This is possible since the ASA proof of proper sampling just
concerns the parameter temperatures (within reason, as discussed in the
docs and as is sometimes obvious--if you start too focussed, it may
take until your next generation to sample the space, etc.)

You can use an alternative to the Boltzmann using
USER_ACCEPTANCE_TEST.  This can be useful in cases where the form of
your cost function varies with scale, e.g., changing from a power at
coarse scales to an exponential at finer scales.  In the
ASA_TEMPLATE_SAMPLE template in asa_usr.c there is an example of a class
of such modifications.  Note that when USER_ACCEPTANCE_TEST is TRUE,
you also have the option of calculating the acceptance criteria within
the user_cost_function().  This can be very useful when a partial
calculation of the cost function suffices to apply an acceptance
criteria.

You can define an alternative to the ASA generating function (or
whatever algorithm is required) using USER_GENERATING_FUNCTION.  For
example, mild modifications to the ASA distribution can be useful,
e.g., slowing down the annealing schedule by taking a fractional root
of the current temperature.

In the current implementation, only one current optimal point is kept
at a time.  I do not see the utility of keeping more than one optimal
point at a time.  For example, some people have asked if starting with
several random seeds would help the efficiency of the code.  I do not
think so:  The fat tail of the ASA distribution results in a fairly
high generated to accepted ratio, and in practice this accounts for a
fairly robust sampling.  However, their is much merit in considering
calculating blocks of generating points.  As I mention in
asa92_mnn.pdf, this can be extremely helpful in a parallelized
version.  There are ASA_PARALLEL hooks in the present code to do this,
as explained in the ASA-README.

I do not think some comments about SA theory not having any practical
value, given finite machine precision, a popular argument to be sure,
is too relevant.  Most complex systems exist at multiple scales; in
fact, for most physical systems, the very concept of "noise" is really
the the introduction of new variables (e.g., in an appropriate Ito or
Stratonovich representations, etc.) to represent some statistical
aggregation over "fast" variables.  In this context, sampling a cost
function/system should be understood by the researcher as typically
being appropriate to some scale(s).  For many systems, machine
precision suffices at the appropriate scale(s) to effectively sample
the parameter space, and here I think it relevant that SA techniques
can offer a better guide (_especially_ in the absence of other info
about the system, e.g., the existence of convexity, etc.) to
effectively sample the space (if indeed that is required) than other
algorithms.

========================================================================
	@@Parameter-Temperature Scales

If indeed you need to have many generated states, then increasing
OPTIONS->Temperature_Ratio_Scale (by way of lowering the argument of
the power of 10) is a good idea, as this lowers
        m = -log(OPTIONS->Temperature_Ratio_Scale)
which lowers
        c_i = m_i exp(-n_i/D)
which permits slower annealing via
        T_i(k_i) = T_0i exp(-c_i k_i^(1/D))
so that you still might have some moderate (not too small) temperatures
out at high numbers of generated states.  If
RATIO_TEMPERATURE_SCALES is set to TRUE, then
	m_i = m OPTIONS->User_Temperature_Ratio[i].
Also note that
	n_i = log(OPTIONS->Temperature_Anneal_Scale)
and it is not really necessary to have an OPTIONS to set these
independently as one can always use m_i for this purpose.

Of course, both m_i and n could have been aggregated into one OPTIONS
c_i.  However, as explained in the first VFSR paper and as outlined in
the ASA-README, there is a good rationale for keeping m_i and n, with their
different effects on c_i, as they usefully model the approximate
"expected" ratio of final to initial temperatures and the associated
numbers of generated states amassed during annealing, respectively.

========================================================================
	@@Equality and Inequality Constraints

15 Jan 15

Hime Aguiar and his colleagues, who have contributed ASA_FUZZY to ASA,
have developed an procedure to develop existence criteria for when an
N-dimensional space constrained search with p equality constraints
can be developed into an effective N-p dimensional search, when the
feasible domain can be modelled by a smooth submanifold defined by
equality constraints expressions.  In some cases the existence proof
presents numerical procedures for solution of the N-p dimensional space.
See the paper cited in http://ingber.com/asa_papers.html that references
http://dx.doi.org/10.1016/j.ins.2014.12.032 .

25 Jul 11

The method of Lagrange multipliers might help to add equality and inequality
constraints to a cost function C(x,p), where x is a vector of variables
and p is a vector of parameters; the p's are varied by ASA to achieve
optimization of C(x,p).

For example consider constraints on C(x,p)
H(x) = 0
G(x) < 0
which are fairly generic as manytimes equalities and inequalities can be
put into such forms.

The approach is to then use ASA to optimize a new cost function K(x,q)
K(x,q) = C(x,p) + q_e | H(x) | + q_i Min[0,G(x)] 
where q is an extended vector of ASA parameters
q = {p, q_e, q_i}
q_e > 0
q_i > 0
and | H | represents the absolute value of H.

Be sure to check the final values of the optimized parameters.  If it
makes sense for your problem, keep the ASA default to calculate tangents
at the exit, to check that the final values of derivatives of K with
respect to q are relatively quite small, signifying extremal points are
reached.  Also, if it makes sense for your problem, keep the ASA default
to calculate curvatures at the exit, to check that the final values of
second derivatives of K with respect to q are are positive, or at least
relatively quite small, signifying stable minima points are reached.

You may have to adjust the range of {q_e, q_i} to achieve reasonable fits.
It should be clear that very large values or very small values of the
Lagrange multipliers will skew the problem to optimizing only part of
the function K(p,q).  There are several published algorithms using
modified simulated annealing to (quasi-)automate such optimizations
with constraints.

13 Dec 94

If you have equality constraints that can only be enforced as actual
equations in the code (e.g., you can't numerically use them to
substitute in other expressions), you will have problems.  This is
simply because you are constraining the search on the surface of some
volume, and the entire volume is being sampled.  This will be the case
when using any true sampling algorithm.

For example, if you have a cost function with n parameters,
C(p_1, p_2, ..., p_n),  and an equality constraint between parameters
p_n and p_n-1, then solve this equation for p_n, numerically or
algebraically, redefining your cost function to one with n-1
parameters, C'.  If the solution to this equation, or perhaps a set of
m such equality constraints to reduce the number of parameters actually
processed by ASA to n-m, is not simply written down, then you will of
course have to solve such constraints with other algorithms within your
cost function.  If the solution of these equality constraints are so
difficult that by themselves they cannot be approached with
quasi-Newton algorithms, then you could use the recursive properties of
ASA to solve these equations, appropriately defined by another cost
function within your original cost function.

However, if there are branches of multiple solutions of these equality
constraints, then you could use these as a discrete or continuous set
of parameter values within your cost function, instead of reducing the
parameter dimension processed by ASA, e.g., perhaps using
OPTIONS->Sequential_Parameters to delay generating a choice among the
roots of the equality constraints until the other independent
parameters are given new generated values; see the ASA-README for the use
of parameter_minimum[] and parameter_maximum[] which may be required
for such cases.

========================================================================
	@@Number of Generated States Required

The question often arises as to how to guess the required time required
to get the global minimum, which likely is best measured by the
required number of generated states.  While there are quite a few
papers published on this important topic, in general it is quite
difficult to give a categorical answer, basically because (a) nonlinear
systems typically are quite different, (b) many nonlinear systems have
different "terrain" at different scales -- essentially being different
systems at these different scales, and (c) results can be very
dependent on the global optimization algorithm used.

Of course, if ASA already has given you an optimal state, this can be
considered a tentative bound, and then you can explore possibilities to
get this same optimal state with fewer generated states, e.g., using
SELF_OPTIMIZE if you do not enough information about your system to
make some educate guesses for further tuning of the OPTIONS.

Otherwise, you can use plots of generated states versus current the
best cost_function value mentioned above in General Comments, to
extrapolate the number of generated states required to achieve future
values of the cost_function.  Since experience has shown that many
systems exhibit at least three different regions with quite different
shapes -- (1) a quasi-linear region during the initial broad search,
(2) a quasi-linear region during the final search, and (3) a quite
nonlinear region between (1) and (2) -- you would have to be fairly
certain that you are in region (2) in order to consider any such
extrapolation even a crude guess to the number of required generated
states.  Furthermore, you can perform such plots with several values of
selected OPTIONS, to help extrapolate the required number of generated
states as a function of these OPTIONS.

Note that some of my previous ASA publications illustrate comparisons
of such log-log plots with other global optimization algorithms.  Even
the general shape, not just the end result, of the plots can differ
depending on the algorithm used.  This is further evidence that using
general theoretical guides, as mentioned in (c) above, can be quite
misleading.

========================================================================
========================================================================
@@TUNING FOR SOME SYSTEMS

========================================================================
	@@Tuning

Nonlinear systems are typically not typical, and so it is difficult if
not impossible to give guidelines for ASA defaults similar to what you
might expect for "canned" quasi-linear systems.  I have tried to
prepare the ASA-README to give some guidelines, and if all else fails you
could experiment a bit using a logical approach with the SELF_OPTIMIZE
OPTIONS.  I still advise some experimentation that might yield a bit of
insight about a particular system.  In many case, the best approach is
probably a "blend":  Make a guess or two, then  fine-tune the guesses
with SELF_OPTIMIZE in some rather finer range of the parameter(s).  The
reason this is slow is because ASA does what you expect it to do:  It
truly samples the space.  When SELF_OPTIMIZE is turned on, for each
call of the top-level ASA parameters selected, the "inner" shell of
your system's parameters are optimized, and this is performed for an
optimization of the "outer" top-level shell of ASA parameters.  If you
find that indeed this is a necessary and valuable approach to your
problem, then one possible short cut might be to turn on Quenching for
the outer shell.

The ASA proof of statistical convergence to a global optimal point
gives sufficient, _not_ necessary, conditions.  This still is a pretty
strong statement since one can only importance-sample a large space in
a finite time.  Note that some spaces would easily require CPU times
much greater than the lifetime of the universe to sample all points.
If you "tucked away" a "pathological" singular optimal point in an
otherwise "smooth" space, indeed ASA might have to run "forever."  If
the problem isn't quite so pathological, you might have to slow down
the annealing, to permit ASA to spend more time at each scale to
investigate the finer scales; then, you would have to explore some
other OPTIONS.  This could be required if your problem looks different
at different scales, for then you can often get trapped in local
optima, and thus ASA could fail just as any other "greedy" quasi-Newton
algorithm.

Because of its exponential annealing schedule, ASA does converge at the
end stages of runs quite well, so if you start with your setup akin to
this stage, you will search for a very long time (possibly beyond your
machine's precision to generate temperatures) to get out.  Or, if you
start with too broad a search, you will spin your wheels at first
before settling down to explore multiple local optima.

ASA has demonstrated many times that it is more efficient and gets the
global point better than other importance-sampling techniques, but this
still can require "tuning" some ASA OPTIONS.  E.g., as mentioned in the
ASA-README, a quasi-Newton algorithm should be much more efficient than ASA
for a parabolic system.

========================================================================
	@@Some Tuning Guidelines

21 Jan 00

Here are some crude guidelines that typically have been useful to tune
many systems.  At least ASA has a formal proof of convergence to the
global minimum of your system.  However, no sampling proof is general
enough for all systems to guarantee this will take place within your
lifetime.  This is where the true power of ASA comes into play as the
code provides many tuning OPTIONS, most that can be applied adaptively
at any time in the run, to give you tools to tune your system to provide
reasonably efficient optimizations.  Depending on your system, this may
be easy or hard, possibly taxing anyone's intuitive and analytic capabilities.

In general, respect the optimization process as a simulation in
parameter space.  The behavior of a system in this space typically is
quite different from the system defined by other variables in the system.

(a) Three Stages of Optimization
It is useful to think of the optimization process as having three main
stages: initial, middle and end.  In the initial stage you want to be sure
that ASA is jumping around a lot, visiting all regions of the parameter
space within the bounds you have set.  In the end stage you want to be
sure that the cost function is in the region of the global minimum, and
that the cost function as well as the parameter values are being honed to
as many significant figures as required.  The middle stage typically can
require the most tuning, to be sure it smoothly takes the optimization
from the initial to the end stage, permitting plenty of excursions to
regularly sample alternative regions/scales of the parameter space.

(b) Tuning Information
Keep ASA_PRINT_MORE set to TRUE during the tuning process to gather
information in asa_out whenever a new accepted state is encountered.

If you have ASA_PIPE and/or ASA_PIPE_FILE set to TRUE, additional
information (in relatively larger files) is gathered especially for
purposes of graphing key information during the run.  Graphical aids
can be indispensable for gaining some intuition about your system.

If ASA_SAVE_OPT is set to TRUE then you have the ability to restart runs
from intermediate accepted states, without having to reproduce a lot of
the original run each time you wish to adaptively change some OPTIONS
after a given number of accepted or generated states.

(c) Parameter Temperatures
As discussed above in the section Parameter-Temperature Scales,
the temperature schedule is determined by {T_0i, c_i, k_i, Q_i, D}.
The default is to have all these the same for each parameter temperature.
See below for a discussion on sensitivities with respect to dimension D.

Note that the sensitivity of the default parameter distributions to
the parameter temperatures is logarithmic.  Therefore, middle stage
temperatures of 10^-6 or 10^-7 still permit very large excursions from the
last local minima to visit new generated states.  Typically (of course
depending on your system), values of 10^-10 are appropriate for the end
stage of optimization.

It is advisable to start by changing the c_i to get a reasonable
temperature schedule throughout the run.  If it becomes difficult to
do this across the 3 stages, work with the Q_i QUENCH_PARAMETERS as
these provide different sensitivities at different stages.  Generally,
it is convenient to use the c_i to tune the middle stage, then add in
Q_i modifications for the end stage.  As long as the sum Q_i <= 1, then
the sampling proof is intact.  However, once you are sure of the region
of the global minima, it can be convenient to turn on actual quenching
wherein sum Q_i > 1.

Turning on Reanneal_Parameters can be very useful for some systems to
adaptively adjust the temperatures to different scales of the system.

(d) Cost Temperature
Note that the sensitivity of the default cost distribution to the cost
temperatures is exponential.

In general, you would like to see the cost temperatures throughout
the run be on the scale of the difference between the best and last
generated states, where the last generated state in the run is at the
last local minima from which new states are explored.  Therefore, pay
careful attention to these values.  Note that the last generated state
is set to the most recently accepted state, and if the recently accepted
state also is the current best state then the last generated state will
be so reported.  Therefore, this sensitivity to the last generated state
works best during parts of the run where the code is sampling alternate
multiple minima.

The default is to baseline the cost temperature scale to the default
parameter temperature scale, using Cost_Parameter_Scale_Ratio (default
= 1).  It is advisable to first tune your parameter temperature schedule
using Temperature_Ratio_Scale, then to tune your cost temperature schedule
using Cost_Parameter_Scale_Ratio.  If it becomes difficult to do this across
the 3 stages, work with the Q QUENCH_COST as this provides a different
sensitivity at a different stage.  Generally, it is convenient to use
the c scale via Cost_Parameter_Scale_Ratio to tune the middle stage,
then add in Q modifications for the end stage.

Turning on Reanneal_Cost can be very useful for some systems to adaptively
adjust the temperature to different scales of the system.

(e) Large Parameter Dimensions
As the number of parameter dimensions D increases, you may see that your
temperatures are changing more than you would like with respect to D.
The default is to keep the parameter exponents of the k_i summed to 1
with each exponent set to 1/D.

The effective scale of the default exponential decay of the temperatures
is proportional to c k^(-Q/D), so smaller D gives smaller decay rates
for the same values of c, k and Q.  Modifications to this behavior of
the parameter and cost temperatures are easily made by altering the Q_i
and Q, resp., as Q_i, Q and D enter the code as Q_i/D and Q/D, resp.

The scales c are set as
   c = -log(Temperature_Ratio_Scale) exp[-log(Temperature_Anneal_Scale) Q/D]
Therefore, the sensitivity of c to D can be controlled by modifying
Temperature_Anneal_Scale or Q.

========================================================================
	@@Quenching

If you have a large parameter space, and if a "smart" quasi-local
optimization code won't work for you, then _any_ true global
optimization code will be faced with the "curse of dimensionality."
I.e., global optimization algorithms must sample the entire space, and
even an efficient code like ASA must do this.  As mentioned in the
ASA-README, there are some features to explore that might work for your
system.

Simulated "quenching" (SQ) techniques like genetic algorithms (GA)
obviously are important and are crucial to solving many systems in time
periods much shorter than might be obtained by standard SA.  In ASA, if
annealing is forsaken, and Quenching turned on, voiding the proof of
sampling, remarkable increases of speed can be obtained, apparently
sometimes even greater than other "greedy" algorithms.

In large D space, this can be especially useful if the parameters are
relatively independent of each other, by noting that the arguments
of the exponential temperature schedules are proportional to k^(Q/D).
Then, you might do better thinking of changing Q/D in fractional moves,
instead of only small deviations of Q from 1.

For example, in asa92_saga.pdf in the archive, along with 5 GA test
problems from the UCSD GA archive, another harder problem (the ASA_TEST
problem that comes with the ASA code) was used.  In asa93_sapvt.pdf in
this archive, Quenching was applied to this harder problem.  The resulting
SQ code was shown to speed up the search by as much as as factor of 86
(without even attempting to see if this could be increased further
with more extreme quenching).  In the asa_examples.txt file, even
more dramatic efficiencies were obtained.  This is a simple change of
one number in the code, turning it into a variant of SQ, and is not
equivalent to "tuning" any of the other many ASA options, e.g., like
SELF_OPTIMIZE, USER_COST_SCHEDULE, etc.  Note that SQ will not suffice
for all systems; several users of ASA reported that Quenching did not
find the global optimal point that was otherwise be found using the
"correct" SA algorithm.

As mentioned in the ASA-README, note that you also can use the Quenching
OPTIONS quite differently, to slow down the annealing process by
setting USER_OPTIONS->User_Quench_Param_Scale[] to values less than 1.
This can be useful in problems where the global optimal point is at a
quite different scale from other local optima, masking its presence.
This likely might be most useful for low dimensional problems where the
CPU time incurred by slower annealing might not be a major
consideration.

Once you decide you can quench, there are many more alternative
algorithms you might wish to choose for your system, e.g., creating a
hybrid global-local adaptive quenching search algorithm, e.g., using
USER_REANNEAL_PARAMETERS.  Note that just using the quenching OPTIONS
provided with ASA can be quite powerful, as demonstrated in the
asa_examples.txt file.

========================================================================
	@@Options for Large Spaces

5 Oct 94

For very large parameter-space dimensions, the following guide is
useful if you desire to speed up the search:

		Pre-Compile Options
add -DUSER_REANNEAL_PARAMETERS=TRUE to DEFINE_OPTIONS
add -DUSER_COST_SCHEDULE=TRUE to DEFINE_OPTIONS
add -DASA_PRINT_INTERMED=FALSE to DEFINE_OPTIONS
SMALL_FLOAT may have to be decreased
set QUENCH_PARAMETERS to TRUE [a risk that negates proper sampling if Q > 1]
set QUENCH_COST to TRUE
Perhaps set QUENCH_PARAMETERS_SCALE and QUENCH_COST_SCALE to FALSE

		Program Options
set Curvature_0 to TRUE
increase Temperature_Ratio_Scale (smaller negative exponent)
increase Cost_Parameter_Scale_Ratio
increase Maximum_Cost_Repeat
decrease Acceptance_Frequency_Modulus
decrease Generated_Frequency_Modulus

		run time
use `nice -19 asa_run ...` as runs can be time- and CPU-intensive

If the parameter space dimension, D, is huge, e.g., 256x256=65536,
then the exponential of the generating or acceptance index to the 1/D
power hardly changes over even a few million cycles.  True annealing in
such huge spaces can become prohibitively slow as the temperatures will
hardly be diminished over these cycles.  This "curse of dimensionality"
will face any algorithm seeking to explore an unknown space.  Then,
the QUENCH_PARAMETERS and QUENCH_COST DEFINE_OPTIONS should be tried.

However, note that slowing down annealing sometimes can speed up the
search by avoiding spending too much time in some local optimal
regions.
========================================================================
	@@Shunting to Local Codes

I have always maintained in e-mails and in VFSR/ASA publications since
1987, that SA techniques are best suited for approaching complex
systems for which little or no information is available.  When the
range of a global optima is discovered, indeed it may be best to then
turn to another algorithm.  I have done this myself in several papers,
shunting over to a quasi-local search, the
Broyden-Fletcher-Goldfarb-Shanno (BFGS) algorithm, to "polish" off the
last 2 or 3 decimals of precision, after I had determined just what
final level of precision was acceptable.  In the problems where I
shunted to BFGS, I simply used something the value of Cost_Precision or
Limit_Acceptances (which were pretty well correlated in some problems)
to decide when to shunt over.  (I got terrible results if I shunted
over too quickly.)  However, that was before the days I added OPTIONS
like USER_COST_SCHEDULE and USER_ACCEPTANCE_TEST, and if and when I
redo some of those calcs I will first experiment adaptively using these
to account for different behaviors of my systems at different scales.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
29 Nov 97

When FITLOC is set to TRUE, three subroutines become active to perform
a local fit after leaving asa ().

========================================================================
	@@Judging Importance-Sampling

22 Nov 96

If the cost function is plotted simply as a function of decreasing
temperature(s), often the parameter space does appear to be continually
sampled in such a plot, but the plot is misleading.  That is, there
really is importance sampling taking place, and the proof of this is to
do a log-log plot of the cost function versus the number of generated
states.  Then you can see that if the temperature schedule is not
enforced you will have a poor search, if quenching is turned on you
will get a faster search (though you may miss the global minimum),
etc.  You can test these effects using quenching and "reverse
quenching" (slowing down the annealing); it likely would be helpful to
set QUENCH_COST and QUENCH_PARAMETERS to TRUE, QUENCH_PARAMETERS_SCALE
and QUENCH_COST_SCALE to FALSE, and perhaps NO_PARAM_TEMP_TEST and
NO_COST_TEMP_TEST to TRUE.

The point is that the ASA distribution is very fat-tailed, and the
"effective" widths of the parameters being searched change very slowly with
decreasing parameter temperatures; the trade-off is that the parameter
temperatures may decrease exponentially and still obey the sampling
proof.  Thus, the experience is that ASA finds global minimum when
other sampling techniques fail, and it typically finds the global
minimum faster than other sampling techniques as well.

Furthermore, the independence of cost and parameter temperatures
permits additional tuning of ASA in many difficult problems.  While the
decreasing parameter temperatures change the way the parameter states
are generated, the decreasing cost temperature changes the way the
generated states are accepted.  The sensitivity to the acceptance
criteria to the cost temperature schedule can be very important in many
systems.  An examination of a few runs using ASA_PRINT_MORE set to TRUE
can reveal premature holding onto local minimum or not enough holding
time, etc., requiring tuning of some ASA OPTIONS.
========================================================================
========================================================================
@@SPECIAL COMPILATIONS/CODE

========================================================================
	@@Tsallis Statistics

26 Feb 95

A recent paper claimed that a statistics whose parameterization permits
an asymptotic approximation to the exponential function used for the
Boltzmann of the standard SA acceptance test, Tsallis statistics, is
superior to the Boltzmann test, and an example was given comparing
standard SA to this new algorithm in the traveling salesman problem
(TSP).
	%A T.J.P. Penna
	%T Traveling salesman problem and Tsallis statistics
	%J Phys. Rev. E
	%V 50
	%N 6
	%P R1-R3
	%D 1994
There are two issues here, (a) the value of the Tsallis test vs the
Boltzmann test, and (b) the use of TSP for the confirmation of (a).

It seems very reasonable that the Tsallis test should be better than
the Boltzmann test for the SA acceptance test.  For example, if the
Boltzmann statistics did well on a given cost function $C$, then it
might be the case that for the cost function $C prime = exp ( C )$ a
more moderate test, such as obtained for some parameterizations of the
Tsallis statistics, would be more appropriate to avoid getting stuck in
local minima of $C prime$.  In fact, from its first inception VFSR and
ASA have included parameters to effect similar alternatives, and the
latest versions of ASA now have the Tsallis statistics as another
alternative that can be commented out.  I have not yet experienced any
advantages of this over the Boltzmann test when other ASA alternatives
are permitted to be used, but it seems likely that there do exist some
problems that might benefit by its use.

The use of TSP as a test for comparisons among SA techniques seems
quite inappropriate.  To quote another source,
	%A D.H. Wolpert
	%A W.G. Macready
	%T No free lunch theorems for search
	%R Report
	%I Santa Fe Institute
	%C Santa Fe, NM
	%D 1995
\*QAs an example of this, it is well known that generic methods (like
simulated annealing and genetic algorithms) are unable to compete with
carefully hand-crafted solutions for specific search problems.  The
Traveling Salesman (TSP) Problem is an excellent example of such a
situation; the best search algorithms for the TSP problem are
hand-tailored for it.\*U

========================================================================
	@@Dynamic Hill Climbing (DHC)

26 Feb 95

Michael de la Maza posted notices to public electronic bulletin boards,
e.g., as summarized in a public mailing list GA-List@AIC.NRL.NAVY.MIL,
that his new algorithm, dynamic hill climbing (DHC), clearly
outperformed genetic algorithms and ASA.  His code is available by
sending e-mail to dhc@ai.mit.edu.  Since DHC is a variant of a "greedy"
algorithm, it seemed appropriate to permit ASA to also enter its
quenching (SQ) domain.  The following excerpt is the reply posting in
the above bulletin board, also included above in the Quenching section.

\*QSQ techniques like GA obviously are important and are crucial to
solving many systems in time periods much shorter than might be
obtained by SA.  In ASA, if annealing is forsaken, and Quenching turned
on, voiding the proof of sampling, remarkable increases of speed can be
obtained, apparently sometimes even greater than other "greedy"
algorithms.  For example, in asa92_saga.pdf, along with 5 GA test
problems from the UCSD GA archive, another harder problem (the ASA_TEST
problem that comes with the ASA code) was used.  In asa93_sapvt.pdf,
Quenching was applied to this harder problem.  The resulting SQ code
was shown to speed up the search by as much as as factor of 86 (without
even attempting to see if this could be increased further with more
extreme quenching).  This is greater than the factor of 30 that was
reported to me by Michael de la Maza for Dynamic Hill Climbing (DHC).
This is a simple change of one number in the code, turning it into a
variant of SQ, and is not equivalent to "tuning" any of the other many
ASA options, e.g., like SELF_OPTIMIZE, USER_COST_SCHEDULE, etc.  Note
that SQ will not suffice for all systems; several users of ASA reported
that Quenching did not find the global optimal point that was otherwise
be found using the "correct" ASA algorithm.\*U

========================================================================
	@@FORTRAN Issues

20 Oct 06

Two very useful URLs for combining C/C++ and Fortran are:
http://yolinux.com/TUTORIALS/LinuxTutorialMixingFortranAndC.html
http://arnholm.org/software/cppf77/cppf77.htm

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
29 Jul 00

I've included my old 1987 RATFOR VFSR code in asa_contrib.txt.
This code is unsupported.

20 May 93

Some users have requested a FORTRAN version of ASA.  I wrote early
versions of VFSR in RATFOR and used ratfor to translate to FORTRAN,
but picked C for my own convenience for these later versions.

There are at least three reasonable options for people using FORTRAN:

(1) If the FORTRAN code you use is relatively small compared to
the ASA code, you might try f2c to change your FORTRAN source
into C.  This code can be gotten from Netlib, by logging into
netlib@research.att.com as netlib and then cd f2c.

(2) You can use CFORTRAN, available via anonymous ftp from
zebra.desy.de to interface your FORTRAN and C source and/or binary
codes.  It seems the easiest way to use this would be to call a FORTRAN
cost function from within the ASA C cost_function().

(3) You can see if your compiler will accept a rather simple approach
to calling your FORTRAN fcost() from the ASA C cost_function(), just
passing only those variables to fcost() necessary for your
calculation.  The procedure below worked on a Sun SPARC-2/4.1.3 using
gcc and Sun's f77.

(a) In the asa_usr.c file, at the location described in the ASA-README, or in
your asa_usr_cst.c file if you are using COST_FILE set to TRUE, insert your
own cost function:
_______________________________________________________________________
{
#if HAVE_ANSI
  extern void fcost_ (double *q, double *x);    /* note "_" on fcost_ */
#else
  extern void fcost_ ();
#endif
  double q;                     /* returned by fcost_() */
  fcost_ (&q, x);
  *cost_flag = TRUE;            /* or, add some feedback from fcost_() */
  return (q);
}
________________________________________________________________________
The requirement to use an "_" on the C-function call is machine
dependent.

(b) Create a file, e.g., cost.f, containing your FORTRAN cost
function, e.g., if the *parameter_dimension is 4, then:
________________________________________________________________________
      subroutine fcost (q_n, x)
      double precision q_n, x(4)
      ...
      q_n = ...
      end
________________________________________________________________________
Note that element x[0] in C is mapped to x(1) in FORTRAN.

(c) In the Makefile add to the "compile: " (tabbed) commands:
________________________________________________________________________
compile: $(USEROBJS) $(ASAOBJS)
        f77 -c cost.f -lm
        @$(CC) $(LDFLAGS) -o asa_run $(USEROBJS) $(ASAOBJS) cost.o -lm
________________________________________________________________________
Some compilers may require the addition of additional libraries and
options, e.g., -f77 on the CC line.  In general, it seems that the
proper compiler to link all the object files, e.g., cc or f77, should
correspond to the language of main().  If your main() is in FORTRAN,
then use ASA_LIB set to TRUE to use asa_main() in the ASA modules.

========================================================================
	@@Specific Machines/Architectures

5 Aug 97

Under Watcom version 11 exception fault errors are reported.  When
CHECK_EXPONENT is set to TRUE, these do not appear; apparently, there
are problems with handling too large and/or too small exponentials.
See the ASA-README for a discussion on the use of this Pre-Compile
OPTIONS.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
19 Aug 93

On a PC, under MicroSoft Visual C++ 2.0, asa_opt likely should be
placed with the *.c source code, _not_ the executables if they are in a
different directory.

On a Mac, under Code Warrior 6.0, asa_opt likely should be placed with
the executables, _not_  the *.c source code if they are in a different
directory.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Intel Paragon

17 Dec 93
On an Intel Paragon Supercomputer, Graham Campbell
<campbell@ams.sunysb.edu> reported that the ASA test problem runs
without error or warning using gcc-2.4.5 as gcc -g -Wall.  However,
when using cc -O or gcc -g -O, compilation fails.

22 Mar 95
On an Intel Paragon Supercomputer, Shinichi Sakata
<ssakata@weber.ucsd.edu> reported that ASA crashed using the native cc
compiler when entering reanneal(), at the same location as reported by
Graham Campbell.

The location of the problem seems to be within the compiled pow()
function.  I put together an s_pow() function by modifying some public
domain source code from Sun available in the fdlibm directory in
NETLIB.  s_pow() is used instead of pow() when FDLIBM_POW is set to
TRUE.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
29 Mar 93

A problem in compilation,
} Though I compiled successfully
}
} on an old SUN 4/260 and a new IBM risc 6000 using both ansi c and
}
} old version c, troubles comes in when I try it on a newly obtained
}
} HWSs310 sparc workstation (claimed to be equivalent to sparc 10).
}
} When using cc compiler, both asa_usr.c and asa.c have been compiled,
}
} and it gave error message:
}
} undefined symbol  -dlopen
}                   _dlclose
}                   _dlsym
}
was solved by Walter Roberson <roberson@hamer.ibd.nrc.ca> by linking
with -ldl.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
15 Jan 93

Davyd Norris <daffy@sci.monash.edu.au> reports that compilation
was successful on a Pyramid:
"On Pyramid OSx the -Xa compiler option had to be added so that the
compiler knows to expect ANSI code.  Also on our system there is no
stdlib.h include file."

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
PC Code For Time Modules

4 May 94

From selveria@salem.sylvania.com Wed May  4 11:19:58 1994
From: "Selverian, John" <selveria@salem.sylvania.com>
To: "Ingber, Lester" <ingber@alumni.caltech.edu>
Subject: time calculation
Date: Wed, 04 May 94 14:19:00 PDT

Lester,

I move my code (along with ASA) back and forth between a PC & a UNIX
machine.  The time commands work fine on the UNIX machine but not on
the PC.  I currently use the ansi <time.h> header file and the
following command to get the time

#include <time.h>
...
main()
{
      double  start_time,end_time,elapsed_time;
      time_t    tloc;
...
      start_time = (double)time(&tloc);     /* define starting time */
      asa_main(....);                       /* call ASA */
      end_time = (double)time(&tloc);       /* define ending time */
      elapsed_time = end_time - start_time; /* define time spend in ASA */
...
}

This works on both machines & I would guess with all ansi-C compliers.

JS

_________________________________________________________________________
14 Apr 94
Note that there now is only one set of time routines in asa.c, and that
now both asa.c and asa_usr.c pass two arguments to print_time(char
*message, FILE * ptr_asa_out).

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
18 Aug 93

For Turbo C, Davyd.Norris@physics.monash.edu.au suggests adding another
include file, tcdefs.h, after
#include <stdlib.h>
in asa.h and in asa_usr.h.
/***** tcdefs.h */
/* Custom defines for Turbo C 2.0 and above */
#include <float.h>
#define MAX_DOUBLE    DBL_MAX
#define MIN_DOUBLE    DBL_MIN
#define EPS_DOUBLE    DBL_EPSILON
}
/*****/

He also suggests:
} When compiling for Turbo/MS C, you need to set INT_ALLOC=TRUE and
} INT_LONG=TRUE.  Lotsa warnings about unused variables, but no errors
} or warnings that might mean something more serious.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
27 Aug 93

From zg11@midway.uchicago.edu Thu Aug 26 19:50:31 1993
Return-Path: <zg11@midway.uchicago.edu>
Date: Thu, 26 Aug 93 21:53:02 CDT
From: "zening  ge" <zg11@midway.uchicago.edu>
Subject: asa on PC

I have had the version 1.4 asa codes compiled using Turbo C++ 3.0 on my
386SX25 PC. The only thing needs to be changed is to set IO_PROTOTYPE
to FALSE.

It is necessary to turn IO_PROTOTYPES to FALSE to avoid the errors of
type mismatch in redefining "fprintf", "fflush", etc. For your example
problem, it took about 5 minutes to complete the computation on my
386SX25 PC without math-coprocessor.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
31 Aug 93

Return-Path: <selveria@salem.sylvania.com>
From: "Selverian, John" <selveria@salem.sylvania.com>
To: "'Ingber, Lester'" <ingber@alumni.caltech.edu>
Date: Tue, 31 Aug 93 13:58:00 PDT

thanks for the tip.

Setting INT_ALLOC = TRUE and INT_LONG = TRUE solved the problem. Now
the PC and SGI give the same answers.

Just for your info I am running a 486 66Mhz PC with a math co-processor
with MS Quick C for Windows version 1.0.

HP Code For Time Modules
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

4 Nov 93

The changes recommended below for hpux have been implemented using the
TIME_STD DEFINE_OPTION.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
4 Jan 10

Note that Sun C++ under Solaris, e.g., using SUNPRO CC, has system
headers that are written for both C and C++, and so the 'extern "C" {'
line and its '}' line should be commented out in the ASA [].h files.

========================================================================
##
# /***********************************************************************
# * Adaptive Simulated Annealing (ASA)
# * Lester Ingber <ingber@ingber.com>
# * Copyright (c) 1987-2016 Lester Ingber.  All Rights Reserved.
# * ASA-LICENSE file has the license that must be included with ASA code.
# ***********************************************************************/
#
## $Id: ASA-Makefile,v 30.21 2016/02/02 15:49:40 ingber Exp ingber $

## ********************************************************************
## First read ASA-README, then examine this ASA-Makefile and ASA-NOTES.
## ********************************************************************

MANIFEST = \
	ASA-CHANGES \
	ASA-LICENSE \
	ASA-Makefile \
	ASA-NOTES \
	ASA-README.html \
	ASA-README.ms \
	ASA-README.pdf \
	ASA-README.ps \
	ASA-README+.txt \
	ASA-README.txt \
	asa_test_asa \
	asa_test_usr \
	asa_usr.c \
	asa_usr.h \
	asa_usr_cst.c \
	asa.c \
	asa.h \
	asa_usr_asa.h \
	asa_opt

###
###		USER OPTIONS
### The policy is to try to have the asa module (not necessarily
### the user module) compile without "errors" (not necessarily without
### "warnings").  Some additional modifications may be needed on your
### machine; e.g., you might have to comment out the `#include <stdlib.h>'
### line in asa_usr_asa.h.  See the current ASA-NOTES file for any
### updates on some standard implementations.

###
## Defaults for various options are given below.  These can be
## overridden using DEFINE_OPTIONS.  If you include several options,
## separate them by a white space or place them conveniently on several
## lines; if the latter, be sure each line to be continued ends in a "\"
## (backslash).

DEFINE_OPTIONS = -DASA_TEST=TRUE # -DMY_TEMPLATE=TRUE

## This will run the ASA problem.
#DEFINE_OPTIONS = -DASA_TEST=TRUE
##
## This ASA_TEMPLATE will number the ASA_OUT file according to the
## system pid.  See asa_usr.h or possible changes you may have to make in the
## include file and the prototype for getpid(), as well as for the set of
## DEFINE_OPTIONS this example turns on.  (You might also have to change
## the int declaration of pid_int in asa_usr.c as well.)
#DEFINE_OPTIONS = -DASA_TEMPLATE_ASA_OUT_PID=FALSE
##
## This ASA_TEMPLATE will run the ASA test problem multiple times, and
## separate the runs into different files.  See asa_usr_asa.h for the set
## of DEFINE_OPTIONS this example turns on.
#DEFINE_OPTIONS = -DASA_TEMPLATE_MULTIPLE=FALSE
##
## This ASA_TEMPLATE illustrates the use of SELF_OPTIMIZE=TRUE.  See
## asa_usr_asa.h for the set of DEFINE_OPTIONS this example turns on.
#DEFINE_OPTIONS = -DASA_TEMPLATE_SELFOPT=FALSE
##
## This will run the ASA_SAMPLE problem.  See asa_usr_asa.h for the set of
## DEFINE_OPTIONS this example turns on.
#DEFINE_OPTIONS = -DASA_TEMPLATE_SAMPLE=FALSE
##
## This will run the ASA_QUEUE problem.  See asa_usr_asa.h for the set of
## DEFINE_OPTIONS this example turns on.
#DEFINE_OPTIONS = -DASA_TEMPLATE_QUEUE=FALSE
##
##This will run the ASA_PARALLEL code.  See asa_usr_asa.h for the set of
## DEFINE_OPTIONS this example turns on.
#DEFINE_OPTIONS = -DASA_TEMPLATE_PARALLEL=FALSE
##
## These will run the ASA_SAVE problem.  See asa_usr_asa.h for the set of
## DEFINE_OPTIONS this example turns on.
#DEFINE_OPTIONS = -DASA_TEMPLATE_SAVE=FALSE
##

###
###		Pre-Compile Options
###
## You can elect to read in the Program Options from asa_opt by
## setting OPTIONS_FILE=TRUE.  OPTIONS_FILE=TRUE can be set here or
## in asa_usr_asa.h.
#-DOPTIONS_FILE=TRUE

## If OPTIONS_FILE is set to TRUE, then also setting OPTIONS_FILE_DATA
## to TRUE will read in most initialization data from asa_opt.
#-DOPTIONS_FILE_DATA=TRUE

## You can elect to read in the Program Options from asa_opt by setting
## RECUR_OPTIONS_FILE=TRUE.  RECUR_OPTIONS_FILE=TRUE can be set here or in
## asa_usr_asa.h.
#-DRECUR_OPTIONS_FILE=FALSE

## If RECUR_OPTIONS_FILE is set to TRUE, then also setting
## RECUR_OPTIONS_FILE_DATA to TRUE will read in most initialization data
## from asa_opt.
#-DRECUR_OPTIONS_FILE_DATA=FALSE

## If COST_FILE is set to TRUE, then your own file for the cost
## function can be read into asa_usr.c.
#-DCOST_FILE=TRUE

## Setting ASA_LIB=TRUE will facilitate your running asa() as a library
## call from another program, calling asa_main() in asa_usr.c.  In the
## templates, provided, all initializations and cost function definitions
## are set up in asa_usr.c.
#-DASA_LIB=FALSE

## If ASA_TEMPLATE_LIB=TRUE, then asa_main() returns information to an
## example main() in asa_usr.c.  This illustrates how you provide the
## appropriate memory in your main().
#-DASA_TEMPLATE_LIB=FALSE

## If you do _not_ have an ANSI compiler set this to FALSE.
## If you use HAVE_ANSI=FALSE, change CC and CDEBUGFLAGS below.
#-DHAVE_ANSI=TRUE

## Most newer operating systems do not like any other I/O prototyping
## other than those in their own include files.  Other machines, like a
## Dec\-3100 under Ultrix complain that the ANSI I/O prototypes were
## inconsistent.  A Sun under 4.1.x gcc gave warnings if no I/O prototypes
## were present.  The defaults in asa_usr_asa.h use newer system prototypes.
## IO_PROTOTYPES=TRUE will uncomment out declarations for such items as
## fprintf, fflush, fclose, exit, and fscanf.
#-DIO_PROTOTYPES=FALSE

## Some systems do not have the time include files used here; others
## have different scales for time.  Setting TIME_CALC=TRUE will permit
## use of the time routines.
#-DTIME_CALC=FALSE
 
## Some systems, e.g., hpux, use other Unix-standard macros to access
## time.  Setting TIME_STD=TRUE when using TIME_CALC=TRUE will use these
## time routines instead.
#-DTIME_STD=FALSE

## Some smaller systems choke on `long int' and this option can be
## set to INT_LONG=FALSE to turn off warnings and possibly some errors.
#-DINT_LONG=TRUE

## Some machine may not permit the dimension of calloc be anything
## but int; in this case define INT_ALLOC=TRUE.  The default of FALSE
## is to set the dimension to that of LONG_INT, determined by INT_LONG.
#-DINT_ALLOC=FALSE

## You can define SMALL_FLOAT to better correlate to your own machine's
## maximum precision here if you know it.
#-DSMALL_FLOAT=1.0E-18

## You can define your own machine's minimum positive doubles here
## if you know it.

#-DMIN_DOUBLE=SMALL_FLOAT

## You can define your own machine's maximum doubles here if you
## know it.
#-DMAX_DOUBLE=1.0/SMALL_FLOAT

## You can define your own machine's maximum precision here if you
## know it.
#-DEPS_DOUBLE=SMALL_FLOAT

## When CHECK_EXPONENT is TRUE, EXPONENT_CHECK(x) in asa() checks that
## an exponent x is within a valid range and, if not, adjusts its
## magnitude to fit in the range.
#-DCHECK_EXPONENT=FALSE

## When parameter temperatures are less than SMALL_FLOAT, do not exit,
## and set them to SMALL_FLOAT.
#-DNO_PARAM_TEMP_TEST=FALSE

## When the cost temperature is less than SMALL_FLOAT, do not exit,
## and set it to SMALL_FLOAT.
#-DNO_COST_TEMP_TEST=FALSE

## You can try to use asa to self-optimize its own Program Options
## be setting SELF_OPTIMIZE=TRUE.  This can be very CPU-expensive as
## well as being dependent on your definition of recur_cost_function.
#-DSELF_OPTIMIZE=FALSE

## To use the ASA test problem, set ASA_TEST to TRUE.
#-DASA_TEST=FALSE

## To use the enhanced ASA test problem, set ASA_TEST_POINT to TRUE.
#-DASA_TEST_POINT=FALSE

## To  permit IMMEDIATE_EXIT before calculating the next generated state,
## by deleting the file asa_exit_anytime, set ASA_EXIT_ANYTIME to TRUE.
#-DASA_EXIT_ANYTIME=FALSE

## Setting USER_INITIAL_COST_TEMP to TRUE permits you to specify the
## initial cost temperature.  This can be useful in problems where you
## want to start the search at a specific scale.
#-DUSER_INITIAL_COST_TEMP=FALSE

## Different rates of parameter annealing can be set with
## RATIO_TEMPERATURE_SCALES set to TRUE.
#-DRATIO_TEMPERATURE_SCALES=FALSE

## Setting USER_INITIAL_PARAMETERS_TEMPS to TRUE permits you to specify
## the initial parameter temperatures.  This can be useful in constrained
## problems, where greater efficiency can be achieved in focussing the
## search than might be permitted just by setting upper and lower bounds.
#-DUSER_INITIAL_PARAMETERS_TEMPS=FALSE

## Different increments, used during reannealing to set each
## parameter's numerical derivatives, can be set with DELTA_PARAMETERS set
## to TRUE.
#-DDELTA_PARAMETERS=FALSE

## QUENCH_PARAMETERS permits you to alter the basic algorithm to
## perform selective "quenching," i.e., faster temperature cooling than
## permitted by the ASA algorithm.  This can be very useful, e.g., to
## quench the system down to some region of interest, and then to perform
## proper annealing for the rest of the run.
#-DQUENCH_PARAMETERS=FALSE

## If QUENCH_COST is set to TRUE, the scale of the power of the
## temperature schedule used for the acceptance function can be altered in
## a similar fashion to that described above when QUENCH_PARAMETERS is set
## to TRUE.
#-DQUENCH_COST=FALSE

## When QUENCH_PARAMETERS is TRUE, if QUENCH_PARAMETERS_SCALE is TRUE,
## then the temperature scales and the temperature indexes are affected by
## User_Quench_Param_Scale[].  When QUENCH_PARAMETERS is TRUE, if
## QUENCH_PARAMETERS_SCALE is FALSE, only the temperature indexes are
## affected by User_Quench_Param_Scale[].
#-DQUENCH_PARAMETERS_SCALE=TRUE

## When QUENCH_COST is TRUE, if QUENCH_COST_SCALE is TRUE, then the
## temperature scale and the temperature index are affected by
## User_Quench_Cost_Scale[0].  When QUENCH_COST is TRUE, if
## QUENCH_COST_SCALE is FALSE, only the temperature index is affected by
## User_Quench_Cost_Scale[0].
#-DQUENCH_COST_SCALE=TRUE

## To use testing templates in the asa_usr.c and asa.c files, associated
## with several OPTIONS, set ASA_TEMPLATE to TRUE.
#-DASA_TEMPLATE=FALSE

## It can be useful to return additional information to the user
## module from the asa module.  When OPTIONAL_DATA_DBL is set to TRUE, an
## additional pointer, *Asa_Data_Dbl,  is available in DEFINES *OPTIONS to
## gather such data.
#-DOPTIONAL_DATA_DBL=FALSE

## It can be useful to return additional integer information to the
## user module from the asa module.  When OPTIONAL_DATA_INT is set to
## TRUE, an additional pointer, *Asa_Data_Int,  is available in DEFINES
## *OPTIONS to gather such data.
#-DOPTIONAL_DATA_INT=FALSE

## It can be useful to return/pass additional array information to the
## user module from/through the asa module.  When OPTIONAL_DATA_PTR is set
## to TRUE, an additional pointer, *Asa_Data_Ptr, of type
## OPTIONAL_PTR_TYPE is available in DEFINES *OPTIONS to gather such data.
#-DOPTIONAL_DATA_PTR=FALSE

## The function used for the cost_function temperature  schedule is of
## the form test_temperature in asa.c.  You can define your own function
## of test_temperature adaptively in asa_usr.c in user_cost_schedule() (and
## in recur_user_cost_schedule() if SELF_OPTIMIZE is TRUE) by setting
## USER_COST_SCHEDULE to TRUE.
#-DUSER_COST_SCHEDULE=FALSE

## The standard Boltzmann probability distribution is used for the
## acceptance test.  You can adaptively change this using Asymp_Exp_Param
## by setting USER_ACCEPT_ASYMP_EXP to TRUE.
#-DUSER_ACCEPT_ASYMP_EXP=FALSE

## The standard Boltzmann probability distribution is used for the
## acceptance test.  You can change this by setting USER_ACCEPT_THRESHOLD
## to TRUE.
#-DUSER_ACCEPT_THRESHOLD=FALSE

## The standard Boltzmann probability distribution is used for the
## acceptance test.  You can adaptively change this with your own function
## in asa_usr.c in user_acceptance_test() (and in
## recur_user_acceptance_test() if SELF_OPTIMIZE is TRUE) by setting
## USER_ACCEPTANCE_TEST to TRUE.
#-DUSER_ACCEPTANCE_TEST=FALSE

## The ASA generating probability distribution us used to generate new
## states.  You can adaptively change this with your own function in
## asa_usr.c in user_generating_distrib() (and in
## recur_user_generating_distrib() if SELF_OPTIMIZE is TRUE) by setting
## USER_GENERATING_FUNCTION to TRUE.
#-DUSER_GENERATING_FUNCTION=FALSE

## If you wish to adaptively control the algorithm controlling
## reannealing of the cost function, this can be done in asa_usr.c in
## user_reanneal_cost() (and in recur_user_reanneal_cost() if
## SELF_OPTIMIZE is TRUE) by setting USER_REANNEAL_COST to TRUE.
#-DUSER_REANNEAL_COST=FALSE

## The macro used for reannealing parameter temperatures
## #define FUNCTION_REANNEAL_PARAMS(temperature, tangent, max_tangent) \
##  (temperature * (max_tangent / tangent))
## is defined in asa.h.  If you wish to adaptively control this function
## it can be defined in asa_usr.c in user_reanneal_params() (and in
## recur_user_reanneal_params() if SELF_OPTIMIZE is TRUE) by setting
## USER_REANNEAL_PARAMETERS to TRUE.
#-DUSER_REANNEAL_PARAMETERS=FALSE

## MAXIMUM_REANNEAL_INDEX is the maximum index (number of steps) at
## which the initial temperature and the index of the temperature are
## rescaled to avoid losing machine precision.
#-DMAXIMUM_REANNEAL_INDEX=50000

## REANNEAL_SCALE is the reannealing scale used when
## MAXIMUM_REANNEAL_INDEX is exceeded.
#-DREANNEAL_SCALE=10

## When ASA_SAMPLE is set to TRUE, data is collected by asa to
## importance-sample the users' variable space.
#-DASA_SAMPLE=FALSE

## When ADAPTIVE_OPTIONS is set to TRUE, it is possible to change relevant
## OPTIONS in the USER_DEFINES struct in asa_usr_asa.h during run time,
## by including an asa_adaptive_options file.
#-DADAPTIVE_OPTIONS=FALSE

## When ASA_QUEUE is set to TRUE, a FIFO queue saves generated states,
## to avoid extra cost function calculations.
#-DASA_QUEUE=FALSE

## When ASA_RESOLUTION is set to TRUE, Coarse_Resolution[] defines the
## resolution of parameters in the fit.
#-DASA_RESOLUTION=FALSE

## When ASA_FUZZY is set to TRUE, several subroutines become available to
## perform an adaptive tuning of selected ASA OPTIONS.
#-DASA_FUZZY=FALSE

## When ASA_FUZZY_PRINT is set to TRUE, the local fitting routines
## print out from the user module.
#-DASA_FUZZY_PRINT=FALSE

## When FITLOC is set to TRUE, three subroutines become available to
## shunt asa() over to a local simplex optimization.
#-DFITLOC=FALSE

## If FITLOC is set to TRUE and FITLOC_ROUND is TRUE, then each time
## parameters are passed to or between the local routines, they are first
## processed by rounding integers or respecting rounding according to
## ASA_RESOLUTION constraints.
#-DFITLOC_ROUND=TRUE

## When FITLOC is set to TRUE and FITLOC_PRINT is TRUE, the local
## fitting routines print out from the user module.
#-DFITLOC_PRINT=TRUE

## When MULTI_MIN is set to TRUE, the lowest Multi_Number values of the
## cost function and their parameters are saved.
#-DMULTI_MIN=FALSE

## When ASA_PARALLEL is set to TRUE, ASA is run in parallel-processor
## mode.
#-DASA_PARALLEL=FALSE

## When FDLIBM_POW is set to TRUE, a user-defined function s_pow() is
## used instead of pow().  This may be desirable on some machines when a
## speed-up can be realized.
#-DFDLIBM_POW=FALSE

## When FDLIBM_LOG is set to TRUE, a user-defined function s_log() is
## used instead of log().  This may be desirable on some machines when a
## speed-up can be realized.
#-DFDLIBM_LOG=FALSE

## When FDLIBM_EXP is set to TRUE, a user-defined function s_exp() is
## used instead of exp().  This may be desirable on some machines when a
## speed-up can be realized.
#-DFDLIBM_EXP=FALSE

###
###		Printing Options
###
## Setting ASA_PRINT to FALSE will suppress all printing within asa.
#-DASA_PRINT=TRUE

## The name of the output file containing all printing from asa If you
## wish to attach a process number use ASA_OUT=\"asa_out_$$$$\" If
## ASA_OUT=\"STDOUT\" then ASA will print to stdout.
#-DASA_OUT=\"asa_out\"

## The name of the output file containing all printing from asa_usr.c If you
## wish to attach a process number use USER_OUT=\"asa_usr_out_$$$$\" If
## USER_OUT=\"STDOUT\" then asa_usr.c will print to stdout.
#-DUSER_OUT=\"asa_usr_out\"

## Some compilers on some systems under some levels of optimization will not
## compile if stdout is present in the code.  All instances of stdout and
## printf in the user and the asa modules can be commented out by setting
## INCL_STDOUT to FALSE.  Note that this also will suppress some output
## from such OPTIONS as ASA_PIPE, TIME_CALC, etc.
#-DINCL_STDOUT=TRUE

## If your wish to have the printing from asa be sent to a file
## determined dynamically from the user module, set USER_ASA_OUT to
## TRUE, and define the Program Option *Asa_Out_File in the user module.
## (This overrides any ASA_OUT settings.)  In asa_usr.c, if
## USER_OPTIONS->Asa_Out_File = "STDOUT";, then ASA will print to stdout.
#-DUSER_ASA_OUT=FALSE

## If your wish to have the printing from asa_usr be sent to a file
## determined dynamically from the user module, set USER_ASA_USR_OUT to
## TRUE, and define the Program Option *Asa_Usr_Out_File in the user module.
## (This overrides any USER_OUT settings.)
#-DUSER_ASA_USR_OUT=FALSE

## Setting ASA_PRINT_INTERMED to FALSE will suppress intermediate
## printing within asa.
#-DASA_PRINT_INTERMED=TRUE

## Setting ASA_PRINT_MORE to TRUE will print out more intermediate
## information, e.g., new parameters whenever a new minimum is reported.
#-DASA_PRINT_MORE=FALSE

## The field width and precision for doubles is specified as
## G_FIELD.G_PRECISION.
#-DG_FIELD=12
#-DG_PRECISION=7

## When ASA_SAVE is set to TRUE, asa saves enough information after
## each newly best accepted state to restart from that point.
#-DASA_SAVE=FALSE

## If ASA_SAVE is set to TRUE, when ASA_SAVE_BACKUP is set to TRUE,
## asa saves enough information after each newly best accepted state to
## restart from any previous best accepted state when that
## asa_save.{best_state} is copied to asa_save.
#-DASA_SAVE_BACKUP=FALSE

## If ASA_SAVE_OPT is set to TRUE, when asa is restarted, if the file
## asa_opt_save is present in the same directory as asa_opt, then new values
## of ASA parameters and OPTIONS are read in after initializing to the
## point of the last writing of asa_save, without requiring recompilation.
#-DASA_SAVE_OPT=FALSE

## When ASA_PIPE is set to TRUE asa prints to STDOUT lines of
## data that can be used to update databases or charts.
#-DASA_PIPE=FALSE

## When ASA_PIPE_FILE is set to TRUE asa prints to asa_pipe lines of
## data that can be used to examine run data.
#DASA_PIPE_FILE=FALSE

## When SYSTEM_CALL is set to FALSE, asa avoids popen calls, e.g.,
## as in asa.c when ASA_SAVE is set to TRUE, to copy asa_save to
## asa_save.old.  This is useful on machines that do not permit these
## commands.
#-DSYSTEM_CALL=TRUE

###
###		Compiler Choices
###
## If HAVE_ANSI=TRUE use this block; otherwise, use the K&R block below.
## The gnu C compiler is the default.
## The use of -ffloat-store with gcc/g++ is to maintain the same level of
## precision across levels of compiler optimization on different platforms.
#CC = g++
CC = gcc
CDEBUGFLAGS = -g -Wall -ffloat-store # -Wno-unused-but-set-variable # MY_TEMPLATE_flags
##
## If you use your system's ANSI compiler, e.g., named cc, use this block.
## Sun's ANSI compiler is named acc, so use CC = acc for this one.

#CC = acc
#CDEBUGFLAGS = -O

## If HAVE_ANSI=FALSE use this K&R block, or the next block with gcc
#CC = cc
#CDEBUGFLAGS = -O
#
#CC = gcc
#CDEBUGFLAGS = -traditional -g -O -Wall -ffloat-store

## If you wish to include some profile statistics
#CC = gcc -pg
#CDEBUGFLAGS = -g -Wall -ffloat-store

## If using gcc with ASA_PARALLEL and _OPENMP using gcc
#CC = gcc -fopenmp
#CDEBUGFLAGS = -g -Wall -ffloat-store # MY_TEMPLATE_flags

CFLAGS = $(CDEBUGFLAGS) $(DEFINE_OPTIONS)
## Under Cygwin, using ASA_LIB set TRUE and INCL_STDOUT set FALSE,
## use the following to produce a DLL with asa_dll: below
## CC = /bin/i686-pc-mingw32-gcc.exe

LDFLAGS =

all:
	make compile
	make run
#	make profile

###
###		Document Formatting
###
doc:
## Use groff if you have it; add pep or colcrt to delete extra
## formatting.  Under groff, using `more' or `less' presents an enhanced
## text.  The following is used on Cygwin.
## Otherwise, standard UNIX macros are fine.
## The next 2 lines use standard UNIX utilities
#	refer -e -P -n ASA-README.ms | tbl | nroff -ms > ASA-README+.txt
#	refer -e -P -n ASA-README.ms | tbl | nroff -ms | pep > ASA-README.txt
##
## Similarly, you may format your own PostScript ASA-README.ps.
##
	groff -wall -R -t -Tascii -ms ASA-README.ms > ASA-README+.txt
	cat ASA-README+.txt | sed -e "s/\[1m//g" | sed -e "s/\[0m//g" | sed -e "s/\[4m//g" | sed -e "s/\[24m//g" | sed -e "s/\[22m//g" > ASA-README.txt
	groff -wall -R -t -e -ms ASA-README.ms > tp.ASA-README.ps
	psselect -p1,58-,2-56 tp.ASA-README.ps > ASA-README.ps
	rm tp.ASA-README.ps
	ps2pdf ASA-README.ps
	HTML/xread_html
	chmod 644 ASA-README*

###
###		Other Standard Arguments to Make
###
# MY_TEMPLATE_macros
#
## If COST_FILE is set to FALSE, asa_usr_cst.c may be deleted.  If the
## name asa_usr_cst.c is changed, then this might be changed here as well.
USEROBJS = asa_usr.o asa_usr_cst.o # the name of the calling object files
ASAOBJS = asa.o # the ASA optimization object file
ASA_USER_INCL = asa.h asa_usr.h
# MY_TEMPLATE_OBJS =
# MY_TEMPLATE_incl =
# Use this 2-line compile instead of the next one if using MY_TEMPLATE_OBJS
#compile: $(USEROBJS) $(ASAOBJS) $(MY_TEMPLATE_OBJS)
#	@$(CC) $(LDFLAGS) -o asa_run $(USEROBJS) $(ASAOBJS) $(MY_TEMPLATE_OBJS) -lm
compile: $(USEROBJS) $(ASAOBJS)
	@$(CC) $(LDFLAGS) -o asa_run $(USEROBJS) $(ASAOBJS) -lm

$(USEROBJS): asa_usr.h # MY_TEMPLATE_user_incl
$(ASAOBJS): asa.h
$(ASA_USER_INCL): asa_usr_asa.h
# MY_TEMPLATE_depends

profile:
	gprof -z asa_run > asa_profile

## CC and CFLAGS are passed into main, to be recorded in asa_usr_out.
## If "." is not in the path, use "./asa_run" instead of "asa_run" .
## Use a low value of nice for runs that are time- and CPU-intensive.
run:
	asa_run $(CC) $(CFLAGS) # MY_TEMPLATE_run
#	./asa_run $(CC) $(CFLAGS) # MY_TEMPLATE_run
#	nice -19 asa_run $(CC) $(CFLAGS)
#	profile

clean:
	rm -f *\.o asa_run* asadll* # MY_TEMPLATE_clean core gmon.out

realclean:
	rm -f *\.o asa_run* asa_usr_out* asa_out* core asa_save* asa_rcur asa_sfop \
	asa_exit_anytime asa_[A-D]_[a-d] asa_pipe asadll* # MY_TEMPLATE_realclean gmon.out

docclean:
	rm -f ASA-README.txt ASA-README.ps ASA-README.pdf

tgz:
	mkdir ASA ; cp $(MANIFEST) ASA ; tar cBf - ASA | gzip --best > ASA.tar.gz ; rm -rf ASA

## Prepare DOS-zip using UNIX-zip
zip:
	mkdir ASA ; cp $(MANIFEST) ASA ; u2d ASA/*[^f] ; zip -rq9 ASA ASA ; rm -rf ASA

# under Cygwin change CC to
## CC = /bin/i686-pc-mingw32-gcc.exe
dllmodule = asadll
obj_libs = $(MY_TEMPLATE_OBJS) $(USEROBJS) $(ASAOBJS)
dependency_libs =  # -lm is a dummy /usr/lib/mingw/libm.a with Cygwin
#dependency_libs = -lm
# compiling without main(), using ASA_LIB, gives warning to be ignored.
asadll:
	make -i compile
	$(CC) $(CFLAGS) -shared -o ${dllmodule}.dll \
	-Wl,--out-implib=${dllmodule}.lib \
	-Wl,--compat-implib \
	-Wl,--add-stdcall-alias \
	-Wl,--enable-stdcall-fixup \
	-Wl,--enable-auto-import \
	-Wl,--enable-auto-image-base \
	-Wl,--whole-archive ${obj_libs} \
	-Wl,--export-all \
	-Wl,--output-def=${dllmodule}.def \
	-Wl,--no-whole-archive ${dependency_libs}

/***********************************************************************
* Adaptive Simulated Annealing (ASA)
* Lester Ingber <ingber@ingber.com>
* Copyright (c) 1987-2016 Lester Ingber.  All Rights Reserved.
* ASA-LICENSE file has the license that must be included with ASA code.
***********************************************************************/

#define ASA_ID "/* $Id: asa.c,v 30.21 2016/02/02 15:49:44 ingber Exp ingber $ */"

#include "asa.h"

char exit_msg[160];             /* temp storage for exit messages */

/***********************************************************************
* asa
*       This procedure implements the full ASA function optimization.
***********************************************************************/
#if HAVE_ANSI
double
asa (double (*user_cost_function)

      
     (double *, double *, double *, double *, double *, ALLOC_INT *, int *,
      int *, int *, USER_DEFINES *),
     double (*user_random_generator) (LONG_INT *), LONG_INT * seed,
     double *parameter_initial_final, double *parameter_minimum,
     double *parameter_maximum, double *tangents, double *curvature,
     ALLOC_INT * number_parameters, int *parameter_type,
     int *valid_state_generated_flag, int *exit_status,
     USER_DEFINES * OPTIONS)
#else
double
asa (user_cost_function,
     user_random_generator,
     seed,
     parameter_initial_final,
     parameter_minimum,
     parameter_maximum,
     tangents,
     curvature,
     number_parameters,
     parameter_type, valid_state_generated_flag, exit_status, OPTIONS)
     double (*user_cost_function) ();
     double (*user_random_generator) ();
     LONG_INT *seed;
     double *parameter_initial_final;
     double *parameter_minimum;
     double *parameter_maximum;
     double *tangents;
     double *curvature;
     ALLOC_INT *number_parameters;
     int *parameter_type;
     int *valid_state_generated_flag;
     int *exit_status;
     USER_DEFINES *OPTIONS;
#endif /* HAVE_ANSI */
{
#if USER_REANNEAL_COST
#else
  int immediate_flag;           /* save Immediate_Exit */
#endif /* USER_REANNEAL_COST */
#if USER_INITIAL_COST_TEMP
#if USER_REANNEAL_COST
#else
  int index_cost_constraint;    /* index cost functions averaged */
#endif /* USER_REANNEAL_COST */
#else /* USER_INITIAL_COST_TEMP */
  int index_cost_constraint;    /* index cost functions averaged */
#endif /* USER_INITIAL_COST_TEMP */

  int index_cost_repeat,        /* test OPTIONS->Cost_Precision when =
                                   OPTIONS->Maximum_Cost_Repeat */
    tmp_var_int, tmp_var_int1, tmp_var_int2;    /* temporary integers */

  int generate_flg;
  ALLOC_INT index_v,            /* iteration index */
   *start_sequence;             /* initial OPTIONS->Sequential_Parameters
                                   used if >= 0 */
  double final_cost,            /* best cost to return to user */
    tmp_var_db, tmp_var_db1, tmp_var_db2;       /* temporary doubles */
  int *curvature_flag;
  FILE *ptr_asa_out;            /* file ptr to output file */
  int ret1_flg;

  /* The 3 states that are kept track of during the annealing process */
  STATE *current_generated_state, *last_saved_state, *best_generated_state;

#if ASA_SAVE
  FILE *ptr_save, *ptr_comm;
  int asa_read;
  char asa_save_comm[100];
#if ASA_SAVE_OPT
  char read_option[80];
  char read_if[4], read_FALSE[6], read_comm1[3], read_ASA_SAVE[9],
    read_comm2[3];
  int read_int;
#if INT_LONG
  LONG_INT read_long;
#endif
  double read_double;
  FILE *ptr_save_opt;
#endif
#endif /* ASA_SAVE */

#if ASA_PIPE_FILE
  FILE *ptr_asa_pipe;
#endif

#if ASA_EXIT_ANYTIME
  FILE *ptr_exit_anytime;
#endif /* ASA_EXIT_ANYTIME */

  int asa_exit_value;
  int best_flag;
  int fscanf_ret;

  double xnumber_parameters[1];

  /* The array of tangents (absolute value of the numerical derivatives),
     and the maximum |tangent| of the array */
  double *maximum_tangent;

  /* ratio of acceptances to generated points - determines when to
     test/reanneal */
  double *accepted_to_generated_ratio;

  /* temperature parameters */
  double temperature_scale, *temperature_scale_parameters;
  /* relative scalings of cost and parameters to temperature_scale */
  double *temperature_scale_cost;
  double *current_user_parameter_temp;
  double *initial_user_parameter_temp;
  double *current_cost_temperature;
  double *initial_cost_temperature;
  double log_new_temperature_ratio;     /* current *temp = initial *temp *
                                           exp(log_new_temperature_ratio) */
  ALLOC_INT *index_exit_v;      /* information for asa_exit */

  /* counts of generated states and acceptances */
  LONG_INT *index_parameter_generations;
  LONG_INT *number_generated, *best_number_generated_saved;
  LONG_INT *recent_number_generated, *number_accepted;
  LONG_INT *recent_number_acceptances, *index_cost_acceptances;
  LONG_INT *number_acceptances_saved, *best_number_accepted_saved;

  /* Flag indicates that the parameters generated were
     invalid according to the cost function validity criteria. */
  LONG_INT *number_invalid_generated_states;
  LONG_INT repeated_invalid_states;

#if ASA_QUEUE
  int queue_new;                /* flag to add new entry */
  int *save_queue_flag;         /* save valid_state_generated_flag */
  LONG_INT queue;               /* index of queue */
  LONG_INT queue_v;             /* index of parameters in queue */
  LONG_INT save_queue_test;     /* test if all parameters are present */
  LONG_INT save_queue;          /* last filled position in queue */
  LONG_INT save_queue_indx;     /* current position in queue */
  double *save_queue_cost, *save_queue_param;   /* saved states */
  ALLOC_INT queue_size_tmp;
#endif /* ASA_QUEUE */

#if MULTI_MIN
  int multi_index;
  int multi_test, multi_test_cmp, multi_test_dim;
  int *multi_sort;
  double *multi_cost;
  double **multi_params;
#endif /* MULTI_MIN */

#if ASA_PARALLEL
  int EXIT_asa_parallel = 0;
  LONG_INT tmp_var_lint;
  LONG_INT *parallel_gen_ratio_block;
  LONG_INT *parallel_sort;
  LONG_INT i_prll, sort_index;  /* count of parallel generated states */
  STATE *gener_block_state;
  int *generate_flg_par;
  LONG_INT *number_invalid_generated_states_par;
  LONG_INT *repeated_invalid_states_par;
  double *tmp_var_db1_par;
  double *tmp_var_db_par;
  int *valid_state_generated_flag_par;
  int valid_state_generated_flag_par_test;
#if ASA_QUEUE
  int *queue_new_par;
  LONG_INT *queue_v_par;
  LONG_INT *save_queue_indx_par;
  LONG_INT *save_queue_test_par;
  LONG_INT *save_queue_par;
  double *queue_par_cost;
  int **save_queue_valid_state_flag_par;
  double **save_queue_cost_par;
  double **save_queue_param_par;
#endif /* ASA_QUEUE */
#endif /* ASA_PARALLEL */

  /* used to index repeated and recursive calls to asa */
  /* This assumes that multiple calls (>= 1) _or_ recursive
     calls are being made to asa */
  static int asa_open = FALSE;
  static int number_asa_open = 0;
  static int recursive_asa_open = 0;

  /* initializations */

  ret1_flg = 0;
  generate_flg = 0;
  if (generate_flg != 0)
    generate_flg = 0;

  fscanf_ret = 0;               /* stop compiler warning */
  if (fscanf_ret) {
    ;
  }

  if ((curvature_flag = (int *) calloc (1, sizeof (int))) == NULL) {
    strcpy (exit_msg, "asa(): curvature_flag");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((maximum_tangent = (double *) calloc (1, sizeof (double))) == NULL) {
    strcpy (exit_msg, "asa(): maximum_tangent");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((accepted_to_generated_ratio =
       (double *) calloc (1, sizeof (double))) == NULL) {
    strcpy (exit_msg, "asa(): accepted_to_generated_ratio");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((temperature_scale_cost =
       (double *) calloc (1, sizeof (double))) == NULL) {
    strcpy (exit_msg, "asa(): temperature_scale_cost");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((current_cost_temperature =
       (double *) calloc (1, sizeof (double))) == NULL) {
    strcpy (exit_msg, "asa(): current_cost_temperature");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((initial_cost_temperature =
       (double *) calloc (1, sizeof (double))) == NULL) {
    strcpy (exit_msg, "asa(): initial_cost_temperature");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((index_exit_v = (ALLOC_INT *) calloc (1, sizeof (ALLOC_INT))) == NULL) {
    strcpy (exit_msg, "asa(): index_exit_v");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((start_sequence = (ALLOC_INT *) calloc (1, sizeof (ALLOC_INT))) == NULL) {
    strcpy (exit_msg, "asa(): start_sequence");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((number_generated =
       (ALLOC_INT *) calloc (1, sizeof (ALLOC_INT))) == NULL) {
    strcpy (exit_msg, "asa(): number_generated");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((best_number_generated_saved =
       (ALLOC_INT *) calloc (1, sizeof (ALLOC_INT))) == NULL) {
    strcpy (exit_msg, "asa(): best_number_generated_saved");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((recent_number_generated =
       (ALLOC_INT *) calloc (1, sizeof (ALLOC_INT))) == NULL) {
    strcpy (exit_msg, "asa(): recent_number_generated");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((number_accepted =
       (ALLOC_INT *) calloc (1, sizeof (ALLOC_INT))) == NULL) {
    strcpy (exit_msg, "asa(): number_accepted");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((recent_number_acceptances =
       (ALLOC_INT *) calloc (1, sizeof (ALLOC_INT))) == NULL) {
    strcpy (exit_msg, "asa(): recent_number_acceptances");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((index_cost_acceptances =
       (ALLOC_INT *) calloc (1, sizeof (ALLOC_INT))) == NULL) {
    strcpy (exit_msg, "asa(): index_cost_acceptances");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((number_acceptances_saved =
       (ALLOC_INT *) calloc (1, sizeof (ALLOC_INT))) == NULL) {
    strcpy (exit_msg, "asa(): number_acceptances_saved");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((best_number_accepted_saved =
       (ALLOC_INT *) calloc (1, sizeof (ALLOC_INT))) == NULL) {
    strcpy (exit_msg, "asa(): best_number_accepted_saved");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((number_invalid_generated_states =
       (ALLOC_INT *) calloc (1, sizeof (ALLOC_INT))) == NULL) {
    strcpy (exit_msg, "asa(): number_invalid_generated_states");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }

  if ((current_generated_state =
       (STATE *) calloc (1, sizeof (STATE))) == NULL) {
    strcpy (exit_msg, "asa(): current_generated_state");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((last_saved_state = (STATE *) calloc (1, sizeof (STATE))) == NULL) {
    strcpy (exit_msg, "asa(): last_saved_state");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((best_generated_state = (STATE *) calloc (1, sizeof (STATE))) == NULL) {
    strcpy (exit_msg, "asa(): best_generated_state");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
#if ASA_PARALLEL
  if ((gener_block_state =
       (STATE *) calloc (OPTIONS->Gener_Block_Max, sizeof (STATE))) == NULL) {
    strcpy (exit_msg, "asa(): gener_block_state");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  gener_block_state_qsort = gener_block_state;
  if ((parallel_sort =
       (LONG_INT *) calloc (OPTIONS->Gener_Block_Max,
                            sizeof (LONG_INT))) == NULL) {
    strcpy (exit_msg, "asa(): parallel_sort");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }

  if ((generate_flg_par =
       (int *) calloc (OPTIONS->Gener_Block_Max, sizeof (int))) == NULL) {
    strcpy (exit_msg, "asa(): generate_flg_par");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((valid_state_generated_flag_par =
       (int *) calloc (OPTIONS->Gener_Block_Max, sizeof (int))) == NULL) {
    strcpy (exit_msg, "asa(): valid_state_generated_flag_par");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((number_invalid_generated_states_par =
       (LONG_INT *) calloc (OPTIONS->Gener_Block_Max,
                            sizeof (LONG_INT))) == NULL) {
    strcpy (exit_msg, "asa(): number_invalid_generated_states_par");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((repeated_invalid_states_par =
       (LONG_INT *) calloc (OPTIONS->Gener_Block_Max,
                            sizeof (LONG_INT))) == NULL) {
    strcpy (exit_msg, "asa(): repeated_invalid_states_par");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((tmp_var_db1_par =
       (double *) calloc (OPTIONS->Gener_Block_Max,
                          sizeof (double))) == NULL) {
    strcpy (exit_msg, "asa(): tmp_var_db1_par");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((tmp_var_db_par =
       (double *) calloc (OPTIONS->Gener_Block_Max,
                          sizeof (double))) == NULL) {
    strcpy (exit_msg, "asa(): tmp_var_db_par");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }

  if ((parallel_gen_ratio_block =
       (LONG_INT *) calloc (OPTIONS->Gener_Mov_Avr,
                            sizeof (LONG_INT))) == NULL) {
    strcpy (exit_msg, "asa(): parallel_gen_ratio_block");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }

  for (i_prll = 0; i_prll < OPTIONS->Gener_Mov_Avr; ++i_prll) {
    parallel_gen_ratio_block[i_prll] = OPTIONS->Gener_Block;
  }
#endif /* ASA_PARALLEL */

  fscanf_ret = 0;

  /* set default */
  ptr_asa_out = (FILE *) NULL;

  OPTIONS->Immediate_Exit = FALSE;

  if (asa_open == FALSE) {
    asa_open = TRUE;
    ++number_asa_open;
#if ASA_PRINT
    if (number_asa_open == 1) {
      /* open the output file */
#if USER_ASA_OUT
      if (!strcmp (OPTIONS->Asa_Out_File, "STDOUT")) {
#if INCL_STDOUT
        ptr_asa_out = stdout;
#endif /* INCL_STDOUT */
      } else {
#if ASA_SAVE
        ptr_asa_out = fopen (OPTIONS->Asa_Out_File, "a");
#else
        ptr_asa_out = fopen (OPTIONS->Asa_Out_File, "w");
#endif
      }
#else /* USER_ASA_OUT */
      if (!strcmp (ASA_OUT, "STDOUT")) {
#if INCL_STDOUT
        ptr_asa_out = stdout;
#endif /* INCL_STDOUT */
      } else {
#if ASA_SAVE
        ptr_asa_out = fopen (ASA_OUT, "a");
#else
        ptr_asa_out = fopen (ASA_OUT, "w");
#endif
      }
#endif /* USER_ASA_OUT */
    } else {
#if USER_ASA_OUT
      if (!strcmp (OPTIONS->Asa_Out_File, "STDOUT")) {
#if INCL_STDOUT
        ptr_asa_out = stdout;
#endif /* INCL_STDOUT */
      } else {
        ptr_asa_out = fopen (OPTIONS->Asa_Out_File, "a");
      }
#else
      if (!strcmp (ASA_OUT, "STDOUT")) {
#if INCL_STDOUT
        ptr_asa_out = stdout;
#endif /* INCL_STDOUT */
      } else {
        ptr_asa_out = fopen (ASA_OUT, "a");
      }
#endif
      fprintf (ptr_asa_out, "\n\n\t\t number_asa_open = %d\n",
               number_asa_open);
      fflush (ptr_asa_out);
    }
#endif /* ASA_PRINT */
  } else {
    ++recursive_asa_open;
#if ASA_PRINT
    if (recursive_asa_open == 1) {
      /* open the output file */
#if ASA_SAVE
#if USER_ASA_OUT
      if (!strcmp (OPTIONS->Asa_Out_File, "STDOUT")) {
#if INCL_STDOUT
        ptr_asa_out = stdout;
#endif /* INCL_STDOUT */
      } else {
        ptr_asa_out = fopen (OPTIONS->Asa_Out_File, "a");
      }
#else
      if (!strcmp (ASA_OUT, "STDOUT")) {
#if INCL_STDOUT
        ptr_asa_out = stdout;
#endif /* INCL_STDOUT */
      } else {
        ptr_asa_out = fopen (ASA_OUT, "a");
      }
#endif
#else /* ASA_SAVE */
#if USER_ASA_OUT
      if (!strcmp (OPTIONS->Asa_Out_File, "STDOUT")) {
#if INCL_STDOUT
        ptr_asa_out = stdout;
#endif /* INCL_STDOUT */
      } else {
        ptr_asa_out = fopen (OPTIONS->Asa_Out_File, "w");
      }
#else
      if (!strcmp (ASA_OUT, "STDOUT")) {
#if INCL_STDOUT
        ptr_asa_out = stdout;
#endif /* INCL_STDOUT */
      } else {
        ptr_asa_out = fopen (ASA_OUT, "w");
      }
#endif
#endif /* ASA_SAVE */
    } else {
#if USER_ASA_OUT
      if (!strcmp (OPTIONS->Asa_Out_File, "STDOUT")) {
#if INCL_STDOUT
        ptr_asa_out = stdout;
#endif /* INCL_STDOUT */
      } else {
        ptr_asa_out = fopen (OPTIONS->Asa_Out_File, "a");
      }
#else
      if (!strcmp (ASA_OUT, "STDOUT")) {
#if INCL_STDOUT
        ptr_asa_out = stdout;
#endif /* INCL_STDOUT */
      } else {
        ptr_asa_out = fopen (ASA_OUT, "a");
      }
#endif
      fprintf (ptr_asa_out, "\n\n\t\t recursive_asa_open = %d\n",
               recursive_asa_open);
    }
#endif /* ASA_PRINT */
  }

#if ASA_PIPE_FILE
  ptr_asa_pipe = fopen ("asa_pipe", "a");
  fprintf (ptr_asa_pipe, "%s", "%generate");
  fprintf (ptr_asa_pipe, "\t%s", "accept");
  fprintf (ptr_asa_pipe, "\t%s", "best_cost");
  VFOR (index_v)
#if INT_ALLOC
    fprintf (ptr_asa_pipe, "\t%s-%d", "best_param", index_v);
#else
#if INT_LONG
    fprintf (ptr_asa_pipe, "\t%s-%ld", "best_param", index_v);
#else
    fprintf (ptr_asa_pipe, "\t%s-%d", "best_param", index_v);
#endif
#endif
  fprintf (ptr_asa_pipe, "\t%s", "curr_cost");
  VFOR (index_v)
#if INT_ALLOC
    fprintf (ptr_asa_pipe, "\t%s-%d", "curr_param", index_v);
#else
#if INT_LONG
    fprintf (ptr_asa_pipe, "\t%s-%ld", "curr_param", index_v);
#else
    fprintf (ptr_asa_pipe, "\t%s-%d", "curr_param", index_v);
#endif
#endif
  fprintf (ptr_asa_pipe, "\t%s", "cost_temp");
  VFOR (index_v)
#if INT_ALLOC
    fprintf (ptr_asa_pipe, "\t%s-%d", "param_temp", index_v);
#else
#if INT_LONG
    fprintf (ptr_asa_pipe, "\t%s-%ld", "param_temp", index_v);
#else
    fprintf (ptr_asa_pipe, "\t%s-%d", "param_temp", index_v);
#endif
#endif
  fprintf (ptr_asa_pipe, "\t%s", "last_cost");
  fprintf (ptr_asa_pipe, "\n");
  fflush (ptr_asa_pipe);
#endif /* ASA_PIPE_FILE */

#if ASA_EXIT_ANYTIME
  if ((ptr_exit_anytime = fopen ("asa_exit_anytime", "w")) != NULL) {
    fprintf (ptr_exit_anytime, "%s\n",
             "force IMMEDIATE_EXIT by removing this file if ASA_EXIT_ANYTIME is TRUE");
    fflush (ptr_exit_anytime);
    fclose (ptr_exit_anytime);
  }
#endif /* ASA_EXIT_ANYTIME */

#if ASA_PRINT
  /* print header information as defined by user */
  print_asa_options (ptr_asa_out, OPTIONS);

#if TIME_CALC
  /* print starting time */
  print_time ("start_asa", ptr_asa_out);
#endif
  fflush (ptr_asa_out);
#endif /* ASA_PRINT */

  /* set indices and counts to 0 */
  *best_number_generated_saved =
    *number_generated =
    *recent_number_generated = *recent_number_acceptances = 0;
  *index_cost_acceptances =
    *best_number_accepted_saved =
    *number_accepted = *number_acceptances_saved = 0;
  index_cost_repeat = 0;

  OPTIONS->N_Accepted = *number_accepted;
  OPTIONS->N_Generated = *number_generated;

#if ASA_SAMPLE
  OPTIONS->N_Generated = 0;
  OPTIONS->Average_Weights = 1.0;
#endif

  /* do not calculate curvatures initially */
  *curvature_flag = FALSE;

  /* allocate storage for all parameters */
  if ((current_generated_state->parameter =
       (double *) calloc (*number_parameters, sizeof (double))) == NULL) {
    strcpy (exit_msg, "asa(): current_generated_state->parameter");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    ret1_flg = 1;
    goto RET1_asa;
  }
  if ((last_saved_state->parameter =
       (double *) calloc (*number_parameters, sizeof (double))) == NULL) {
    strcpy (exit_msg, "asa(): last_saved_state->parameter");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    ret1_flg = 1;
    goto RET1_asa;
  }
  if ((best_generated_state->parameter =
       (double *) calloc (*number_parameters, sizeof (double))) == NULL) {
    strcpy (exit_msg, "asa(): best_generated_state->parameter");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    ret1_flg = 1;
    goto RET1_asa;
  }
#if ASA_PARALLEL
  for (i_prll = 0; i_prll < OPTIONS->Gener_Block_Max; ++i_prll) {
    if ((gener_block_state[i_prll].parameter =
         (double *) calloc (*number_parameters, sizeof (double))) == NULL) {
      strcpy (exit_msg, "asa(): gener_block_state[i_prll].parameter");
      Exit_ASA (exit_msg);
      *exit_status = CALLOC_FAILED;
      ret1_flg = 1;
      goto RET1_asa;
    } else {
      ;
    }
  }
  OPTIONS->parallel_id = -1;
#endif /* ASA_PARALLEL */

  OPTIONS->Best_Cost = &(best_generated_state->cost);
  OPTIONS->Best_Parameters = best_generated_state->parameter;
  OPTIONS->Last_Cost = &(last_saved_state->cost);
  OPTIONS->Last_Parameters = last_saved_state->parameter;

  if ((initial_user_parameter_temp =
       (double *) calloc (*number_parameters, sizeof (double))) == NULL) {
    strcpy (exit_msg, "asa(): initial_user_parameter_temp");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    ret1_flg = 1;
    goto RET1_asa;
  }
  if ((index_parameter_generations =
       (ALLOC_INT *) calloc (*number_parameters,
                             sizeof (ALLOC_INT))) == NULL) {
    strcpy (exit_msg, "asa(): index_parameter_generations");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    ret1_flg = 1;
    goto RET1_asa;
  }

  /* set all temperatures */
  if ((current_user_parameter_temp =
       (double *) calloc (*number_parameters, sizeof (double))) == NULL) {
    strcpy (exit_msg, "asa(): current_user_parameter_temp");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    ret1_flg = 1;
    goto RET1_asa;
  }
#if USER_INITIAL_PARAMETERS_TEMPS
  VFOR (index_v)
    current_user_parameter_temp[index_v] =
    initial_user_parameter_temp[index_v] =
    OPTIONS->User_Parameter_Temperature[index_v];
#else
  VFOR (index_v)
    current_user_parameter_temp[index_v] =
    initial_user_parameter_temp[index_v] =
    OPTIONS->Initial_Parameter_Temperature;
#endif

  if ((temperature_scale_parameters =
       (double *) calloc (*number_parameters, sizeof (double))) == NULL) {
    strcpy (exit_msg, "asa(): temperature_scale_parameters");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    ret1_flg = 1;
    goto RET1_asa;
  }
#if ASA_QUEUE
  if (OPTIONS->Queue_Size > 0) {
    queue_size_tmp = OPTIONS->Queue_Size;
  } else {
    queue_size_tmp = 1;
  }
  if ((save_queue_flag =
       (int *) calloc (queue_size_tmp, sizeof (int))) == NULL) {
    strcpy (exit_msg, "asa(): save_queue_flag");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((save_queue_cost =
       (double *) calloc (queue_size_tmp, sizeof (double))) == NULL) {
    strcpy (exit_msg, "asa(): save_queue_cost");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((save_queue_param =
       (double *) calloc ((*number_parameters) * queue_size_tmp,
                          sizeof (double))) == NULL) {
    strcpy (exit_msg, "asa(): save_queue_param");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
#if ASA_PARALLEL
  if (OPTIONS->Queue_Size > 0) {
    queue_size_tmp = OPTIONS->Queue_Size;
  } else {
    queue_size_tmp = 1;
  }

  if ((queue_par_cost =
       (double *) calloc (OPTIONS->Gener_Block_Max,
                          sizeof (double))) == NULL) {
    strcpy (exit_msg, "asa(): queue_par_cost");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((queue_new_par =
       (int *) calloc (OPTIONS->Gener_Block_Max, sizeof (int))) == NULL) {
    strcpy (exit_msg, "asa(): queue_new_par");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((queue_v_par =
       (LONG_INT *) calloc (OPTIONS->Gener_Block_Max,
                            sizeof (LONG_INT))) == NULL) {
    strcpy (exit_msg, "asa(): queue_v_par");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((save_queue_indx_par =
       (LONG_INT *) calloc (OPTIONS->Gener_Block_Max,
                            sizeof (LONG_INT))) == NULL) {
    strcpy (exit_msg, "asa(): save_queue_indx_par");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((save_queue_test_par =
       (LONG_INT *) calloc (OPTIONS->Gener_Block_Max,
                            sizeof (LONG_INT))) == NULL) {
    strcpy (exit_msg, "asa(): save_queue_test_par");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((save_queue_par =
       (LONG_INT *) calloc (OPTIONS->Gener_Block_Max,
                            sizeof (LONG_INT))) == NULL) {
    strcpy (exit_msg, "asa(): save_queue_par");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }

  if ((save_queue_valid_state_flag_par =
       (int **) calloc (OPTIONS->Gener_Block_Max, sizeof (int *))) == NULL) {
    strcpy (exit_msg, "asa(): *save_queue_valid_state_flag_par");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((save_queue_cost_par =
       (double **) calloc (OPTIONS->Gener_Block_Max,
                           sizeof (double *))) == NULL) {
    strcpy (exit_msg, "asa(): *save_queue_cost_par");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  if ((save_queue_param_par =
       (double **) calloc (OPTIONS->Gener_Block_Max,
                           sizeof (double *))) == NULL) {
    strcpy (exit_msg, "asa(): *save_queue_param_par");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    return (-1);
  }
  for (i_prll = 0; i_prll < OPTIONS->Gener_Block_Max; ++i_prll) {
    if ((save_queue_valid_state_flag_par[i_prll] =
         (int *) calloc (queue_size_tmp, sizeof (int))) == NULL) {
      strcpy (exit_msg, "asa(): save_queue_valid_state_flag_par[i_prll]");
      Exit_ASA (exit_msg);
      *exit_status = CALLOC_FAILED;
      return (-1);
    }
    if ((save_queue_cost_par[i_prll] =
         (double *) calloc (queue_size_tmp, sizeof (double))) == NULL) {
      strcpy (exit_msg, "asa(): save_queue_cost_par[i_prll]");
      Exit_ASA (exit_msg);
      *exit_status = CALLOC_FAILED;
      return (-1);
    }
    if ((save_queue_param_par[i_prll] =
         (double *) calloc ((*number_parameters) * queue_size_tmp,
                            sizeof (double))) == NULL) {
      strcpy (exit_msg, "asa(): save_queue_param_par[i_prll]");
      Exit_ASA (exit_msg);
      *exit_status = CALLOC_FAILED;
      return (-1);
    }
  }
#endif /* ASA_PARALLEL */
#endif /* ASA_QUEUE */

#if MULTI_MIN
  if ((multi_cost =
       (double *) calloc (OPTIONS->Multi_Number + 1,
                          sizeof (double))) == NULL) {
    strcpy (exit_msg, "asa(): *multi_cost");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    ret1_flg = 1;
    goto RET1_asa;
  }
  multi_cost_qsort = multi_cost;
  if ((multi_sort =
       (int *) calloc (OPTIONS->Multi_Number + 1, sizeof (int))) == NULL) {
    strcpy (exit_msg, "asa(): *multi_sort");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    ret1_flg = 1;
    goto RET1_asa;
  }
  if ((multi_params =
       (double **) calloc (OPTIONS->Multi_Number + 1,
                           sizeof (double *))) == NULL) {
    strcpy (exit_msg, "asa(): *multi_params");
    Exit_ASA (exit_msg);
    *exit_status = CALLOC_FAILED;
    ret1_flg = 1;
    goto RET1_asa;
  }
  for (multi_index = 0; multi_index <= OPTIONS->Multi_Number; ++multi_index) {
    if ((multi_params[multi_index] =
         (double *) calloc (*number_parameters, sizeof (double))) == NULL) {
      strcpy (exit_msg, "asa(): multi_params[multi_index]");
      Exit_ASA (exit_msg);
      *exit_status = CALLOC_FAILED;
      ret1_flg = 1;
      goto RET1_asa;
    }
  }
#endif /* MULTI_MIN */
RET1_asa:
  if (ret1_flg == 1) {
#if ASA_PIPE_FILE
    fclose (ptr_asa_pipe);
#endif
    free (accepted_to_generated_ratio);
    free (best_generated_state);
    free (best_number_accepted_saved);
    free (best_number_generated_saved);
    free (current_cost_temperature);
    free (current_generated_state);
    free (curvature_flag);
    free (index_cost_acceptances);
    free (index_exit_v);
    free (initial_cost_temperature);
    free (last_saved_state);
    free (maximum_tangent);
    free (number_acceptances_saved);
    free (number_accepted);
    free (number_generated);
    free (number_invalid_generated_states);
    free (recent_number_acceptances);
    free (recent_number_generated);
    free (start_sequence);
    free (temperature_scale_cost);

    return (-1);
  }
#if USER_INITIAL_COST_TEMP
#if USER_ACCEPTANCE_TEST
  OPTIONS->Cost_Temp_Curr = OPTIONS->Cost_Temp_Init =
#endif
    *initial_cost_temperature = *current_cost_temperature =
    OPTIONS->User_Cost_Temperature[0];
#endif

  /* set parameters to the initial parameter values */
  VFOR (index_v)
    last_saved_state->parameter[index_v] =
    current_generated_state->parameter[index_v] =
    parameter_initial_final[index_v];
#if USER_ACCEPTANCE_TEST
  OPTIONS->Random_Seed = seed;
  OPTIONS->Random_Seed[0] = *seed;
  OPTIONS->User_Acceptance_Flag = TRUE;
  OPTIONS->Cost_Acceptance_Flag = FALSE;
#endif

#if ASA_PRINT
#if INT_LONG
  fprintf (ptr_asa_out, "Initial Random Seed = %ld\n\n", *seed);
#else
  fprintf (ptr_asa_out, "Initial Random Seed = %d\n\n", *seed);
#endif
#endif /* ASA_PRINT */

  /* save initial user value of OPTIONS->Sequential_Parameters */
  *start_sequence = OPTIONS->Sequential_Parameters;

#if ASA_PRINT
#if INT_ALLOC
  fprintf (ptr_asa_out, "*number_parameters = %d\n\n", *number_parameters);
#else
#if INT_LONG
  fprintf (ptr_asa_out, "*number_parameters = %ld\n\n", *number_parameters);
#else
  fprintf (ptr_asa_out, "*number_parameters = %d\n\n", *number_parameters);
#endif
#endif

  /* print the min, max, current values, and types of parameters */
  fprintf (ptr_asa_out,
           "index_v parameter_minimum parameter_maximum parameter_value parameter_type \n");

#if ASA_PRINT_INTERMED
  VFOR (index_v) fprintf (ptr_asa_out,
#if INT_ALLOC
                          " %-8d %-*.*g \t\t %-*.*g \t %-*.*g %-7d\n",
#else
#if INT_LONG
                          " %-8ld %-*.*g \t\t %-*.*g \t %-*.*g %-7d\n",
#else
                          " %-8d %-*.*g \t\t %-*.*g \t %-*.*g %-7d\n",
#endif
#endif
                          index_v,
                          G_FIELD, G_PRECISION, parameter_minimum[index_v],
                          G_FIELD, G_PRECISION, parameter_maximum[index_v],
                          G_FIELD, G_PRECISION,
                          current_generated_state->parameter[index_v],
                          parameter_type[index_v]);

  fprintf (ptr_asa_out, "\n\n");
#endif /* ASA_PRINT_INTERMED */
  /* Print out user-defined OPTIONS */

#if DELTA_PARAMETERS
  VFOR (index_v) fprintf (ptr_asa_out,
#if INT_ALLOC
                          "OPTIONS->User_Delta_Parameter[%d] = %*.*g\n",
#else
#if INT_LONG
                          "OPTIONS->User_Delta_Parameter[%ld] = %*.*g\n",
#else
                          "OPTIONS->User_Delta_Parameter[%d] = %*.*g\n",
#endif
#endif
                          index_v,
                          G_FIELD, G_PRECISION,
                          OPTIONS->User_Delta_Parameter[index_v]);
  fprintf (ptr_asa_out, "\n");
#endif /* DELTA_PARAMETERS */

#if QUENCH_PARAMETERS
  VFOR (index_v) fprintf (ptr_asa_out,
#if INT_ALLOC
                          "OPTIONS->User_Quench_Param_Scale[%d] = %*.*g\n",
#else
#if INT_LONG
                          "OPTIONS->User_Quench_Param_Scale[%ld] = %*.*g\n",
#else
                          "OPTIONS->User_Quench_Param_Scale[%d] = %*.*g\n",
#endif
#endif
                          index_v,
                          G_FIELD, G_PRECISION,
                          OPTIONS->User_Quench_Param_Scale[index_v]);
#endif /* QUENCH_PARAMETERS */

#if QUENCH_COST
  fprintf (ptr_asa_out,
           "\nOPTIONS->User_Quench_Cost_Scale = %*.*g\n\n",
           G_FIELD, G_PRECISION, OPTIONS->User_Quench_Cost_Scale[0]);
#endif /* QUENCH_COST */

#if USER_INITIAL_PARAMETERS_TEMPS
  VFOR (index_v) fprintf (ptr_asa_out,
#if INT_ALLOC
                          "OPTIONS->User_Parameter_Temperature[%d] = %*.*g\n",
#else
#if INT_LONG
                          "OPTIONS->User_Parameter_Temperature[%ld] = %*.*g\n",
#else
                          "OPTIONS->User_Parameter_Temperature[%d] = %*.*g\n",
#endif
#endif
                          index_v,
                          G_FIELD, G_PRECISION,
                          initial_user_parameter_temp[index_v]);
#endif /* USER_INITIAL_PARAMETERS_TEMPS */

#if RATIO_TEMPERATURE_SCALES
  VFOR (index_v) fprintf (ptr_asa_out,
#if INT_ALLOC
                          "OPTIONS->User_Temperature_Ratio[%d] = %*.*g\n",
#else
#if INT_LONG
                          "OPTIONS->User_Temperature_Ratio[%ld] = %*.*g\n",
#else
                          "OPTIONS->User_Temperature_Ratio[%d] = %*.*g\n",
#endif
#endif
                          index_v,
                          G_FIELD, G_PRECISION,
                          OPTIONS->User_Temperature_Ratio[index_v]);
#endif /* RATIO_TEMPERATURE_SCALES */

#if USER_INITIAL_COST_TEMP
  fprintf (ptr_asa_out,
           "OPTIONS->User_Cost_Temperature[0] = %*.*g\n",
           G_FIELD, G_PRECISION, *initial_cost_temperature);
#endif /* USER_INITIAL_COST_TEMP */

  fflush (ptr_asa_out);
#endif /* ASA_PRINT */

#if MULTI_MIN
#if ASA_PRINT
  fprintf (ptr_asa_out, "\n");
  fprintf (ptr_asa_out, "Multi_Number = %d\n", OPTIONS->Multi_Number);
  fprintf (ptr_asa_out, "Multi_Specify = %d\n", OPTIONS->Multi_Specify);
#if ASA_RESOLUTION
#else
  VFOR (index_v) {
    fprintf (ptr_asa_out,
#if INT_ALLOC
             "Multi_Grid[%d] = %*.*g\n",
#else
#if INT_LONG
             "Multi_Grid[%ld] = %*.*g\n",
#else
             "Multi_Grid[%d] = %*.*g\n",
#endif
#endif
             index_v, G_FIELD, G_PRECISION, OPTIONS->Multi_Grid[index_v]);
  }
#endif /* ASA_RESOLUTION */
  fprintf (ptr_asa_out, "\n");
  fflush (ptr_asa_out);
#endif /* ASA_PRINT */
#endif /* MULTI_MIN */

#if ASA_PARALLEL
#if ASA_PRINT
  fprintf (ptr_asa_out,
#if INT_LONG
           "Initial ASA_PARALLEL OPTIONS->\n\t Gener_Block = %ld\n \t Gener_Block_Max = %ld\n \t Gener_Mov_Avr= %d\n\n",
#else
           "ASA_PARALLEL OPTIONS->\n\t Gener_Block = %d\n \t Gener_Block_Max = %d\n \t Gener_Mov_Avr= %d\n\n",
#endif
           OPTIONS->Gener_Block, OPTIONS->Gener_Block_Max,
           OPTIONS->Gener_Mov_Avr);
#endif
#endif /* ASA_PARALLEL */

#if ASA_SAMPLE
#if ASA_PRINT
  fprintf (ptr_asa_out, "OPTIONS->Limit_Weights = %*.*g\n\n",
           G_FIELD, G_PRECISION, OPTIONS->Limit_Weights);
#endif
#endif
  if (OPTIONS->Asa_Recursive_Level > asa_recursive_max)
    asa_recursive_max = OPTIONS->Asa_Recursive_Level;
#if ASA_SAVE
  if (OPTIONS->Asa_Recursive_Level > 0)
    sprintf (asa_save_comm, "asa_save_%d", OPTIONS->Asa_Recursive_Level);
  else
    sprintf (asa_save_comm, "asa_save");
  if ((ptr_save = fopen (asa_save_comm, "r")) == NULL) {
    asa_read = FALSE;
  } else {
#if ASA_PRINT
    fprintf (ptr_asa_out, "\n\n\trestart after ASA_SAVE\n\n");
#endif
    fclose (ptr_save);
    asa_read = TRUE;

    /* give some value to avoid any problems with other OPTIONS */
#if USER_ACCEPTANCE_TEST
    OPTIONS->Cost_Temp_Curr = OPTIONS->Cost_Temp_Init =
#endif
      current_generated_state->cost
      = *initial_cost_temperature = *current_cost_temperature = 3.1416;
  }
#endif

  tmp_var_int = cost_function_test (current_generated_state->cost,
                                    current_generated_state->parameter,
                                    parameter_minimum,
                                    parameter_maximum, number_parameters,
                                    xnumber_parameters);

  /* compute temperature scales */
  tmp_var_db1 = -F_LOG ((OPTIONS->Temperature_Ratio_Scale));
  tmp_var_db2 = F_LOG (OPTIONS->Temperature_Anneal_Scale);
  temperature_scale =
    tmp_var_db1 * F_EXP (-tmp_var_db2 / *xnumber_parameters);

  /* set here in case not used */
  tmp_var_db = ZERO;

#if QUENCH_PARAMETERS
#if RATIO_TEMPERATURE_SCALES
  VFOR (index_v) temperature_scale_parameters[index_v] = tmp_var_db1 * F_EXP
#if QUENCH_PARAMETERS_SCALE
    (-(tmp_var_db2 * OPTIONS->User_Quench_Param_Scale[index_v])
#else
    (-(tmp_var_db2)
#endif
     / *xnumber_parameters)
    * OPTIONS->User_Temperature_Ratio[index_v];
#else
  VFOR (index_v) temperature_scale_parameters[index_v] = tmp_var_db1 * F_EXP
#if QUENCH_PARAMETERS_SCALE
    (-(tmp_var_db2 * OPTIONS->User_Quench_Param_Scale[index_v])
#else
    (-(tmp_var_db2)
#endif
     / *xnumber_parameters);
#endif /* RATIO_TEMPERATURE_SCALES */
#else /* QUENCH_PARAMETERS */
#if RATIO_TEMPERATURE_SCALES
  VFOR (index_v)
    temperature_scale_parameters[index_v] =
    tmp_var_db1 * F_EXP (-(tmp_var_db2) / *xnumber_parameters)
    * OPTIONS->User_Temperature_Ratio[index_v];
#else
  VFOR (index_v)
    temperature_scale_parameters[index_v] =
    tmp_var_db1 * F_EXP (-(tmp_var_db2) / *xnumber_parameters);
#endif /* RATIO_TEMPERATURE_SCALES */
#endif /* QUENCH_PARAMETERS */

#if USER_ACCEPTANCE_TEST
  OPTIONS->Cost_Temp_Scale =
#endif
    *temperature_scale_cost =
#if QUENCH_COST
#if QUENCH_COST_SCALE
    tmp_var_db1 * F_EXP (-(tmp_var_db2 * OPTIONS->User_Quench_Cost_Scale[0])
#else
    tmp_var_db1 * F_EXP (-(tmp_var_db2)
#endif
                         / *xnumber_parameters) *
    OPTIONS->Cost_Parameter_Scale_Ratio;
#else /* QUENCH_COST */
    tmp_var_db1 * F_EXP (-(tmp_var_db2)
                         / *xnumber_parameters) *
    OPTIONS->Cost_Parameter_Scale_Ratio;
#endif /* QUENCH_COST */

  /* set the initial index of parameter generations to 1 */
  VFOR (index_v) index_parameter_generations[index_v] = 1;

  /* test user-defined options before calling cost function */
  tmp_var_int = asa_test_asa_options (seed,
                                      parameter_initial_final,
                                      parameter_minimum,
                                      parameter_maximum,
                                      tangents,
                                      curvature,
                                      number_parameters,
                                      parameter_type,
                                      valid_state_generated_flag,
                                      exit_status, ptr_asa_out, OPTIONS);
  if (tmp_var_int > 0) {
#if ASA_PRINT
    fprintf (ptr_asa_out, "total number invalid OPTIONS = %d\n", tmp_var_int);
    fflush (ptr_asa_out);
#endif
    *exit_status = INVALID_USER_INPUT;
    goto EXIT_asa;
  }
#if USER_INITIAL_COST_TEMP
#else
#if ASA_SAVE
  if (asa_read == TRUE)
    OPTIONS->Number_Cost_Samples = 1;
#endif
  /* calculate the average cost over samplings of the cost function */
  if (OPTIONS->Number_Cost_Samples < -1) {
    tmp_var_db1 = ZERO;
    tmp_var_db2 = ZERO;
    tmp_var_int = -OPTIONS->Number_Cost_Samples;
  } else {
    tmp_var_db1 = ZERO;
    tmp_var_int = OPTIONS->Number_Cost_Samples;
  }

  OPTIONS->Locate_Cost = 0;     /* initial cost temp */

  for (index_cost_constraint = 0;
       index_cost_constraint < tmp_var_int; ++index_cost_constraint) {
    *number_invalid_generated_states = 0;
    repeated_invalid_states = 0;
    OPTIONS->Sequential_Parameters = *start_sequence - 1;
    do {
#if ASA_EXIT_ANYTIME
      if ((ptr_exit_anytime = fopen ("asa_exit_anytime", "r")) == NULL) {
        *exit_status = IMMEDIATE_EXIT;
        goto EXIT_asa;
      } else {
        fclose (ptr_exit_anytime);
      }
#endif /* ASA_EXIT_ANYTIME */
      ++(*number_invalid_generated_states);
      generate_flg = generate_new_state (user_random_generator,
                                         seed,
                                         parameter_minimum,
                                         parameter_maximum,
                                         current_user_parameter_temp,
#if USER_GENERATING_FUNCTION
                                         initial_user_parameter_temp,
                                         temperature_scale_parameters,
#endif
                                         number_parameters,
                                         parameter_type,
                                         current_generated_state,
                                         last_saved_state, OPTIONS);
      *valid_state_generated_flag = TRUE;
#if USER_ACCEPTANCE_TEST
      OPTIONS->User_Acceptance_Flag = TRUE;
      OPTIONS->Cost_Acceptance_Flag = FALSE;
#endif
      tmp_var_db =
        user_cost_function (current_generated_state->parameter,
                            parameter_minimum,
                            parameter_maximum,
                            tangents,
                            curvature,
                            number_parameters,
                            parameter_type,
                            valid_state_generated_flag, exit_status, OPTIONS);
      if (cost_function_test
          (tmp_var_db, current_generated_state->parameter,
           parameter_minimum, parameter_maximum, number_parameters,
           xnumber_parameters) == 0) {
        *exit_status = INVALID_COST_FUNCTION;
        goto EXIT_asa;
      }

      ++repeated_invalid_states;
      if (repeated_invalid_states > OPTIONS->Limit_Invalid_Generated_States) {
        *exit_status = TOO_MANY_INVALID_STATES;
        goto EXIT_asa;
      }
    }
    while (*valid_state_generated_flag == FALSE);
    --(*number_invalid_generated_states);

    if (OPTIONS->Number_Cost_Samples < -1) {
      tmp_var_db1 += tmp_var_db;
      tmp_var_db2 += (tmp_var_db * tmp_var_db);
    } else {
      tmp_var_db1 += fabs (tmp_var_db);
    }
  }
  if (OPTIONS->Number_Cost_Samples < -1) {
    tmp_var_db1 /= (double) tmp_var_int;
    tmp_var_db2 /= (double) tmp_var_int;
    tmp_var_db = sqrt (fabs ((tmp_var_db2 - tmp_var_db1 * tmp_var_db1)
                             * ((double) tmp_var_int
                                / ((double) tmp_var_int - ONE))))
      + (double) EPS_DOUBLE;
  } else {
    tmp_var_db = tmp_var_db1 / (double) tmp_var_int;
  }

#if USER_ACCEPTANCE_TEST
  OPTIONS->Cost_Temp_Curr = OPTIONS->Cost_Temp_Init =
#endif
    *initial_cost_temperature = *current_cost_temperature = tmp_var_db;
  if (fabs (*initial_cost_temperature) <= SMALL_FLOAT) {
    *initial_cost_temperature = *current_cost_temperature = 2.718;
#if ASA_PRINT
    fprintf (ptr_asa_out,
             "*** invalid too small cost temp = %g, set to = %g ***\n",
             tmp_var_db, *initial_cost_temperature);
    fflush (ptr_asa_out);
#endif
  }
#endif /* USER_INITIAL_COST_TEMP */

  /* set all parameters to the initial parameter values */
  VFOR (index_v)
    best_generated_state->parameter[index_v] =
    last_saved_state->parameter[index_v] =
    current_generated_state->parameter[index_v] =
    parameter_initial_final[index_v];

  OPTIONS->Locate_Cost = 1;     /* initial cost value */

  /* if using user's initial parameters */
  if (OPTIONS->User_Initial_Parameters == TRUE) {
    *valid_state_generated_flag = TRUE;
#if USER_ACCEPTANCE_TEST
    OPTIONS->User_Acceptance_Flag = TRUE;
    OPTIONS->Cost_Acceptance_Flag = FALSE;
#endif
#if ASA_SAVE
    if (asa_read == FALSE)
#endif
      current_generated_state->cost =
        user_cost_function (current_generated_state->parameter,
                            parameter_minimum,
                            parameter_maximum,
                            tangents,
                            curvature,
                            number_parameters,
                            parameter_type,
                            valid_state_generated_flag, exit_status, OPTIONS);
    if (cost_function_test
        (current_generated_state->cost, current_generated_state->parameter,
         parameter_minimum, parameter_maximum, number_parameters,
         xnumber_parameters) == 0) {
      *exit_status = INVALID_COST_FUNCTION;
      goto EXIT_asa;
    }
#if ASA_PRINT
    if (*valid_state_generated_flag == FALSE)
      fprintf (ptr_asa_out,
               "user's initial parameters generated FALSE *valid_state_generated_flag\n");
#endif
  } else {
    /* let asa generate valid initial parameters */
    repeated_invalid_states = 0;
    OPTIONS->Sequential_Parameters = *start_sequence - 1;
    do {
#if ASA_EXIT_ANYTIME
      if ((ptr_exit_anytime = fopen ("asa_exit_anytime", "r")) == NULL) {
        *exit_status = IMMEDIATE_EXIT;
        goto EXIT_asa;
      } else {
        fclose (ptr_exit_anytime);
      }
#endif /* ASA_EXIT_ANYTIME */
      ++(*number_invalid_generated_states);
      generate_flg = generate_new_state (user_random_generator,
                                         seed,
                                         parameter_minimum,
                                         parameter_maximum,
                                         current_user_parameter_temp,
#if USER_GENERATING_FUNCTION
                                         initial_user_parameter_temp,
                                         temperature_scale_parameters,
#endif
                                         number_parameters,
                                         parameter_type,
                                         current_generated_state,
                                         last_saved_state, OPTIONS);
      *valid_state_generated_flag = TRUE;
#if USER_ACCEPTANCE_TEST
      OPTIONS->User_Acceptance_Flag = TRUE;
      OPTIONS->Cost_Acceptance_Flag = FALSE;
#endif
      current_generated_state->cost =
        user_cost_function (current_generated_state->parameter,
                            parameter_minimum,
                            parameter_maximum,
                            tangents,
                            curvature,
                            number_parameters,
                            parameter_type,
                            valid_state_generated_flag, exit_status, OPTIONS);
      if (cost_function_test
          (current_generated_state->cost,
           current_generated_state->parameter, parameter_minimum,
           parameter_maximum, number_parameters, xnumber_parameters) == 0) {
        *exit_status = INVALID_COST_FUNCTION;
        goto EXIT_asa;
      }
      ++repeated_invalid_states;
      if (repeated_invalid_states > OPTIONS->Limit_Invalid_Generated_States) {
        *exit_status = TOO_MANY_INVALID_STATES;
        goto EXIT_asa;
      }
    }
    while (*valid_state_generated_flag == FALSE);
    --(*number_invalid_generated_states);
  }                             /* OPTIONS->User_Initial_Parameters */

  /* set all states to the last one generated */
  VFOR (index_v) {
#if DROPPED_PARAMETERS
    /* ignore parameters that have too small a range */
    if (PARAMETER_RANGE_TOO_SMALL (index_v))
      continue;
#endif
    best_generated_state->parameter[index_v] =
      last_saved_state->parameter[index_v] =
      current_generated_state->parameter[index_v];
  }

  /* set all costs to the last one generated */
  best_generated_state->cost = last_saved_state->cost =
    current_generated_state->cost;

  *accepted_to_generated_ratio = ONE;

  /* do not calculate curvatures initially */
  *curvature_flag = FALSE;

#if ASA_PRINT
  fprintf (ptr_asa_out,
           "temperature_scale = %*.*g\n",
           G_FIELD, G_PRECISION, temperature_scale);
#if RATIO_TEMPERATURE_SCALES
#if ASA_PRINT_INTERMED
  VFOR (index_v) {
    fprintf (ptr_asa_out,
#if INT_ALLOC
             "temperature_scale_parameters[%d] = %*.*g\n",
#else
#if INT_LONG
             "temperature_scale_parameters[%ld] = %*.*g\n",
#else
             "temperature_scale_parameters[%d] = %*.*g\n",
#endif
#endif
             index_v,
             G_FIELD, G_PRECISION, temperature_scale_parameters[index_v]);
  }
#endif
#else
  fprintf (ptr_asa_out,
           "temperature_scale_parameters[0] = %*.*g\n",
           G_FIELD, G_PRECISION, temperature_scale_parameters[0]);
#endif /* RATIO_TEMPERATURE_SCALES */
  fprintf (ptr_asa_out,
           "*temperature_scale_cost = %*.*g\n",
           G_FIELD, G_PRECISION, *temperature_scale_cost);
  fprintf (ptr_asa_out, "\n\n");

#if ASA_PRINT_INTERMED
  print_state (parameter_minimum,
               parameter_maximum,
               tangents,
               curvature,
               current_cost_temperature,
               current_user_parameter_temp,
               accepted_to_generated_ratio,
               number_parameters,
               curvature_flag,
               number_accepted,
               index_cost_acceptances,
               number_generated,
               number_invalid_generated_states,
               last_saved_state, best_generated_state, ptr_asa_out, OPTIONS);
#endif
  fprintf (ptr_asa_out, "\n");

  fflush (ptr_asa_out);
#endif

#if ASA_SAMPLE
#if ASA_PRINT
  fprintf (ptr_asa_out,
           ":SAMPLE:   n_accept   cost        cost_temp    bias_accept    aver_weight\n");
  fprintf (ptr_asa_out,
           ":SAMPLE:   index      param[]     temp[]       bias_gener[]   range[]\n");
#endif
#endif

  /* reset the current cost and the number of generations performed */
  *number_invalid_generated_states = 0;
  *best_number_generated_saved =
    *number_generated = *recent_number_generated = 0;
  OPTIONS->N_Generated = *number_generated;
  VFOR (index_v) {
    /* ignore parameters that have too small a range */
    if (PARAMETER_RANGE_TOO_SMALL (index_v))
      continue;
    index_parameter_generations[index_v] = 1;
  }
#if USER_ACCEPTANCE_TEST
  OPTIONS->User_Acceptance_Flag = FALSE;
  OPTIONS->Cost_Acceptance_Flag = FALSE;
#endif

#if ASA_QUEUE
#if ASA_PRINT
#if INT_ALLOC
  fprintf (ptr_asa_out, "OPTIONS->Queue_Size = %d\n", OPTIONS->Queue_Size);
#else
#if INT_LONG
  fprintf (ptr_asa_out, "OPTIONS->Queue_Size = %ld\n", OPTIONS->Queue_Size);
#else
  fprintf (ptr_asa_out, "OPTIONS->Queue_Size = %d\n", OPTIONS->Queue_Size);
#endif
#endif
  VFOR (index_v) {
    fprintf (ptr_asa_out,
#if INT_ALLOC
             "Queue_Resolution[%d] = %*.*g\n",
#else
#if INT_LONG
             "Queue_Resolution[%ld] = %*.*g\n",
#else
             "Queue_Resolution[%d] = %*.*g\n",
#endif
#endif
             index_v,
             G_FIELD, G_PRECISION, OPTIONS->Queue_Resolution[index_v]);
  }
#endif /* ASA_PRINT */

  /* fill arrays to check allocated memory */
  for (queue = 0; queue < (LONG_INT) queue_size_tmp; ++queue) {
    VFOR (index_v) {
      if (PARAMETER_RANGE_TOO_SMALL (index_v)) {
        continue;
      }
      queue_v = index_v + queue * (LONG_INT) (*number_parameters);
      save_queue_param[queue_v] = current_generated_state->parameter[index_v];
    }
    save_queue_cost[queue] = current_generated_state->cost;
    save_queue_flag[queue] = *valid_state_generated_flag;
  }
  save_queue = save_queue_indx = 0;
#if ASA_PARALLEL
  for (i_prll = 0; i_prll < OPTIONS->Gener_Block_Max; ++i_prll) {
    for (queue = 0; queue < (LONG_INT) queue_size_tmp; ++queue) {
      VFOR (index_v) {
        if (PARAMETER_RANGE_TOO_SMALL (index_v)) {
          continue;
        }
        queue_v_par[i_prll] =
          index_v + queue * (LONG_INT) (*number_parameters);
        save_queue_param_par[i_prll][queue_v_par[i_prll]] =
          current_generated_state->parameter[index_v];
      }
      save_queue_cost_par[i_prll][queue] = current_generated_state->cost;
      save_queue_valid_state_flag_par[i_prll][queue] =
        *valid_state_generated_flag;
    }
    save_queue_par[i_prll] = save_queue_indx_par[i_prll] = 0;
  }
#endif /* ASA_PARALLEL */
#endif /* ASA_QUEUE */

#if ASA_RESOLUTION
#if ASA_PRINT
  VFOR (index_v) {
    fprintf (ptr_asa_out,
#if INT_ALLOC
             "Coarse_Resolution[%d] = %*.*g\n",
#else
#if INT_LONG
             "Coarse_Resolution[%ld] = %*.*g\n",
#else
             "Coarse_Resolution[%d] = %*.*g\n",
#endif
#endif
             index_v,
             G_FIELD, G_PRECISION, OPTIONS->Coarse_Resolution[index_v]);
  }
#endif /* ASA_PRINT */
#endif /* ASA_RESOLUTION */

#if MULTI_MIN
  multi_sort[OPTIONS->Multi_Number] = OPTIONS->Multi_Number;
  multi_cost[OPTIONS->Multi_Number] = current_generated_state->cost;
  VFOR (index_v) {
    multi_params[OPTIONS->Multi_Number][index_v] =
      current_generated_state->parameter[index_v];
  }
  for (multi_index = 0; multi_index < OPTIONS->Multi_Number; ++multi_index) {
    multi_sort[multi_index] = multi_index;
    multi_cost[multi_index] = OPTIONS->Multi_Cost[multi_index] =
      current_generated_state->cost;
    VFOR (index_v) {
      multi_params[multi_index][index_v] =
        OPTIONS->Multi_Params[multi_index][index_v] =
        current_generated_state->parameter[index_v];
    }
  }
#endif /* MULTI_MIN */

  /* this test is after MULTI_MIN so that params are not all just set to 0 */
  if (*initial_cost_temperature < (double) EPS_DOUBLE) {
#if ASA_PRINT
    fprintf (ptr_asa_out, "*initial_cost_temperature (= %g) < EPS_DOUBLE\n",
             *initial_cost_temperature);
    fflush (ptr_asa_out);
#endif
    *exit_status = INVALID_COST_FUNCTION;
    goto EXIT_asa;
  }

  OPTIONS->Sequential_Parameters = *start_sequence - 1;

  /* MAIN ANNEALING LOOP */
  while (((*number_accepted <= OPTIONS->Limit_Acceptances)
          || (OPTIONS->Limit_Acceptances == 0))
         && ((*number_generated <= OPTIONS->Limit_Generated)
             || (OPTIONS->Limit_Generated == 0))) {

    tmp_var_db1 = -F_LOG ((OPTIONS->Temperature_Ratio_Scale));

    /* compute temperature scales */
    tmp_var_db2 = F_LOG (OPTIONS->Temperature_Anneal_Scale);
    temperature_scale = tmp_var_db1 *
      F_EXP (-tmp_var_db2 / *xnumber_parameters);

#if QUENCH_PARAMETERS
#if RATIO_TEMPERATURE_SCALES
    VFOR (index_v)
      temperature_scale_parameters[index_v] = tmp_var_db1 * F_EXP
#if QUENCH_PARAMETERS_SCALE
      (-(tmp_var_db2 * OPTIONS->User_Quench_Param_Scale[index_v])
#else
      (-(tmp_var_db2)
#endif
       / *xnumber_parameters)
      * OPTIONS->User_Temperature_Ratio[index_v];
#else
    VFOR (index_v)
      temperature_scale_parameters[index_v] = tmp_var_db1 * F_EXP
#if QUENCH_PARAMETERS_SCALE
      (-(tmp_var_db2 * OPTIONS->User_Quench_Param_Scale[index_v])
#else
      (-(tmp_var_db2)
#endif
       / *xnumber_parameters);
#endif /* RATIO_TEMPERATURE_SCALES */
#else /* QUENCH_PARAMETERS */
#if RATIO_TEMPERATURE_SCALES
    VFOR (index_v)
      temperature_scale_parameters[index_v] =
      tmp_var_db1 * F_EXP (-(tmp_var_db2) / *xnumber_parameters)
      * OPTIONS->User_Temperature_Ratio[index_v];
#else
    VFOR (index_v)
      temperature_scale_parameters[index_v] =
      tmp_var_db1 * F_EXP (-(tmp_var_db2) / *xnumber_parameters);
#endif /* RATIO_TEMPERATURE_SCALES */
#endif /* QUENCH_PARAMETERS */

#if USER_ACCEPTANCE_TEST
    OPTIONS->Cost_Temp_Scale =
#endif
      *temperature_scale_cost =
#if QUENCH_COST
#if QUENCH_COST_SCALE
      tmp_var_db1 * F_EXP (-(tmp_var_db2 * OPTIONS->User_Quench_Cost_Scale[0])
#else
      tmp_var_db1 * F_EXP (-(tmp_var_db2)
#endif
                           / *xnumber_parameters) *
      OPTIONS->Cost_Parameter_Scale_Ratio;
#else /* QUENCH_COST */
      tmp_var_db1 * F_EXP (-(tmp_var_db2)
                           / *xnumber_parameters) *
      OPTIONS->Cost_Parameter_Scale_Ratio;
#endif /* QUENCH_COST */

    /* CALCULATE NEW TEMPERATURES */

    /* calculate new parameter temperatures */
    VFOR (index_v) {
      /* skip parameters with too small a range */
      if (PARAMETER_RANGE_TOO_SMALL (index_v))
        continue;

      log_new_temperature_ratio =
        -temperature_scale_parameters[index_v] *
        F_POW ((double) index_parameter_generations[index_v],
#if QUENCH_PARAMETERS
               OPTIONS->User_Quench_Param_Scale[index_v]
#else /* QUENCH_PARAMETERS */
               ONE
#endif /* QUENCH_PARAMETERS */
               / *xnumber_parameters);
      /* check (and correct) for too large an exponent */
      log_new_temperature_ratio = EXPONENT_CHECK (log_new_temperature_ratio);
      current_user_parameter_temp[index_v] =
        initial_user_parameter_temp[index_v]
        * F_EXP (log_new_temperature_ratio);

#if NO_PARAM_TEMP_TEST
      if (current_user_parameter_temp[index_v] < (double) EPS_DOUBLE)
        current_user_parameter_temp[index_v] = (double) EPS_DOUBLE;
#else
      /* check for too small a parameter temperature */
      if (current_user_parameter_temp[index_v] < (double) EPS_DOUBLE) {
        *exit_status = P_TEMP_TOO_SMALL;
        *index_exit_v = index_v;
        goto EXIT_asa;
      }
#endif
    }

    /* calculate new cost temperature */
    log_new_temperature_ratio =
      -*temperature_scale_cost * F_POW ((double) *index_cost_acceptances,
#if QUENCH_COST
                                        OPTIONS->User_Quench_Cost_Scale[0]
#else
                                        ONE
#endif
                                        / *xnumber_parameters);
    log_new_temperature_ratio = EXPONENT_CHECK (log_new_temperature_ratio);
#if USER_ACCEPTANCE_TEST
    OPTIONS->Cost_Temp_Curr = OPTIONS->Cost_Temp_Init =
#endif
      *current_cost_temperature = *initial_cost_temperature
      * F_EXP (log_new_temperature_ratio);

#if NO_COST_TEMP_TEST
    if (*current_cost_temperature < (double) EPS_DOUBLE)
#if USER_ACCEPTANCE_TEST
      OPTIONS->Cost_Temp_Curr =
#endif
        *current_cost_temperature = (double) EPS_DOUBLE;
#else
    /* check for too small a cost temperature */
    if (*current_cost_temperature < (double) EPS_DOUBLE) {
      *exit_status = C_TEMP_TOO_SMALL;
      goto EXIT_asa;
    }
#endif

#if ASA_SAVE
    if (asa_read == TRUE && OPTIONS->Asa_Recursive_Level == asa_recursive_max) {
      if (OPTIONS->Asa_Recursive_Level > 0)
        sprintf (asa_save_comm, "asa_save_%d", OPTIONS->Asa_Recursive_Level);
      else
        sprintf (asa_save_comm, "asa_save");
      ptr_save = fopen (asa_save_comm, "r");

      fread (number_parameters, sizeof (ALLOC_INT), 1, ptr_save);
      fread (xnumber_parameters, sizeof (double), 1, ptr_save);
      fread (parameter_minimum, sizeof (double),
             *number_parameters, ptr_save);
      fread (parameter_maximum, sizeof (double),
             *number_parameters, ptr_save);
      fread (tangents, sizeof (double), *number_parameters, ptr_save);
      fread (current_user_parameter_temp, sizeof (double),
             *number_parameters, ptr_save);
      fread (initial_user_parameter_temp, sizeof (double),
             *number_parameters, ptr_save);
      fread (temperature_scale_parameters, sizeof (double),
             *number_parameters, ptr_save);

      fread (parameter_type, sizeof (int), *number_parameters, ptr_save);
      fread (&index_cost_repeat, sizeof (int), 1, ptr_save);
      fread (&asa_open, sizeof (int), 1, ptr_save);
      fread (&number_asa_open, sizeof (int), 1, ptr_save);
      fread (&recursive_asa_open, sizeof (int), 1, ptr_save);

      fread (current_cost_temperature, sizeof (double), 1, ptr_save);
      fread (initial_cost_temperature, sizeof (double), 1, ptr_save);
      fread (temperature_scale_cost, sizeof (double), 1, ptr_save);
      fread (accepted_to_generated_ratio, sizeof (double), 1, ptr_save);

      fread (curvature_flag, sizeof (int), 1, ptr_save);

      fread (seed, sizeof (LONG_INT), 1, ptr_save);
      fread (number_generated, sizeof (LONG_INT), 1, ptr_save);
      fread (number_accepted, sizeof (LONG_INT), 1, ptr_save);
      fread (number_acceptances_saved, sizeof (LONG_INT), 1, ptr_save);
      fread (recent_number_acceptances, sizeof (LONG_INT), 1, ptr_save);
      fread (recent_number_generated, sizeof (LONG_INT), 1, ptr_save);
      fread (number_invalid_generated_states, sizeof (LONG_INT), 1, ptr_save);
      fread (index_cost_acceptances, sizeof (LONG_INT), 1, ptr_save);
      fread (best_number_generated_saved, sizeof (LONG_INT), 1, ptr_save);
      fread (best_number_accepted_saved, sizeof (LONG_INT), 1, ptr_save);

      fread (index_parameter_generations, sizeof (LONG_INT),
             *number_parameters, ptr_save);

      fread (current_generated_state->parameter,
             sizeof (double), *number_parameters, ptr_save);
      fread (last_saved_state->parameter,
             sizeof (double), *number_parameters, ptr_save);
      fread (best_generated_state->parameter,
             sizeof (double), *number_parameters, ptr_save);
      fread (&(current_generated_state->cost), sizeof (double), 1, ptr_save);
      fread (&(last_saved_state->cost), sizeof (double), 1, ptr_save);
      fread (&(best_generated_state->cost), sizeof (double), 1, ptr_save);

      fread (&(OPTIONS->Limit_Acceptances), sizeof (LONG_INT), 1, ptr_save);
      fread (&(OPTIONS->Limit_Generated), sizeof (LONG_INT), 1, ptr_save);
      fread (&(OPTIONS->Limit_Invalid_Generated_States), sizeof (int),
             1, ptr_save);
      fread (&(OPTIONS->Accepted_To_Generated_Ratio), sizeof (double),
             1, ptr_save);
      fread (&(OPTIONS->Cost_Precision), sizeof (double), 1, ptr_save);
      fread (&(OPTIONS->Maximum_Cost_Repeat), sizeof (int), 1, ptr_save);
      fread (&(OPTIONS->Number_Cost_Samples), sizeof (int), 1, ptr_save);
      fread (&(OPTIONS->Temperature_Ratio_Scale), sizeof (double),
             1, ptr_save);
      fread (&(OPTIONS->Cost_Parameter_Scale_Ratio), sizeof (double),
             1, ptr_save);
      fread (&(OPTIONS->Temperature_Anneal_Scale), sizeof (double),
             1, ptr_save);
      fread (&(OPTIONS->Include_Integer_Parameters), sizeof (int),
             1, ptr_save);
      fread (&(OPTIONS->User_Initial_Parameters), sizeof (int), 1, ptr_save);
      fread (&(OPTIONS->Sequential_Parameters), sizeof (ALLOC_INT), 1,
             ptr_save);
      fread (&(OPTIONS->Initial_Parameter_Temperature), sizeof (double), 1,
             ptr_save);
      fread (&(OPTIONS->Acceptance_Frequency_Modulus), sizeof (int), 1,
             ptr_save);
      fread (&(OPTIONS->Generated_Frequency_Modulus), sizeof (int), 1,
             ptr_save);
      fread (&(OPTIONS->Reanneal_Cost), sizeof (int), 1, ptr_save);
      fread (&(OPTIONS->Reanneal_Parameters), sizeof (int), 1, ptr_save);
      fread (&(OPTIONS->Delta_X), sizeof (double), 1, ptr_save);
      fread (&(OPTIONS->User_Tangents), sizeof (int), 1, ptr_save);

#if USER_INITIAL_COST_TEMP
      fread (&(OPTIONS->User_Cost_Temperature), sizeof (double), 1, ptr_save);
#endif
#if RATIO_TEMPERATURE_SCALES
      fread (OPTIONS->User_Temperature_Ratio, sizeof (double),
             *number_parameters, ptr_save);
#endif
#if USER_INITIAL_PARAMETERS_TEMPS
      fread (OPTIONS->User_Parameter_Temperature, sizeof (double),
             *number_parameters, ptr_save);
#endif
#if DELTA_PARAMETERS
      fread (OPTIONS->User_Delta_Parameter, sizeof (double),
             *number_parameters, ptr_save);
#endif
#if QUENCH_PARAMETERS
      fread (OPTIONS->User_Quench_Param_Scale, sizeof (double),
             *number_parameters, ptr_save);
#endif
#if QUENCH_COST
      fread (OPTIONS->User_Quench_Cost_Scale, sizeof (double), 1, ptr_save);
#endif
      fread (&(OPTIONS->N_Accepted), sizeof (LONG_INT), 1, ptr_save);
      fread (&(OPTIONS->N_Generated), sizeof (LONG_INT), 1, ptr_save);
      fread (&(OPTIONS->Locate_Cost), sizeof (int), 1, ptr_save);
      fread (&(OPTIONS->Immediate_Exit), sizeof (int), 1, ptr_save);
#if OPTIONAL_DATA_DBL
      fread (&(OPTIONS->Asa_Data_Dim_Dbl), sizeof (ALLOC_INT), 1, ptr_save);
      fread (OPTIONS->Asa_Data_Dbl, sizeof (double),
             OPTIONS->Asa_Data_Dim_Dbl, ptr_save);
#endif
      fread (&(OPTIONS->Random_Array_Dim), sizeof (ALLOC_INT), 1, ptr_save);
      fread (OPTIONS->Random_Array, sizeof (double),
             OPTIONS->Random_Array_Dim, ptr_save);
      fread (&(OPTIONS->Asa_Recursive_Level), sizeof (int), 1, ptr_save);
#if OPTIONAL_DATA_INT
      fread (&(OPTIONS->Asa_Data_Dim_Int), sizeof (ALLOC_INT), 1, ptr_save);
      fread (OPTIONS->Asa_Data_Int, sizeof (LONG_INT),
             OPTIONS->Asa_Data_Dim_Int, ptr_save);
#endif
#if OPTIONAL_DATA_PTR
      fread (&(OPTIONS->Asa_Data_Dim_Ptr), sizeof (ALLOC_INT), 1, ptr_save);
      if (OPTIONS->Asa_Recursive_Level == 0)
        fread (OPTIONS->Asa_Data_Ptr, sizeof (OPTIONAL_PTR_TYPE),
               OPTIONS->Asa_Data_Dim_Ptr, ptr_save);
#if ASA_TEMPLATE_SELFOPT
      if (OPTIONS->Asa_Recursive_Level == 1)
        fread (OPTIONS->Asa_Data_Ptr, sizeof (RECUR_OPTIONAL_PTR_TYPE),
               OPTIONS->Asa_Data_Dim_Ptr, ptr_save);
#endif
#endif
#if USER_ASA_OUT
      fread (OPTIONS->Asa_Out_File, sizeof (char), 80, ptr_save);
#endif
#if USER_ASA_USR_OUT
      fread (OPTIONS->Asa_Usr_Out_File, sizeof (char), 80, ptr_save);
#endif
#if USER_COST_SCHEDULE
      fread (&(OPTIONS->Cost_Schedule), sizeof (char), 1, ptr_save);
#endif
#if USER_ACCEPT_ASYMP_EXP
      fread (&(OPTIONS->Asymp_Exp_Param), sizeof (double), 1, ptr_save);
#endif
#if USER_ACCEPTANCE_TEST
      fread (&(OPTIONS->Acceptance_Test), sizeof (char), 1, ptr_save);
      fread (&(OPTIONS->User_Acceptance_Flag), sizeof (int), 1, ptr_save);
      fread (&(OPTIONS->Cost_Acceptance_Flag), sizeof (int), 1, ptr_save);
      fread (&(OPTIONS->Cost_Temp_Curr), sizeof (double), 1, ptr_save);
      fread (&(OPTIONS->Cost_Temp_Init), sizeof (double), 1, ptr_save);
      fread (&(OPTIONS->Cost_Temp_Scale), sizeof (double), 1, ptr_save);
#endif
#if USER_GENERATING_FUNCTION
      fread (&(OPTIONS->Generating_Distrib), sizeof (char), 1, ptr_save);
#endif
#if USER_REANNEAL_COST
      fread (&(OPTIONS->Reanneal_Cost_Function), sizeof (char), 1, ptr_save);
#endif
#if USER_REANNEAL_PARAMETERS
      fread (&(OPTIONS->Reanneal_Params_Function), sizeof (char),
             1, ptr_save);
#endif
#if ASA_SAMPLE
      fread (&(OPTIONS->Bias_Acceptance), sizeof (double), 1, ptr_save);
      fread (OPTIONS->Bias_Generated, sizeof (double),
             *number_parameters, ptr_save);
      fread (&(OPTIONS->Average_Weights), sizeof (double), 1, ptr_save);
      fread (&(OPTIONS->Limit_Weights), sizeof (double), 1, ptr_save);
#endif
#if ASA_QUEUE
      fread (&save_queue, sizeof (LONG_INT), 1, ptr_save);
      fread (&save_queue_indx, sizeof (LONG_INT), 1, ptr_save);
      fread (&(OPTIONS->Queue_Size), sizeof (ALLOC_INT), 1, ptr_save);
      fread (save_queue_flag, sizeof (int), save_queue, ptr_save);
      fread (save_queue_cost, sizeof (double), save_queue, ptr_save);
      fread (save_queue_param, sizeof (double),
             (*number_parameters) * (OPTIONS->Queue_Size), ptr_save);
#if ASA_RESOLUTION
#else
      fread (OPTIONS->Queue_Resolution, sizeof (double),
             *number_parameters, ptr_save);
#endif
#endif /* ASA_QUEUE */
#if ASA_RESOLUTION
      fread (OPTIONS->Coarse_Resolution, sizeof (double),
             *number_parameters, ptr_save);
#endif
#if FITLOC
      fread (&(OPTIONS->Fit_Local), sizeof (int), 1, ptr_save);
      fread (&(OPTIONS->Iter_Max), sizeof (int), 1, ptr_save);
      fread (&(OPTIONS->Penalty), sizeof (double), 1, ptr_save);
#endif
#if ASA_FUZZY
      fread (&(OPTIONS->NoOfSamples), sizeof (int), 1, ptr_save);
      fread (&(OPTIONS->ThresholdDeviation), sizeof (double), 1, ptr_save);
      fread (&(OPTIONS->Performance_Target), sizeof (double), 1, ptr_save);
      fread (&(OPTIONS->Factor_a), sizeof (double), 1, ptr_save);
#endif
#if MULTI_MIN
      fread (OPTIONS->Multi_Number, sizeof (int), 1, ptr_save);
      fread (OPTIONS->Multi_Grid,
             sizeof (double), *number_parameters, ptr_save);
      fread (&(OPTIONS->Multi_Specify), sizeof (int), 1, ptr_save);
      for (multi_index = 0; multi_index < OPTIONS->Multi_Number;
           ++multi_index) {
        fread (&(OPTIONS->Multi_Cost[multi_index]), sizeof (double), 1,
               ptr_save);
        fread (&(OPTIONS->Multi_Params[multi_index]), sizeof (double),
               *number_parameters, ptr_save);
      }
#endif
#if ASA_PARALLEL
      for (i_prll = 0; i_prll < OPTIONS->Gener_Block_Max; ++i_prll) {
        fread (gener_block_state[i_prll].parameter,
               sizeof (double), *number_parameters, ptr_save);
        fread (&(gener_block_state[i_prll].cost),
               sizeof (double), 1, ptr_save);
#if USER_ACCEPTANCE_TEST
        fread (&
               (gener_block_state[i_prll].par_user_accept_flag),
               sizeof (int), 1, ptr_save);
        fread (&
               (gener_block_state[i_prll].par_cost_accept_flag),
               sizeof (int), 1, ptr_save);
#endif
      }
      fread (&(OPTIONS->Gener_Mov_Avr), sizeof (int), 1, ptr_save);
      fread (&(OPTIONS->Gener_Block), sizeof (LONG_INT), 1, ptr_save);
      fread (&(OPTIONS->Gener_Block_Max), sizeof (LONG_INT), 1, ptr_save);
#endif /* ASA_PARALLEL */

      fclose (ptr_save);

      asa_read = FALSE;
#if ASA_PRINT
      print_state (parameter_minimum,
                   parameter_maximum,
                   tangents,
                   curvature,
                   current_cost_temperature,
                   current_user_parameter_temp,
                   accepted_to_generated_ratio,
                   number_parameters,
                   curvature_flag,
                   number_accepted,
                   index_cost_acceptances,
                   number_generated,
                   number_invalid_generated_states,
                   last_saved_state,
                   best_generated_state, ptr_asa_out, OPTIONS);
#endif /* ASA_PRINT */

#include "asa_opt"
#if ASA_SAVE_OPT
      if ((ptr_save_opt = fopen ("asa_save_opt", "r")) == NULL) {
#if INCL_STDOUT
        printf ("\n\n*** WARNING fopen asa_save_opt failed *** \n\n");
#endif /* INCL_STDOUT */
#if ASA_PRINT
        fprintf (ptr_asa_out,
                 "\n\n*** WARNING fopen asa_save_opt failed *** \n\n");
        fflush (ptr_asa_out);
#endif
      } else {
        fscanf_ret = fscanf (ptr_save_opt, "%s%s%s%s%s",
                             read_if, read_FALSE, read_comm1, read_ASA_SAVE,
                             read_comm2);
        if (strcmp (read_if, "#if") || strcmp (read_FALSE, "FALSE")
            || strcmp (read_comm1, "/*")
            || strcmp (read_ASA_SAVE, "ASA_SAVE")
            || strcmp (read_comm2, "*/")) {
#if INCL_STDOUT
          printf ("\n\n*** EXIT not asa_save_opt for this version *** \n\n");
#endif /* INCL_STDOUT */
#if ASA_PRINT
          fprintf (ptr_asa_out,
                   "\n\n*** not asa_save_opt for this version *** \n\n");
          fflush (ptr_asa_out);
#endif
          *exit_status = INVALID_USER_INPUT;
          goto EXIT_asa;
        }
#if INT_LONG
        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%ld", &read_long);
        OPTIONS->Limit_Acceptances = read_long;
        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%ld", &read_long);
        OPTIONS->Limit_Generated = read_long;
#else
        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%d", &read_int);
        OPTIONS->Limit_Acceptances = read_int;
        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%d", &read_int);
        OPTIONS->Limit_Generated = read_int;
#endif
        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%d", &read_int);
        OPTIONS->Limit_Invalid_Generated_States = read_int;
        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%lf", &read_double);
        OPTIONS->Accepted_To_Generated_Ratio = read_double;

        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%lf", &read_double);
        OPTIONS->Cost_Precision = read_double;
        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%d", &read_int);
        OPTIONS->Maximum_Cost_Repeat = read_int;
        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%d", &read_int);
        OPTIONS->Number_Cost_Samples = read_int;
        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%lf", &read_double);
        OPTIONS->Temperature_Ratio_Scale = read_double;
        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%lf", &read_double);
        OPTIONS->Cost_Parameter_Scale_Ratio = read_double;
        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%lf", &read_double);
        OPTIONS->Temperature_Anneal_Scale = read_double;

        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%d", &read_int);
        OPTIONS->Include_Integer_Parameters = read_int;
        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%d", &read_int);
        OPTIONS->User_Initial_Parameters = read_int;
#if INT_ALLOC
        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%d", &read_int);
        OPTIONS->Sequential_Parameters = read_int;
#else
#if INT_LONG
        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%ld", &read_long);
        OPTIONS->Sequential_Parameters = read_long;
#else
        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%d", &read_int);
        OPTIONS->Sequential_Parameters = read_int;
#endif
#endif
        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%lf", &read_double);
        OPTIONS->Initial_Parameter_Temperature = read_double;

        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%d", &read_int);
        OPTIONS->Acceptance_Frequency_Modulus = read_int;
        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%d", &read_int);
        OPTIONS->Generated_Frequency_Modulus = read_int;
        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%d", &read_int);
        OPTIONS->Reanneal_Cost = read_int;
        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%d", &read_int);
        OPTIONS->Reanneal_Parameters = read_int;

        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%lf", &read_double);
        OPTIONS->Delta_X = read_double;
        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%d", &read_int);
        OPTIONS->User_Tangents = read_int;
        fscanf_ret = fscanf (ptr_save_opt, "%s", read_option);
        fscanf_ret = fscanf (ptr_save_opt, "%d", &read_int);
        OPTIONS->Curvature_0 = read_int;

        fclose (ptr_save_opt);
      }
#endif /* ASA_SAVE_OPT */

      goto SAVED_asa;
    }
#endif /* ASA_SAVE */

    if (OPTIONS->Locate_Cost < 0) {
      OPTIONS->Locate_Cost = 12;        /* generate new state from new best */
    } else {
      OPTIONS->Locate_Cost = 2; /* generate new state */
    }

#if USER_ACCEPTANCE_TEST
    OPTIONS->User_Acceptance_Flag = FALSE;
    OPTIONS->Cost_Acceptance_Flag = FALSE;
#endif

#if ASA_EXIT_ANYTIME
    if ((ptr_exit_anytime = fopen ("asa_exit_anytime", "r")) == NULL) {
      goto EXIT_asa;
    } else {
      fclose (ptr_exit_anytime);
    }
#endif /* ASA_EXIT_ANYTIME */

    /* GENERATE NEW PARAMETERS */

    /* generate a new valid set of parameters */
#if ASA_PARALLEL
    /* While this section of code is set to run under OpenMP using the gcc
     * compiler, you may change/add lines of code in this entire ASA_PARALLEL
     * section to correspond to your choice of parallel algorithm and
     * compiler. The entire ASA_PARALLEL section makes assignments to indexed
     * variables to afford flexibility for other such algorithms. */

    /* Note that here the do loop around generated states that tests for
     * invalid states is taken over, not within, blocks of parallel
     * calculated cost functions for these generated states, below. */

    repeated_invalid_states = 0;
    do {
      valid_state_generated_flag_par_test = 0;
      for (i_prll = 0; i_prll < OPTIONS->Gener_Block; ++i_prll) {
        valid_state_generated_flag_par[i_prll] = TRUE;
        number_invalid_generated_states_par[i_prll] =
          *number_invalid_generated_states;
#if USER_ACCEPTANCE_TEST
        gener_block_state[i_prll].par_user_accept_flag =
          OPTIONS->User_Acceptance_Flag;
        gener_block_state[i_prll].par_cost_accept_flag =
          OPTIONS->Cost_Acceptance_Flag;
#endif
      }

      for (i_prll = 0; i_prll < OPTIONS->Gener_Block; ++i_prll) {
        generate_flg_par[i_prll] =
          generate_new_state_par (user_random_generator, seed,
                                  parameter_minimum, parameter_maximum,
                                  current_user_parameter_temp,
#if USER_GENERATING_FUNCTION
                                  initial_user_parameter_temp,
                                  temperature_scale_parameters,
#endif
                                  number_parameters,
                                  parameter_type,
                                  i_prll,
                                  gener_block_state, last_saved_state,
                                  OPTIONS);

#if ASA_QUEUE
        /* Binary trees do not seem necessary since we are assuming
           that the cost function calculation is the bottleneck.
           However, see the MISC.DIR/asa_contrib file for
           source code for doubly-linked and hashed lists. */
        save_queue = (LONG_INT) OPTIONS->Queue_Size;
        if (OPTIONS->Queue_Size == 0) {
          queue_new_par[i_prll] = 1;
        } else {
          queue_new_par[i_prll] = 1;
          for (queue = 0; queue < save_queue; ++queue) {
            save_queue_test_par[i_prll] = 0;
            VFOR (index_v) {
              if (PARAMETER_RANGE_TOO_SMALL (index_v)) {
                ++(save_queue_test_par[i_prll]);
              } else {
                queue_v_par[i_prll] =
                  index_v + queue * (LONG_INT) (*number_parameters);
                tmp_var_db_par[i_prll] =
                  fabs (gener_block_state[i_prll].parameter
                        [index_v] -
                        save_queue_param_par[i_prll][queue_v_par[i_prll]]);
                if (
#if ASA_RESOLUTION
                     /* Coarse_Resolution used in gener_block_state */
                     tmp_var_db_par[i_prll]
                     < EPS_DOUBLE
#else
                     tmp_var_db_par[i_prll]
                     < (OPTIONS->Queue_Resolution[index_v] + EPS_DOUBLE)
#endif /* ASA_RESOLUTION */
                  ) {
                  ++(save_queue_test_par[i_prll]);
                }
              }
            }
            if (save_queue_test_par[i_prll] == *number_parameters) {
              queue_par_cost[i_prll] = save_queue_cost_par[i_prll][queue];
              queue_new_par[i_prll] = 0;
              valid_state_generated_flag_par[i_prll] =
                save_queue_valid_state_flag_par[i_prll][queue];
              if (valid_state_generated_flag_par[i_prll] == FALSE) {
#if ASA_PRINT_MORE
#if INT_LONG
                fprintf (ptr_asa_out,
                         "ASA_QUEUE: %ld BlockID: %ld \t previous invalid state",
                         OPTIONS->N_Generated, i_prll);
#else
                fprintf (ptr_asa_out,
                         "ASA_QUEUE: %d BlockID: %d \t previous invalid state",
                         OPTIONS->N_Generated, i_prll);
#endif
#endif /* ASA_PRINT_MORE */
              } else if (valid_state_generated_flag_par[i_prll] == TRUE) {
#if ASA_PRINT_MORE
#if INT_LONG
                fprintf (ptr_asa_out, "ASA_QUEUE: %ld BlockID %ld \t %*.*g\n",
                         OPTIONS->N_Generated, i_prll,
                         G_FIELD, G_PRECISION, tmp_var_db_par[i_prll]);
#else
                fprintf (ptr_asa_out, "ASA_QUEUE: BlockID %d %d \t %*.*g\n",
                         OPTIONS->N_Generated, i_prll,
                         G_FIELD, G_PRECISION, tmp_var_db_par[i_prll]);
#endif
#endif /* ASA_PRINT_MORE */
              }
              break;
            }
          }
        }
#endif /* ASA_QUEUE */
      }

      /* *** ENTER CODE TO SPAWN OFF PARALLEL GENERATED STATES *** */
#ifdef _OPENMP
#pragma omp parallel for
#endif /* _OPENMP */
      for (i_prll = 0; i_prll < OPTIONS->Gener_Block; ++i_prll) {
#if ASA_QUEUE
        if (queue_new_par[i_prll] == 0) {
          gener_block_state[i_prll].cost = queue_par_cost[i_prll];
        } else {
#endif /* ASA_QUEUE */
          OPTIONS->parallel_id = i_prll;
          gener_block_state[i_prll].cost =
            user_cost_function (gener_block_state[i_prll].parameter,
                                parameter_minimum,
                                parameter_maximum,
                                tangents,
                                curvature,
                                number_parameters,
                                parameter_type,
                                &(valid_state_generated_flag_par[i_prll]),
                                exit_status, OPTIONS);
          tmp_var_db1_par[i_prll] =
            cost_function_test (gener_block_state[i_prll].cost,
                                gener_block_state[i_prll].parameter,
                                parameter_minimum, parameter_maximum,
                                number_parameters, xnumber_parameters);
          if (tmp_var_db1_par[i_prll] == 0) {
            EXIT_asa_parallel = 1;
          }
#if ASA_QUEUE
        }
#endif /* ASA_QUEUE */
      }
      /* *** EXIT CODE SPAWNING OFF PARALLEL GENERATED STATES *** */

      if (EXIT_asa_parallel == 1) {
        *exit_status = INVALID_COST_FUNCTION;
        goto EXIT_asa;
      }
#if ASA_QUEUE
      for (i_prll = 0; i_prll < OPTIONS->Gener_Block; ++i_prll) {
        if (valid_state_generated_flag_par[i_prll] == FALSE) {
          ++valid_state_generated_flag_par_test;
        }
        if (queue_new_par[i_prll] == 1) {
          if (OPTIONS->Queue_Size > 0) {        /* in case recursive use */
            VFOR (index_v) {
              if (PARAMETER_RANGE_TOO_SMALL (index_v)) {
                continue;
              }
              queue_v_par[i_prll] = index_v + save_queue_indx_par[i_prll]
                * (LONG_INT) (*number_parameters);
              save_queue_param_par[i_prll][queue_v_par[i_prll]] =
                gener_block_state[i_prll].parameter[index_v];
            }
            save_queue_cost_par[i_prll][save_queue_indx_par[i_prll]] =
              gener_block_state[i_prll].cost;
            save_queue_valid_state_flag_par[i_prll][save_queue_indx_par
                                                    [i_prll]]
              = valid_state_generated_flag_par[i_prll];

            ++(save_queue_par[i_prll]);
            if (save_queue_par[i_prll] == (LONG_INT) OPTIONS->Queue_Size)
              --(save_queue_par[i_prll]);

            ++(save_queue_indx_par[i_prll]);
            if (save_queue_indx_par[i_prll] == (LONG_INT) OPTIONS->Queue_Size)
              save_queue_indx_par[i_prll] = 0;
          }
        }
      }
#endif /* ASA_QUEUE */
      repeated_invalid_states += valid_state_generated_flag_par_test;
    }
    while (valid_state_generated_flag_par_test >= OPTIONS->Gener_Block);

    if (repeated_invalid_states > OPTIONS->Limit_Invalid_Generated_States) {
      *exit_status = TOO_MANY_INVALID_STATES;
      goto EXIT_asa;
    }
#else /* ASA_PARALLEL */
    repeated_invalid_states = 0;
    do {
      ++(*number_invalid_generated_states);
      generate_flg = generate_new_state (user_random_generator,
                                         seed,
                                         parameter_minimum,
                                         parameter_maximum,
                                         current_user_parameter_temp,
#if USER_GENERATING_FUNCTION
                                         initial_user_parameter_temp,
                                         temperature_scale_parameters,
#endif
                                         number_parameters,
                                         parameter_type,
                                         current_generated_state,
                                         last_saved_state, OPTIONS);

      *valid_state_generated_flag = TRUE;
#if ASA_QUEUE
      /* Binary trees do not seem necessary since we are assuming
         that the cost function calculation is the bottleneck.
         However, see the MISC.DIR/asa_contrib file for
         source code for doubly-linked and hashed lists. */
      save_queue = (LONG_INT) OPTIONS->Queue_Size;
      if (OPTIONS->Queue_Size == 0) {
        queue_new = 1;
      } else {
        queue_new = 1;
        for (queue = 0; queue < save_queue; ++queue) {
          save_queue_test = 0;
          VFOR (index_v) {
            if (PARAMETER_RANGE_TOO_SMALL (index_v)) {
              ++save_queue_test;
            } else {
              queue_v = index_v + queue * (LONG_INT) (*number_parameters);
              if (
#if ASA_RESOLUTION
                   /* Coarse_Resolution used in current_generated_state */
                   fabs (current_generated_state->parameter[index_v] -
                         save_queue_param[queue_v]) < EPS_DOUBLE
#else
                   fabs (current_generated_state->parameter[index_v] -
                         save_queue_param[queue_v]) <
                   (OPTIONS->Queue_Resolution[index_v] + EPS_DOUBLE)
#endif /* ASA_RESOLUTION */
                ) {
                ++save_queue_test;
              }
            }
          }
          if (save_queue_test == *number_parameters) {
            tmp_var_db = save_queue_cost[queue];
            queue_new = 0;
            *valid_state_generated_flag = save_queue_flag[queue];
            if (*valid_state_generated_flag == FALSE) {
#if ASA_PRINT_MORE
#if INT_LONG
              fprintf (ptr_asa_out,
                       "ASA_QUEUE: %ld \t previous invalid state",
                       OPTIONS->N_Generated);
#else
              fprintf (ptr_asa_out,
                       "ASA_QUEUE: %d \t previous invalid state",
                       OPTIONS->N_Generated);
#endif
#endif /* ASA_PRINT_MORE */
            } else {
#if ASA_PRINT_MORE
#if INT_LONG
              fprintf (ptr_asa_out, "ASA_QUEUE: %ld \t %*.*g\n",
                       OPTIONS->N_Generated,
                       G_FIELD, G_PRECISION, tmp_var_db);
#else
              fprintf (ptr_asa_out, "ASA_QUEUE: %d \t %*.*g\n",
                       OPTIONS->N_Generated,
                       G_FIELD, G_PRECISION, tmp_var_db);
#endif
#endif /* ASA_PRINT_MORE */
            }
            break;
          }
        }
      }
      if (queue_new == 1) {
        tmp_var_db =
          user_cost_function (current_generated_state->parameter,
                              parameter_minimum,
                              parameter_maximum,
                              tangents,
                              curvature,
                              number_parameters,
                              parameter_type,
                              valid_state_generated_flag,
                              exit_status, OPTIONS);
        if (cost_function_test (tmp_var_db,
                                current_generated_state->parameter,
                                parameter_minimum,
                                parameter_maximum,
                                number_parameters, xnumber_parameters) == 0) {
          *exit_status = INVALID_COST_FUNCTION;
          goto EXIT_asa;
        }
        if (OPTIONS->Queue_Size > 0) {  /* in case recursive use */
          VFOR (index_v) {
            if (PARAMETER_RANGE_TOO_SMALL (index_v)) {
              continue;
            }
            queue_v = index_v + save_queue_indx
              * (LONG_INT) (*number_parameters);
            save_queue_param[queue_v] =
              current_generated_state->parameter[index_v];
          }
          save_queue_cost[save_queue_indx] = tmp_var_db;
          save_queue_flag[save_queue_indx]
            = *valid_state_generated_flag;

          ++save_queue;
          if (save_queue == (LONG_INT) OPTIONS->Queue_Size)
            --save_queue;

          ++save_queue_indx;
          if (save_queue_indx == (LONG_INT) OPTIONS->Queue_Size)
            save_queue_indx = 0;
        }
      }
#else /* ASA_QUEUE */
      tmp_var_db =
        user_cost_function (current_generated_state->parameter,
                            parameter_minimum,
                            parameter_maximum,
                            tangents,
                            curvature,
                            number_parameters,
                            parameter_type,
                            valid_state_generated_flag, exit_status, OPTIONS);
      if (cost_function_test
          (tmp_var_db, current_generated_state->parameter,
           parameter_minimum, parameter_maximum, number_parameters,
           xnumber_parameters) == 0) {
        *exit_status = INVALID_COST_FUNCTION;
        goto EXIT_asa;
      }
#endif /* ASA_QUEUE */
      current_generated_state->cost = tmp_var_db;
      ++repeated_invalid_states;
      if (repeated_invalid_states > OPTIONS->Limit_Invalid_Generated_States) {
        *exit_status = TOO_MANY_INVALID_STATES;
        goto EXIT_asa;
      }
    }
    while (*valid_state_generated_flag == FALSE);
    --(*number_invalid_generated_states);
#endif /* ASA_PARALLEL */

    /* ACCEPT/REJECT NEW PARAMETERS */

#if ASA_PARALLEL
    for (sort_index = 0; sort_index < OPTIONS->Gener_Block; ++sort_index) {
      parallel_sort[sort_index] = sort_index;
    }
    qsort (parallel_sort, OPTIONS->Gener_Block, sizeof (LONG_INT),
           sort_parallel);

    for (sort_index = 0; sort_index < OPTIONS->Gener_Block; ++sort_index) {
      i_prll = parallel_sort[sort_index];
      if (valid_state_generated_flag_par[i_prll] == FALSE) {
        continue;
      }
      current_generated_state->cost = gener_block_state[i_prll].cost;
#if USER_ACCEPTANCE_TEST
      OPTIONS->User_Acceptance_Flag =
        gener_block_state[i_prll].par_user_accept_flag;
      OPTIONS->Cost_Acceptance_Flag =
        gener_block_state[i_prll].par_cost_accept_flag;
#endif
      VFOR (index_v) {
        /* ignore parameters with too small a range */
        if (PARAMETER_RANGE_TOO_SMALL (index_v))
          continue;
        current_generated_state->parameter[index_v] =
          gener_block_state[i_prll].parameter[index_v];
      }
#endif /* ASA_PARALLEL */
      /* decide whether to accept/reject the new state */
      accept_new_state (user_random_generator,
                        seed,
                        parameter_minimum,
                        parameter_maximum, current_cost_temperature,
#if ASA_SAMPLE
                        current_user_parameter_temp,
#endif
                        number_parameters,
                        recent_number_acceptances,
                        number_accepted,
                        index_cost_acceptances,
                        number_acceptances_saved,
                        recent_number_generated,
                        number_generated,
                        index_parameter_generations,
                        current_generated_state, last_saved_state,
#if ASA_SAMPLE
                        ptr_asa_out,
#endif
                        OPTIONS);

#if ASA_PARALLEL
#else
#if ASA_PIPE_FILE
#if INT_ALLOC
      fprintf (ptr_asa_pipe, "%d", *number_generated);
#else
#if INT_LONG
      fprintf (ptr_asa_pipe, "%ld", *number_generated);
#else
      fprintf (ptr_asa_pipe, "%d", *number_generated);
#endif
#endif
#if INT_ALLOC
      fprintf (ptr_asa_pipe, "\t%d", *number_accepted);
#else
#if INT_LONG
      fprintf (ptr_asa_pipe, "\t%ld", *number_accepted);
#else
      fprintf (ptr_asa_pipe, "\t%d", *number_accepted);
#endif
#endif
      fprintf (ptr_asa_pipe, "\t%g", best_generated_state->cost);
      VFOR (index_v)
        fprintf (ptr_asa_pipe, "\t%g",
                 best_generated_state->parameter[index_v]);
      fprintf (ptr_asa_pipe, "\t%g", current_generated_state->cost);
      VFOR (index_v)
        fprintf (ptr_asa_pipe, "\t%g",
                 current_generated_state->parameter[index_v]);
      fprintf (ptr_asa_pipe, "\t%g", *current_cost_temperature);
      VFOR (index_v)
        fprintf (ptr_asa_pipe, "\t%g", current_user_parameter_temp[index_v]);
      fprintf (ptr_asa_pipe, "\t%g", last_saved_state->cost);
      fprintf (ptr_asa_pipe, "\n");
      fflush (ptr_asa_pipe);
#endif /* ASA_PIPE_FILE */
#if INCL_STDOUT
#if ASA_PIPE
#if INT_ALLOC
      printf ("%d", *number_generated);
#else
#if INT_LONG
      printf ("%ld", *number_generated);
#else
      printf ("%d", *number_generated);
#endif
#endif
#if INT_ALLOC
      printf ("\t%d", *number_accepted);
#else
#if INT_LONG
      printf ("\t%ld", *number_accepted);
#else
      printf ("\t%d", *number_accepted);
#endif
#endif
      printf ("\t%g", best_generated_state->cost);
      VFOR (index_v)
        printf ("\t%g", best_generated_state->parameter[index_v]);
      printf ("\t%g", current_generated_state->cost);
      VFOR (index_v)
        printf ("\t%g", current_generated_state->parameter[index_v]);
      printf ("\t%g", *current_cost_temperature);
      VFOR (index_v)
        printf ("\t%g", current_user_parameter_temp[index_v]);
      printf ("\t%g", last_saved_state->cost);
      printf ("\n");
#endif /* ASA_PIPE */
#endif /* INCL_STDOUT */
#endif /* ASA_PARALLEL */

      /* calculate the ratio of acceptances to generated states */
      *accepted_to_generated_ratio =
        (double) (*recent_number_acceptances + 1) /
        (double) (*recent_number_generated + 1);

#if MULTI_MIN
      if (((OPTIONS->Multi_Specify == 0)
           && (current_generated_state->cost <= best_generated_state->cost))
          || ((OPTIONS->Multi_Specify == 1)
              && (current_generated_state->cost <
                  best_generated_state->cost))) {
#if ASA_RESOLUTION
        VFOR (index_v) {
          if (OPTIONS->Multi_Grid[index_v] <
              OPTIONS->Coarse_Resolution[index_v])
            OPTIONS->Multi_Grid[index_v] =
              OPTIONS->Coarse_Resolution[index_v];
        }
#endif /* ASA_RESOLUTION */
        VFOR (index_v) {
          if (OPTIONS->Multi_Grid[index_v] < EPS_DOUBLE)
            OPTIONS->Multi_Grid[index_v] = EPS_DOUBLE;
        }

        multi_test = 0;
        for (multi_index = 0; multi_index < OPTIONS->Multi_Number;
             ++multi_index) {
          multi_test_cmp = 0;
          multi_test_dim = 0;
          VFOR (index_v) {
            if (PARAMETER_RANGE_TOO_SMALL (index_v))
              continue;
            ++multi_test_dim;
            if (fabs (current_generated_state->parameter[index_v]
                      - OPTIONS->Multi_Params[multi_index][index_v])
                < OPTIONS->Multi_Grid[index_v] - EPS_DOUBLE)
              ++multi_test_cmp;
          }
          if (multi_test_cmp == multi_test_dim)
            multi_test = 1;
          if (OPTIONS->Multi_Specify == 1)
            break;
        }

        if (multi_test == 0) {
          multi_cost[OPTIONS->Multi_Number] = current_generated_state->cost;
          VFOR (index_v) {
            multi_params[OPTIONS->Multi_Number][index_v] =
              current_generated_state->parameter[index_v];
          }
          for (multi_index = 0; multi_index < OPTIONS->Multi_Number;
               ++multi_index) {
            multi_cost[multi_index] = OPTIONS->Multi_Cost[multi_index];
            VFOR (index_v) {
              multi_params[multi_index][index_v] =
                OPTIONS->Multi_Params[multi_index][index_v];
            }
          }

          qsort (multi_sort, OPTIONS->Multi_Number + 1, sizeof (int),
                 multi_compare);
          for (multi_index = 0; multi_index < OPTIONS->Multi_Number;
               ++multi_index) {
            OPTIONS->Multi_Cost[multi_index] =
              multi_cost[multi_sort[multi_index]];
            VFOR (index_v) {
              OPTIONS->Multi_Params[multi_index][index_v] =
                multi_params[multi_sort[multi_index]][index_v];
            }
          }
        }
      }
#endif /* MULTI_MIN */

      /* CHECK FOR NEW MINIMUM */
      if (current_generated_state->cost < best_generated_state->cost) {
        best_flag = 1;
      } else {
        best_flag = 0;
      }
#if MULTI_MIN
      if (((OPTIONS->Multi_Specify == 0)
           && (current_generated_state->cost <= best_generated_state->cost))
          || ((OPTIONS->Multi_Specify == 1)
              && (current_generated_state->cost <
                  best_generated_state->cost)))
#else
      if (current_generated_state->cost < best_generated_state->cost)
#endif /* MULTI_MIN */
      {
        /* NEW MINIMUM FOUND */

        OPTIONS->Locate_Cost = -1;

        /* reset the recent acceptances and generated counts */
        *recent_number_acceptances = *recent_number_generated = 0;
        if (best_flag == 1) {
          *best_number_generated_saved = *number_generated;
          *best_number_accepted_saved = *number_accepted;
        }
        index_cost_repeat = 0;

        /* copy the current state into the best_generated state */
        best_generated_state->cost = current_generated_state->cost;
        VFOR (index_v) {
#if DROPPED_PARAMETERS
          /* ignore parameters that have too small a range */
          if (PARAMETER_RANGE_TOO_SMALL (index_v))
            continue;
#endif
          best_generated_state->parameter[index_v] =
            current_generated_state->parameter[index_v];
        }

        /* printout the new minimum state and value */
#if ASA_PRINT
        fprintf (ptr_asa_out,
#if INT_LONG
                 "best...->cost=%-*.*g  *number_accepted=%ld  *number_generated=%ld\n",
                 G_FIELD, G_PRECISION, best_generated_state->cost,
#else
                 "best...->cost=%-*.*g  *number_accepted=%d  *number_generated=%d\n",
                 G_FIELD, G_PRECISION, best_generated_state->cost,
#endif /* INT_LONG */
                 *number_accepted, *number_generated);
#if ASA_PRINT_MORE
        if (best_flag == 1) {
          fprintf (ptr_asa_out, "\nnew best\n");
        }
#endif /* ASA_PRINT_MORE */
#if ASA_PARALLEL
        /* print OPTIONS->Gener_Block just used */
        fprintf (ptr_asa_out,
#if INT_LONG
                 "OPTIONS->Gener_Block = %ld\n",
#else
                 "OPTIONS->Gener_Block = %d\n",
#endif /* INT_LONG */
                 OPTIONS->Gener_Block);
#endif /* ASA_PARALLEL */
        if (best_flag == 1) {
#if ASA_PRINT_MORE
#if INT_ALLOC
          fprintf (ptr_asa_out, "Present Random Seed = %d\n", *seed);
#else
#if INT_LONG
          fprintf (ptr_asa_out, "Present Random Seed = %ld\n", *seed);
#else
          fprintf (ptr_asa_out, "Present Random Seed = %d\n", *seed);
#endif
#endif
          print_state (parameter_minimum,
                       parameter_maximum,
                       tangents,
                       curvature,
                       current_cost_temperature,
                       current_user_parameter_temp,
                       accepted_to_generated_ratio,
                       number_parameters,
                       curvature_flag,
                       number_accepted,
                       index_cost_acceptances,
                       number_generated,
                       number_invalid_generated_states,
                       last_saved_state,
                       best_generated_state, ptr_asa_out, OPTIONS);
#endif /* ASA_PRINT_MORE */
        }
        fflush (ptr_asa_out);
#endif /* ASA_PRINT */
      }
#if ASA_PARALLEL
    }
#endif /* ASA_PARALLEL */

#if ASA_SAVE
    /* These writes are put here with these tests, instead of just
       after a new best state is found, to prevent any confusion with
       any parallel code that might be added by users. */
    if (*recent_number_acceptances == 0
        && *recent_number_generated == 0
        && *best_number_generated_saved == *number_generated
        && *best_number_accepted_saved == *number_accepted
        && OPTIONS->Asa_Recursive_Level == asa_recursive_max
        && index_cost_repeat == 0) {
      if (OPTIONS->Asa_Recursive_Level > 0)
        sprintf (asa_save_comm, "asa_save_%d", OPTIONS->Asa_Recursive_Level);
      else
        sprintf (asa_save_comm, "asa_save");
      ptr_save = fopen (asa_save_comm, "w");

      fwrite (number_parameters, sizeof (ALLOC_INT), 1, ptr_save);
      fwrite (xnumber_parameters, sizeof (double), 1, ptr_save);
      fwrite (parameter_minimum, sizeof (double), *number_parameters,
              ptr_save);
      fwrite (parameter_maximum, sizeof (double), *number_parameters,
              ptr_save);
      fwrite (tangents, sizeof (double), *number_parameters, ptr_save);
      fwrite (current_user_parameter_temp, sizeof (double),
              *number_parameters, ptr_save);
      fwrite (initial_user_parameter_temp, sizeof (double),
              *number_parameters, ptr_save);
      fwrite (temperature_scale_parameters, sizeof (double),
              *number_parameters, ptr_save);

      fwrite (parameter_type, sizeof (int), *number_parameters, ptr_save);
      fwrite (&index_cost_repeat, sizeof (int), 1, ptr_save);
      fwrite (&asa_open, sizeof (int), 1, ptr_save);
      fwrite (&number_asa_open, sizeof (int), 1, ptr_save);
      fwrite (&recursive_asa_open, sizeof (int), 1, ptr_save);

      fwrite (current_cost_temperature, sizeof (double), 1, ptr_save);
      fwrite (initial_cost_temperature, sizeof (double), 1, ptr_save);
      fwrite (temperature_scale_cost, sizeof (double), 1, ptr_save);
      fwrite (accepted_to_generated_ratio, sizeof (double), 1, ptr_save);

      fwrite (curvature_flag, sizeof (int), 1, ptr_save);

      fwrite (seed, sizeof (LONG_INT), 1, ptr_save);
      fwrite (number_generated, sizeof (LONG_INT), 1, ptr_save);
      fwrite (number_accepted, sizeof (LONG_INT), 1, ptr_save);
      fwrite (number_acceptances_saved, sizeof (LONG_INT), 1, ptr_save);
      fwrite (recent_number_acceptances, sizeof (LONG_INT), 1, ptr_save);
      fwrite (recent_number_generated, sizeof (LONG_INT), 1, ptr_save);
      fwrite (number_invalid_generated_states, sizeof (LONG_INT), 1,
              ptr_save);
      fwrite (index_cost_acceptances, sizeof (LONG_INT), 1, ptr_save);
      fwrite (best_number_generated_saved, sizeof (LONG_INT), 1, ptr_save);
      fwrite (best_number_accepted_saved, sizeof (LONG_INT), 1, ptr_save);

      fwrite (index_parameter_generations, sizeof (LONG_INT),
              *number_parameters, ptr_save);

      fwrite (current_generated_state->parameter,
              sizeof (double), *number_parameters, ptr_save);
      fwrite (last_saved_state->parameter,
              sizeof (double), *number_parameters, ptr_save);
      fwrite (best_generated_state->parameter,
              sizeof (double), *number_parameters, ptr_save);
      fwrite (&(current_generated_state->cost), sizeof (double), 1, ptr_save);
      fwrite (&(last_saved_state->cost), sizeof (double), 1, ptr_save);
      fwrite (&(best_generated_state->cost), sizeof (double), 1, ptr_save);

      fwrite (&(OPTIONS->Limit_Acceptances), sizeof (LONG_INT), 1, ptr_save);
      fwrite (&(OPTIONS->Limit_Generated), sizeof (LONG_INT), 1, ptr_save);
      fwrite (&(OPTIONS->Limit_Invalid_Generated_States), sizeof (int),
              1, ptr_save);
      fwrite (&(OPTIONS->Accepted_To_Generated_Ratio), sizeof (double),
              1, ptr_save);
      fwrite (&(OPTIONS->Cost_Precision), sizeof (double), 1, ptr_save);
      fwrite (&(OPTIONS->Maximum_Cost_Repeat), sizeof (int), 1, ptr_save);
      fwrite (&(OPTIONS->Number_Cost_Samples), sizeof (int), 1, ptr_save);
      fwrite (&(OPTIONS->Temperature_Ratio_Scale), sizeof (double),
              1, ptr_save);
      fwrite (&(OPTIONS->Cost_Parameter_Scale_Ratio), sizeof (double),
              1, ptr_save);
      fwrite (&(OPTIONS->Temperature_Anneal_Scale), sizeof (double),
              1, ptr_save);
      fwrite (&(OPTIONS->Include_Integer_Parameters), sizeof (int),
              1, ptr_save);
      fwrite (&(OPTIONS->User_Initial_Parameters), sizeof (int), 1, ptr_save);
      fwrite (&(OPTIONS->Sequential_Parameters), sizeof (ALLOC_INT), 1,
              ptr_save);
      fwrite (&(OPTIONS->Initial_Parameter_Temperature), sizeof (double), 1,
              ptr_save);
      fwrite (&(OPTIONS->Acceptance_Frequency_Modulus), sizeof (int), 1,
              ptr_save);
      fwrite (&(OPTIONS->Generated_Frequency_Modulus), sizeof (int), 1,
              ptr_save);
      fwrite (&(OPTIONS->Reanneal_Cost), sizeof (int), 1, ptr_save);
      fwrite (&(OPTIONS->Reanneal_Parameters), sizeof (int), 1, ptr_save);
      fwrite (&(OPTIONS->Delta_X), sizeof (double), 1, ptr_save);
      fwrite (&(OPTIONS->User_Tangents), sizeof (int), 1, ptr_save);

#if USER_INITIAL_COST_TEMP
      fwrite (&(OPTIONS->User_Cost_Temperature), sizeof (double), 1,
              ptr_save);
#endif
#if RATIO_TEMPERATURE_SCALES
      fwrite (OPTIONS->User_Temperature_Ratio, sizeof (double),
              *number_parameters, ptr_save);
#endif
#if USER_INITIAL_PARAMETERS_TEMPS
      fwrite (OPTIONS->User_Parameter_Temperature, sizeof (double),
              *number_parameters, ptr_save);
#endif
#if DELTA_PARAMETERS
      fwrite (OPTIONS->User_Delta_Parameter, sizeof (double),
              *number_parameters, ptr_save);
#endif
#if QUENCH_PARAMETERS
      fwrite (OPTIONS->User_Quench_Param_Scale, sizeof (double),
              *number_parameters, ptr_save);
#endif
#if QUENCH_COST
      fwrite (OPTIONS->User_Quench_Cost_Scale, sizeof (double), 1, ptr_save);
#endif
      fwrite (&(OPTIONS->N_Accepted), sizeof (LONG_INT), 1, ptr_save);
      fwrite (&(OPTIONS->N_Generated), sizeof (LONG_INT), 1, ptr_save);
      fwrite (&(OPTIONS->Locate_Cost), sizeof (int), 1, ptr_save);
      fwrite (&(OPTIONS->Immediate_Exit), sizeof (int), 1, ptr_save);
#if OPTIONAL_DATA_DBL
      fwrite (&(OPTIONS->Asa_Data_Dim_Dbl), sizeof (ALLOC_INT), 1, ptr_save);
      fwrite (OPTIONS->Asa_Data_Dbl, sizeof (double),
              OPTIONS->Asa_Data_Dim_Dbl, ptr_save);
#endif
      fwrite (&(OPTIONS->Random_Array_Dim), sizeof (ALLOC_INT), 1, ptr_save);
      fwrite (OPTIONS->Random_Array, sizeof (double),
              OPTIONS->Random_Array_Dim, ptr_save);
      fwrite (&(OPTIONS->Asa_Recursive_Level), sizeof (int), 1, ptr_save);
#if OPTIONAL_DATA_INT
      fwrite (&(OPTIONS->Asa_Data_Dim_Int), sizeof (ALLOC_INT), 1, ptr_save);
      fwrite (OPTIONS->Asa_Data_Int, sizeof (LONG_INT),
              OPTIONS->Asa_Data_Dim_Int, ptr_save);
#endif
#if OPTIONAL_DATA_PTR
      fwrite (&(OPTIONS->Asa_Data_Dim_Ptr), sizeof (ALLOC_INT), 1, ptr_save);
      if (OPTIONS->Asa_Recursive_Level == 0)
        fwrite (OPTIONS->Asa_Data_Ptr, sizeof (OPTIONAL_PTR_TYPE),
                OPTIONS->Asa_Data_Dim_Ptr, ptr_save);
#if ASA_TEMPLATE_SELFOPT
      if (OPTIONS->Asa_Recursive_Level == 1)
        fwrite (OPTIONS->Asa_Data_Ptr, sizeof (RECUR_OPTIONAL_PTR_TYPE),
                OPTIONS->Asa_Data_Dim_Ptr, ptr_save);
#endif
#endif
#if USER_ASA_OUT
      fwrite (OPTIONS->Asa_Out_File, sizeof (char), 80, ptr_save);
#endif
#if USER_ASA_OUT
      fwrite (OPTIONS->Asa_Usr_Out_File, sizeof (char), 80, ptr_save);
#endif
#if USER_COST_SCHEDULE
      fwrite (&(OPTIONS->Cost_Schedule), sizeof (char), 1, ptr_save);
#endif
#if USER_ACCEPT_ASYMP_EXP
      fwrite (&(OPTIONS->Asymp_Exp_Param), sizeof (double), 1, ptr_save);
#endif
#if USER_ACCEPTANCE_TEST
      fwrite (&(OPTIONS->Acceptance_Test), sizeof (char), 1, ptr_save);
      fwrite (&(OPTIONS->User_Acceptance_Flag), sizeof (int), 1, ptr_save);
      fwrite (&(OPTIONS->Cost_Acceptance_Flag), sizeof (int), 1, ptr_save);
      fwrite (&(OPTIONS->Cost_Temp_Curr), sizeof (double), 1, ptr_save);
      fwrite (&(OPTIONS->Cost_Temp_Init), sizeof (double), 1, ptr_save);
      fwrite (&(OPTIONS->Cost_Temp_Scale), sizeof (double), 1, ptr_save);
#endif
#if USER_GENERATING_FUNCTION
      fwrite (&(OPTIONS->Generating_Distrib), sizeof (char), 1, ptr_save);
#endif
#if USER_REANNEAL_COST
      fwrite (&(OPTIONS->Reanneal_Cost_Function), sizeof (char), 1, ptr_save);
#endif
#if USER_REANNEAL_PARAMETERS
      fwrite (&(OPTIONS->Reanneal_Params_Function), sizeof (char), 1,
              ptr_save);
#endif
#if ASA_SAMPLE
      fwrite (&(OPTIONS->Bias_Acceptance), sizeof (double), 1, ptr_save);
      fwrite (OPTIONS->Bias_Generated, sizeof (double),
              *number_parameters, ptr_save);
      fwrite (&(OPTIONS->Average_Weights), sizeof (double), 1, ptr_save);
      fwrite (&(OPTIONS->Limit_Weights), sizeof (double), 1, ptr_save);
#endif
#if ASA_QUEUE
      fwrite (&save_queue, sizeof (LONG_INT), 1, ptr_save);
      fwrite (&save_queue_indx, sizeof (LONG_INT), 1, ptr_save);
      fwrite (&(OPTIONS->Queue_Size), sizeof (ALLOC_INT), 1, ptr_save);
      fwrite (save_queue_flag, sizeof (int), save_queue, ptr_save);
      fwrite (save_queue_cost, sizeof (double), save_queue, ptr_save);
      fwrite (save_queue_param, sizeof (double),
              (*number_parameters) * (OPTIONS->Queue_Size), ptr_save);
#if ASA_RESOLUTION
#else
      fwrite (OPTIONS->Queue_Resolution, sizeof (double),
              *number_parameters, ptr_save);
#endif
#endif /* ASA_QUEUE */
#if ASA_RESOLUTION
      fwrite (OPTIONS->Coarse_Resolution, sizeof (double),
              *number_parameters, ptr_save);
#endif
#if ASA_FUZZY
      fwrite (&(OPTIONS->NoOfSamples), sizeof (int), 1, ptr_save);
      fwrite (&(OPTIONS->ThresholdDeviation), sizeof (double), 1, ptr_save);
      fwrite (&(OPTIONS->Performance_Target), sizeof (double), 1, ptr_save);
      fwrite (&(OPTIONS->Factor_a), sizeof (double), 1, ptr_save);
#endif
#if FITLOC
      fwrite (&(OPTIONS->Fit_Local), sizeof (int), 1, ptr_save);
      fwrite (&(OPTIONS->Iter_Max), sizeof (int), 1, ptr_save);
      fwrite (&(OPTIONS->Penalty), sizeof (double), 1, ptr_save);
#endif
#if MULTI_MIN
      fwrite (OPTIONS->Multi_Number, sizeof (int), 1, ptr_save);
      fwrite (OPTIONS->Multi_Grid,
              sizeof (double), *number_parameters, ptr_save);
      fwrite (&(OPTIONS->Multi_Specify), sizeof (int), 1, ptr_save);
      for (multi_index = 0; multi_index < OPTIONS->Multi_Number;
           ++multi_index) {
        fwrite (&(OPTIONS->Multi_Cost[multi_index]), sizeof (double), 1,
                ptr_save);
        fwrite (&(OPTIONS->Multi_Params[multi_index]), sizeof (double),
                *number_parameters, ptr_save);
      }
#endif
#if ASA_PARALLEL
      for (i_prll = 0; i_prll < OPTIONS->Gener_Block_Max; ++i_prll) {
        fwrite (gener_block_state[i_prll].parameter,
                sizeof (double), *number_parameters, ptr_save);
        fwrite (&(gener_block_state[i_prll].cost),
                sizeof (double), 1, ptr_save);
#if USER_ACCEPTANCE_TEST
        fwrite (&
                (gener_block_state[i_prll].par_user_accept_flag),
                sizeof (int), 1, ptr_save);
        fwrite (&(gener_block_state[i_prll].par_cost_accept_flag),
                sizeof (int), 1, ptr_save);
#endif
      }
      fwrite (&(OPTIONS->Gener_Mov_Avr), sizeof (int), 1, ptr_save);
      fwrite (&(OPTIONS->Gener_Block), sizeof (LONG_INT), 1, ptr_save);
      fwrite (&(OPTIONS->Gener_Block_Max), sizeof (LONG_INT), 1, ptr_save);
#endif /* ASA_PARALLEL */

      fclose (ptr_save);

    SAVED_asa:
      ;

#if SYSTEM_CALL
#if ASA_SAVE_BACKUP
#if INT_LONG
      if (OPTIONS->Asa_Recursive_Level > 0)
        sprintf (asa_save_comm, "/bin/cp asa_save_%d asa_save_%d.%ld",
                 OPTIONS->Asa_Recursive_Level,
                 OPTIONS->Asa_Recursive_Level, OPTIONS->N_Accepted);
      else
        sprintf (asa_save_comm, "/bin/cp asa_save asa_save.%ld",
                 OPTIONS->N_Accepted);
#else
      if (OPTIONS->Asa_Recursive_Level > 0)
        sprintf (asa_save_comm, "/bin/cp asa_save_%d asa_save_%d.%d",
                 OPTIONS->Asa_Recursive_Level,
                 OPTIONS->Asa_Recursive_Level, OPTIONS->N_Accepted);
      else
        sprintf (asa_save_comm, "/bin/cp asa_save asa_save.%d",
                 OPTIONS->N_Accepted);
#endif
      ptr_comm = popen (asa_save_comm, "r");
      pclose (ptr_comm);
#else /* ASA_SAVE_BACKUP */
      /* extra protection in case run aborts during write */
      if (OPTIONS->Asa_Recursive_Level > 0)
        sprintf (asa_save_comm, "/bin/cp asa_save_%d asa_save_%d.old",
                 OPTIONS->Asa_Recursive_Level, OPTIONS->Asa_Recursive_Level);
      else
        sprintf (asa_save_comm, "/bin/cp asa_save asa_save.old");
      ptr_comm = popen (asa_save_comm, "r");
      pclose (ptr_comm);
#endif /* ASA_SAVE_BACKUP */
#endif /* SYSTEM_CALL */
    }
#endif /* ASA_SAVE */

    if (OPTIONS->Immediate_Exit == TRUE) {
      *exit_status = IMMEDIATE_EXIT;
      goto EXIT_asa;
    }

    /* PERIODIC TESTING/REANNEALING/PRINTING SECTION */

    if (OPTIONS->Acceptance_Frequency_Modulus == 0)
      tmp_var_int1 = FALSE;
    else if ((int) (*number_accepted %
                    ((LONG_INT) OPTIONS->Acceptance_Frequency_Modulus)) == 0
             && *number_acceptances_saved == *number_accepted)
      tmp_var_int1 = TRUE;
    else
      tmp_var_int1 = FALSE;

    if (OPTIONS->Generated_Frequency_Modulus == 0)
      tmp_var_int2 = FALSE;
    else if ((int) (*number_generated %
                    ((LONG_INT) OPTIONS->Generated_Frequency_Modulus)) == 0)
      tmp_var_int2 = TRUE;
    else
      tmp_var_int2 = FALSE;

    if (tmp_var_int1 == TRUE || tmp_var_int2 == TRUE
        || (*accepted_to_generated_ratio
            < OPTIONS->Accepted_To_Generated_Ratio)) {

#if ASA_PARALLEL
      if (OPTIONS->Gener_Mov_Avr > 0) {
        for (i_prll = 1; i_prll < OPTIONS->Gener_Mov_Avr; ++i_prll) {
          parallel_gen_ratio_block[i_prll - 1] =
            parallel_gen_ratio_block[i_prll];
        }
        parallel_gen_ratio_block[OPTIONS->Gener_Mov_Avr - 1] =
          *recent_number_generated;
        tmp_var_lint = 0;
        for (i_prll = 0; i_prll < OPTIONS->Gener_Mov_Avr; ++i_prll) {
          tmp_var_lint += parallel_gen_ratio_block[i_prll];
        }
        OPTIONS->Gener_Block = (LONG_INT)
          ((double) tmp_var_lint / (double) (OPTIONS->Gener_Mov_Avr));
        OPTIONS->Gener_Block =
          MIN (OPTIONS->Gener_Block, OPTIONS->Gener_Block_Max);
      }
#endif /* ASA_PARALLEL */

      if (*accepted_to_generated_ratio <
          (OPTIONS->Accepted_To_Generated_Ratio))
        *recent_number_acceptances = *recent_number_generated = 0;

      /* if best.cost repeats OPTIONS->Maximum_Cost_Repeat then exit */
      if (OPTIONS->Maximum_Cost_Repeat != 0) {
        if (fabs (last_saved_state->cost - best_generated_state->cost)
            < OPTIONS->Cost_Precision) {
          ++index_cost_repeat;
          if (index_cost_repeat == (OPTIONS->Maximum_Cost_Repeat)) {
            *exit_status = COST_REPEATING;
            goto EXIT_asa;
          }
        } else {
          index_cost_repeat = 0;
        }
      }
      if (OPTIONS->Reanneal_Parameters == TRUE) {
        OPTIONS->Locate_Cost = 3;       /* reanneal parameters */

        /* calculate tangents, not curvatures, to reanneal */
        *curvature_flag = FALSE;
        cost_derivatives (user_cost_function,
                          parameter_minimum,
                          parameter_maximum,
                          tangents,
                          curvature,
                          maximum_tangent,
                          number_parameters,
                          parameter_type,
                          exit_status,
                          curvature_flag,
                          valid_state_generated_flag,
                          number_invalid_generated_states,
                          current_generated_state,
                          best_generated_state, ptr_asa_out, OPTIONS);
        if (*exit_status == INVALID_COST_FUNCTION_DERIV) {
          goto EXIT_asa;
        }
      }
#if USER_REANNEAL_COST
#else
      if (OPTIONS->Reanneal_Cost == 0 || OPTIONS->Reanneal_Cost == 1) {
        ;
      } else {
        immediate_flag = OPTIONS->Immediate_Exit;

        if (OPTIONS->Reanneal_Cost < -1) {
          tmp_var_int = -OPTIONS->Reanneal_Cost;
        } else {
          tmp_var_int = OPTIONS->Reanneal_Cost;
        }
        tmp_var_db1 = ZERO;
        tmp_var_db2 = ZERO;

        for (index_cost_constraint = 0;
             index_cost_constraint < tmp_var_int; ++index_cost_constraint) {
          OPTIONS->Locate_Cost = 4;     /* reanneal cost */

          *number_invalid_generated_states = 0;
          repeated_invalid_states = 0;
          OPTIONS->Sequential_Parameters = *start_sequence - 1;
          do {
#if ASA_EXIT_ANYTIME
            if ((ptr_exit_anytime = fopen ("asa_exit_anytime", "r")) == NULL) {
              *exit_status = IMMEDIATE_EXIT;
              goto EXIT_asa;
            } else {
              fclose (ptr_exit_anytime);
            }
#endif /* ASA_EXIT_ANYTIME */
            ++(*number_invalid_generated_states);
            generate_flg = generate_new_state (user_random_generator,
                                               seed,
                                               parameter_minimum,
                                               parameter_maximum,
                                               current_user_parameter_temp,
#if USER_GENERATING_FUNCTION
                                               initial_user_parameter_temp,
                                               temperature_scale_parameters,
#endif
                                               number_parameters,
                                               parameter_type,
                                               current_generated_state,
                                               last_saved_state, OPTIONS);
            *valid_state_generated_flag = TRUE;
#if USER_ACCEPTANCE_TEST
            OPTIONS->User_Acceptance_Flag = TRUE;
            OPTIONS->Cost_Acceptance_Flag = FALSE;
#endif

#if ASA_QUEUE
            if (OPTIONS->Queue_Size == 0) {
              queue_new = 1;
            } else {
              queue_new = 1;
              for (queue = 0; queue < save_queue; ++queue) {
                save_queue_test = 0;
                VFOR (index_v) {
                  if (PARAMETER_RANGE_TOO_SMALL (index_v)) {
                    ++save_queue_test;
                  } else {
                    queue_v =
                      index_v + queue * (LONG_INT) (*number_parameters);
                    if (
#if ASA_RESOLUTION
                         /* Coarse_Resolution used in current_generated_state */
                         fabs (current_generated_state->parameter[index_v] -
                               save_queue_param[queue_v]) < EPS_DOUBLE
#else
                         fabs (current_generated_state->parameter[index_v] -
                               save_queue_param[queue_v]) <
                         (OPTIONS->Queue_Resolution[index_v] + EPS_DOUBLE)
#endif /* ASA_RESOLUTION */
                      ) {
                      ++save_queue_test;
                    }
                  }
                }
                if (save_queue_test == *number_parameters) {
                  tmp_var_db = save_queue_cost[queue];
                  queue_new = 0;
                  *valid_state_generated_flag = save_queue_flag[queue];
                  if (*valid_state_generated_flag == FALSE) {
#if ASA_PRINT_MORE
#if INT_LONG
                    fprintf (ptr_asa_out,
                             "ASA_QUEUE: %ld \t previous invalid state",
                             OPTIONS->N_Generated);
#else
                    fprintf (ptr_asa_out,
                             "ASA_QUEUE: %d \t previous invalid state",
                             OPTIONS->N_Generated);
#endif
#endif /* ASA_PRINT_MORE */
                  } else {
#if ASA_PRINT_MORE
#if INT_LONG
                    fprintf (ptr_asa_out, "ASA_QUEUE: %ld \t %*.*g\n",
                             OPTIONS->N_Generated,
                             G_FIELD, G_PRECISION, tmp_var_db);
#else
                    fprintf (ptr_asa_out, "ASA_QUEUE: %d \t %*.*g\n",
                             OPTIONS->N_Generated,
                             G_FIELD, G_PRECISION, tmp_var_db);
#endif
#endif /* ASA_PRINT_MORE */
                  }
                  break;
                }
              }
            }
            if (queue_new == 1) {
              tmp_var_db =
                user_cost_function (current_generated_state->parameter,
                                    parameter_minimum, parameter_maximum,
                                    tangents, curvature, number_parameters,
                                    parameter_type,
                                    valid_state_generated_flag, exit_status,
                                    OPTIONS);
              if (cost_function_test
                  (tmp_var_db, current_generated_state->parameter,
                   parameter_minimum, parameter_maximum, number_parameters,
                   xnumber_parameters) == 0) {
                *exit_status = INVALID_COST_FUNCTION;
                goto EXIT_asa;
              }
              if (OPTIONS->Queue_Size > 0) {
                VFOR (index_v) {
                  if (PARAMETER_RANGE_TOO_SMALL (index_v)) {
                    continue;
                  }
                  queue_v = index_v + save_queue
                    * (LONG_INT) (*number_parameters);
                  save_queue_param[queue_v] =
                    current_generated_state->parameter[index_v];
                }
                save_queue_cost[save_queue] = tmp_var_db;
                save_queue_flag[save_queue]
                  = *valid_state_generated_flag;

                ++save_queue;
                if (save_queue == (LONG_INT) OPTIONS->Queue_Size)
                  --save_queue;

                ++save_queue_indx;
                if (save_queue_indx == (LONG_INT) OPTIONS->Queue_Size)
                  save_queue_indx = 0;
              }
            }
#else /* ASA_QUEUE */
            tmp_var_db =
              user_cost_function (current_generated_state->parameter,
                                  parameter_minimum, parameter_maximum,
                                  tangents, curvature, number_parameters,
                                  parameter_type, valid_state_generated_flag,
                                  exit_status, OPTIONS);
            if (cost_function_test
                (tmp_var_db, current_generated_state->parameter,
                 parameter_minimum, parameter_maximum, number_parameters,
                 xnumber_parameters) == 0) {
              *exit_status = INVALID_COST_FUNCTION;
              goto EXIT_asa;
            }
#endif /* ASA_QUEUE */
            ++repeated_invalid_states;
            if (repeated_invalid_states >
                OPTIONS->Limit_Invalid_Generated_States) {
              *exit_status = TOO_MANY_INVALID_STATES;
              goto EXIT_asa;
            }
          }
          while (*valid_state_generated_flag == FALSE);
          --(*number_invalid_generated_states);

          tmp_var_db1 += tmp_var_db;
          tmp_var_db2 += (tmp_var_db * tmp_var_db);
        }
        tmp_var_db1 /= (double) tmp_var_int;
        tmp_var_db2 /= (double) tmp_var_int;
        tmp_var_db =
          sqrt (fabs
                ((tmp_var_db2 -
                  tmp_var_db1 * tmp_var_db1) * ((double) tmp_var_int /
                                                ((double) tmp_var_int -
                                                 ONE))));
        if (OPTIONS->Reanneal_Cost < -1) {
          *current_cost_temperature = *initial_cost_temperature =
            tmp_var_db + (double) EPS_DOUBLE;
        } else {
          *initial_cost_temperature = tmp_var_db + (double) EPS_DOUBLE;
        }
        OPTIONS->Immediate_Exit = immediate_flag;
      }
#endif /* USER_REANNEAL_COST */

      reanneal (parameter_minimum,
                parameter_maximum,
                tangents,
                maximum_tangent,
                current_cost_temperature,
                initial_cost_temperature,
                temperature_scale_cost,
                current_user_parameter_temp,
                initial_user_parameter_temp,
                temperature_scale_parameters,
                number_parameters,
                parameter_type,
                index_cost_acceptances,
                index_parameter_generations,
                last_saved_state, best_generated_state, OPTIONS);
#if ASA_PRINT_INTERMED
#if ASA_PRINT
      print_state (parameter_minimum,
                   parameter_maximum,
                   tangents,
                   curvature,
                   current_cost_temperature,
                   current_user_parameter_temp,
                   accepted_to_generated_ratio,
                   number_parameters,
                   curvature_flag,
                   number_accepted,
                   index_cost_acceptances,
                   number_generated,
                   number_invalid_generated_states,
                   last_saved_state,
                   best_generated_state, ptr_asa_out, OPTIONS);

      fprintf (ptr_asa_out, "\n");
      fflush (ptr_asa_out);
#endif
#endif
    }
  }

  /* FINISHED ANNEALING and MINIMIZATION */

  *exit_status = NORMAL_EXIT;

EXIT_asa:

  asa_exit_value = asa_exit (user_cost_function,
                             &final_cost,
                             parameter_initial_final,
                             parameter_minimum,
                             parameter_maximum,
                             tangents,
                             curvature,
                             maximum_tangent,
                             current_cost_temperature,
                             initial_user_parameter_temp,
                             current_user_parameter_temp,
                             accepted_to_generated_ratio,
                             number_parameters,
                             parameter_type,
                             valid_state_generated_flag,
                             exit_status,
                             index_exit_v,
                             start_sequence,
                             number_accepted,
                             best_number_accepted_saved,
                             index_cost_acceptances,
                             number_generated,
                             number_invalid_generated_states,
                             index_parameter_generations,
                             best_number_generated_saved,
                             current_generated_state,
                             last_saved_state,
                             best_generated_state, ptr_asa_out, OPTIONS);
  if (asa_exit_value == 9) {
    *exit_status = CALLOC_FAILED;
    return (-1);
  }

  free (curvature_flag);
  free (maximum_tangent);
  free (accepted_to_generated_ratio);
  free (temperature_scale_cost);
  free (current_cost_temperature);
  free (initial_cost_temperature);
  free (number_generated);
  free (best_number_generated_saved);
  free (recent_number_generated);
  free (number_accepted);
  free (recent_number_acceptances);
  free (index_cost_acceptances);
  free (number_acceptances_saved);
  free (best_number_accepted_saved);
  free (number_invalid_generated_states);
  free (current_generated_state->parameter);
  free (last_saved_state->parameter);
  free (best_generated_state->parameter);
  free (current_generated_state);
  free (last_saved_state);
  free (best_generated_state);
#if ASA_QUEUE
  free (save_queue_flag);
  free (save_queue_cost);
  free (save_queue_param);
#endif /* ASA_QUEUE */
#if MULTI_MIN
  for (multi_index = 0; multi_index <= OPTIONS->Multi_Number; ++multi_index)
    free (multi_params[multi_index]);
  free (multi_params);
  free (multi_sort);
  free (multi_cost);
#endif
#if ASA_PARALLEL
  for (i_prll = 0; i_prll < OPTIONS->Gener_Block_Max; ++i_prll) {
    free (gener_block_state[i_prll].parameter);
  }
  free (gener_block_state);
  free (parallel_sort);
  free (parallel_gen_ratio_block);
  free (generate_flg_par);
  free (number_invalid_generated_states_par);
  free (repeated_invalid_states_par);
  free (tmp_var_db1_par);
  free (tmp_var_db_par);
  free (valid_state_generated_flag_par);
#if ASA_QUEUE
  free (queue_par_cost);
  for (i_prll = 0; i_prll < OPTIONS->Gener_Block_Max; ++i_prll) {
    free (save_queue_param_par[i_prll]);
    free (save_queue_valid_state_flag_par[i_prll]);
    free (save_queue_cost_par[i_prll]);
  }
  free (save_queue_valid_state_flag_par);
  free (save_queue_cost_par);
  free (save_queue_param_par);
  free (queue_new_par);
  free (queue_v_par);
  free (save_queue_indx_par);
  free (save_queue_test_par);
  free (save_queue_par);
#endif /* ASA_QUEUE */
#endif /* ASA_PARALLEL */
#if ASA_PIPE_FILE
  fclose (ptr_asa_pipe);
#endif
  free (initial_user_parameter_temp);
  free (index_exit_v);
  free (start_sequence);
  free (index_parameter_generations);
  free (current_user_parameter_temp);
  free (temperature_scale_parameters);
  if (recursive_asa_open == 0)
    asa_open = FALSE;
  return (final_cost);
}

/***********************************************************************
* asa_exit
*	This procedures copies the best parameters and cost into
*       final_cost and parameter_initial_final
***********************************************************************/
#if HAVE_ANSI
int
asa_exit (double (*user_cost_function)

           
          (double *, double *, double *, double *, double *, ALLOC_INT *,
           int *, int *, int *, USER_DEFINES *), double *final_cost,
          double *parameter_initial_final, double *parameter_minimum,
          double *parameter_maximum, double *tangents, double *curvature,
          double *maximum_tangent, double *current_cost_temperature,
          double *initial_user_parameter_temp,
          double *current_user_parameter_temp,
          double *accepted_to_generated_ratio,
          ALLOC_INT * number_parameters, int *parameter_type,
          int *valid_state_generated_flag, int *exit_status,
          ALLOC_INT * index_exit_v, ALLOC_INT * start_sequence,
          LONG_INT * number_accepted,
          LONG_INT * best_number_accepted_saved,
          LONG_INT * index_cost_acceptances, LONG_INT * number_generated,
          LONG_INT * number_invalid_generated_states,
          LONG_INT * index_parameter_generations,
          LONG_INT * best_number_generated_saved,
          STATE * current_generated_state, STATE * last_saved_state,
          STATE * best_generated_state, FILE * ptr_asa_out,
          USER_DEFINES * OPTIONS)
#else
int

asa_exit (user_cost_function,
          final_cost,
          parameter_initial_final,
          parameter_minimum,
          parameter_maximum,
          tangents,
          curvature,
          maximum_tangent,
          current_cost_temperature,
          initial_user_parameter_temp,
          current_user_parameter_temp,
          accepted_to_generated_ratio,
          number_parameters,
          parameter_type,
          valid_state_generated_flag,
          exit_status,
          index_exit_v,
          start_sequence,
          number_accepted,
          best_number_accepted_saved,
          index_cost_acceptances,
          number_generated,
          number_invalid_generated_states,
          index_parameter_generations,
          best_number_generated_saved,
          current_generated_state,
          last_saved_state, best_generated_state, ptr_asa_out, OPTIONS)
     double (*user_cost_function) ();
     double *final_cost;
     double *parameter_initial_final;
     double *parameter_minimum;
     double *parameter_maximum;
     double *tangents;
     double *curvature;
     double *maximum_tangent;
     double *current_cost_temperature;
     double *initial_user_parameter_temp;
     double *current_user_parameter_temp;
     double *accepted_to_generated_ratio;
     ALLOC_INT *number_parameters;
     int *parameter_type;
     int *valid_state_generated_flag;
     int *exit_status;
     ALLOC_INT *index_exit_v;
     ALLOC_INT *start_sequence;
     LONG_INT *number_accepted;
     LONG_INT *best_number_accepted_saved;
     LONG_INT *index_cost_acceptances;
     LONG_INT *number_generated;
     LONG_INT *number_invalid_generated_states;
     LONG_INT *index_parameter_generations;
     LONG_INT *best_number_generated_saved;
     STATE *current_generated_state;
     STATE *last_saved_state;
     STATE *best_generated_state;
     FILE *ptr_asa_out;
     USER_DEFINES *OPTIONS;
#endif
{
  ALLOC_INT index_v;            /* iteration index */
  int curvatureFlag;
  int exit_exit_status, tmp_locate;
#if MULTI_MIN
  int multi_index;
#endif

  tmp_locate = OPTIONS->Locate_Cost;
  if (tmp_locate) {             /* stop compiler warning */
    ;
  }

  exit_exit_status = 0;

  /* return final function minimum and associated parameters */
  *final_cost = best_generated_state->cost;
  VFOR (index_v) {
    parameter_initial_final[index_v] =
      best_generated_state->parameter[index_v];
  }

  OPTIONS->N_Accepted = *best_number_accepted_saved;
  OPTIONS->N_Generated = *best_number_generated_saved;

#if MULTI_MIN
  for (multi_index = OPTIONS->Multi_Number - 1; multi_index >= 0;
       --multi_index) {
    best_generated_state->cost = OPTIONS->Multi_Cost[multi_index];
    VFOR (index_v) {
      best_generated_state->parameter[index_v] =
        OPTIONS->Multi_Params[multi_index][index_v];
    }
#if ASA_PRINT
    fprintf (ptr_asa_out, "\n\t\t multi_index = %d\n", multi_index);
#endif /* ASA_PRINT */
#endif /* MULTI_MIN */
    if (*exit_status != TOO_MANY_INVALID_STATES
        && *exit_status != IMMEDIATE_EXIT
        && *exit_status != INVALID_USER_INPUT
        && *exit_status != INVALID_COST_FUNCTION
        && *exit_status != INVALID_COST_FUNCTION_DERIV) {
      if (OPTIONS->Curvature_0 != TRUE)
        OPTIONS->Locate_Cost = 5;       /* calc curvatures while exiting asa */

      /* calculate curvatures and tangents at best point */
      curvatureFlag = TRUE;
      cost_derivatives (user_cost_function,
                        parameter_minimum,
                        parameter_maximum,
                        tangents,
                        curvature,
                        maximum_tangent,
                        number_parameters,
                        parameter_type,
                        &exit_exit_status,
                        &curvatureFlag,
                        valid_state_generated_flag,
                        number_invalid_generated_states,
                        current_generated_state,
                        best_generated_state, ptr_asa_out, OPTIONS);
    }
#if ASA_PRINT
    if (exit_exit_status == INVALID_COST_FUNCTION_DERIV)
      fprintf (ptr_asa_out, "\n\n  in asa_exit: INVALID_COST_FUNCTION_DERIV");

    if (*exit_status != INVALID_USER_INPUT
        && *exit_status != INVALID_COST_FUNCTION
        && *exit_status != INVALID_COST_FUNCTION_DERIV)
      print_state (parameter_minimum,
                   parameter_maximum,
                   tangents,
                   curvature,
                   current_cost_temperature,
                   current_user_parameter_temp,
                   accepted_to_generated_ratio,
                   number_parameters,
                   &curvatureFlag,
                   number_accepted,
                   index_cost_acceptances,
                   number_generated,
                   number_invalid_generated_states,
                   last_saved_state,
                   best_generated_state, ptr_asa_out, OPTIONS);
#endif /* ASA_PRINT */

#if MULTI_MIN
  }
  best_generated_state->cost = OPTIONS->Multi_Cost[0];
  VFOR (index_v) {
    best_generated_state->parameter[index_v] =
      OPTIONS->Multi_Params[0][index_v];
  }
#endif /* MULTI_MIN */

#if ASA_PRINT
  switch (*exit_status) {
  case NORMAL_EXIT:
    fprintf (ptr_asa_out,
             "\n\n NORMAL_EXIT exit_status = %d\n", *exit_status);
    break;
  case P_TEMP_TOO_SMALL:
    fprintf (ptr_asa_out,
             "\n\n P_TEMP_TOO_SMALL exit_status = %d\n", *exit_status);
    fprintf (ptr_asa_out,
#if INT_ALLOC
             "current_user_parameter_temp[%d] too small = %*.*g\n",
#else
#if INT_LONG
             "current_user_parameter_temp[%ld] too small = %*.*g\n",
#else
             "current_user_parameter_temp[%d] too small = %*.*g\n",
#endif
#endif
             *index_exit_v,
             G_FIELD, G_PRECISION,
             current_user_parameter_temp[*index_exit_v]);
    break;
  case C_TEMP_TOO_SMALL:
    fprintf (ptr_asa_out,
             "\n\n C_TEMP_TOO_SMALL exit_status = %d\n", *exit_status);
    fprintf (ptr_asa_out,
             "*current_cost_temperature too small = %*.*g\n",
             G_FIELD, G_PRECISION, *current_cost_temperature);
    break;
  case COST_REPEATING:
    fprintf (ptr_asa_out,
             "\n\n COST_REPEATING exit_status = %d\n", *exit_status);
    break;
  case TOO_MANY_INVALID_STATES:
    fprintf (ptr_asa_out,
             "\n\n  TOO_MANY_INVALID_STATES exit_status = %d\n",
             *exit_status);
    break;
  case IMMEDIATE_EXIT:
    fprintf (ptr_asa_out,
             "\n\n  IMMEDIATE_EXIT exit_status = %d\n", *exit_status);
    break;
  case INVALID_USER_INPUT:
    fprintf (ptr_asa_out,
             "\n\n  INVALID_USER_INPUT exit_status = %d\n", *exit_status);
    break;
  case INVALID_COST_FUNCTION:
    fprintf (ptr_asa_out,
             "\n\n  INVALID_COST_FUNCTION exit_status = %d\n", *exit_status);
    break;
  case INVALID_COST_FUNCTION_DERIV:
    fprintf (ptr_asa_out,
             "\n\n  INVALID_COST_FUNCTION_DERIV exit_status = %d\n",
             *exit_status);
    break;
  default:
    fprintf (ptr_asa_out, "\n\n ERR: no exit code available = %d\n",
             *exit_status);
  }

  switch (OPTIONS->Locate_Cost) {
  case 0:
    fprintf (ptr_asa_out,
             " Locate_Cost = %d, initial cost temperature\n",
             OPTIONS->Locate_Cost);
    break;
  case 1:
    fprintf (ptr_asa_out,
             " Locate_Cost = %d, initial cost value\n", OPTIONS->Locate_Cost);
    break;
  case 2:
    fprintf (ptr_asa_out,
             " Locate_Cost = %d, new generated state\n",
             OPTIONS->Locate_Cost);
    break;
  case 12:
    fprintf (ptr_asa_out,
             " Locate_Cost = %d, new generated state just after a new best state\n",
             OPTIONS->Locate_Cost);
    break;
  case 3:
    fprintf (ptr_asa_out,
             " Locate_Cost = %d, cost derivatives, reannealing parameters\n",
             OPTIONS->Locate_Cost);
    break;
  case 4:
    fprintf (ptr_asa_out,
             " Locate_Cost = %d, reannealing cost temperature\n",
             OPTIONS->Locate_Cost);
    break;
  case 5:
    fprintf (ptr_asa_out,
             " Locate_Cost = %d, calculating curvatures while exiting asa ()\n",
             OPTIONS->Locate_Cost);
    break;
  case -1:
    fprintf (ptr_asa_out,
             " Locate_Cost = %d, exited main asa () loop by user-defined OPTIONS\n",
             OPTIONS->Locate_Cost);
    break;
  default:
    fprintf (ptr_asa_out,
             " Locate_Cost = %d, no index available for Locate_Cost\n",
             OPTIONS->Locate_Cost);
  }

  if (*exit_status != INVALID_USER_INPUT
      && *exit_status != INVALID_COST_FUNCTION
      && *exit_status != INVALID_COST_FUNCTION_DERIV) {
    fprintf (ptr_asa_out,
             "final_cost = best_generated_state->cost = %-*.*g\n",
             G_FIELD, G_PRECISION, *final_cost);
#if INT_LONG
    fprintf (ptr_asa_out,
             "*number_accepted at best_generated_state->cost = %ld\n",
             *best_number_accepted_saved);
    fprintf (ptr_asa_out,
             "*number_generated at best_generated_state->cost = %ld\n",
             *best_number_generated_saved);
#else
    fprintf (ptr_asa_out,
             "*number_accepted at best_generated_state->cost = %d\n",
             *best_number_accepted_saved);
    fprintf (ptr_asa_out,
             "*number_generated at best_generated_state->cost = %d\n",
             *best_number_generated_saved);
#endif
  }
#endif

#if ASA_TEMPLATE_SELFOPT
  if (OPTIONS->Asa_Data_Dbl[0] > (double) MIN_DOUBLE)
    OPTIONS->Asa_Data_Dbl[1] = (double) (*best_number_generated_saved);
#endif

  /* reset OPTIONS->Sequential_Parameters */
  OPTIONS->Sequential_Parameters = *start_sequence;

#if ASA_PRINT
#if TIME_CALC
  /* print ending time */
  print_time ("asa_end", ptr_asa_out);
#endif
  fprintf (ptr_asa_out, "\n\n\n");
#endif
  fflush (ptr_asa_out);
  fclose (ptr_asa_out);

  return (0);
}

/***********************************************************************
* generate_new_state
*       Generates a valid new state from the old state
***********************************************************************/
#if HAVE_ANSI
int

generate_new_state (double (*user_random_generator) (LONG_INT *),
                    LONG_INT * seed,
                    double *parameter_minimum,
                    double *parameter_maximum,
                    double *current_user_parameter_temp,
#if USER_GENERATING_FUNCTION
                    double *initial_user_parameter_temp,
                    double *temperature_scale_parameters,
#endif
                    ALLOC_INT * number_parameters,
                    int *parameter_type,
                    STATE * current_generated_state,
                    STATE * last_saved_state, USER_DEFINES * OPTIONS)
#else
int

generate_new_state (user_random_generator,
                    seed,
                    parameter_minimum,
                    parameter_maximum, current_user_parameter_temp,
#if USER_GENERATING_FUNCTION
                    initial_user_parameter_temp, temperature_scale_parameters,
#endif
                    number_parameters,
                    parameter_type,
                    current_generated_state, last_saved_state, OPTIONS)
     double (*user_random_generator) ();
     LONG_INT *seed;
     double *parameter_minimum;
     double *parameter_maximum;
     double *current_user_parameter_temp;
#if USER_GENERATING_FUNCTION
     double *initial_user_parameter_temp;
     double *temperature_scale_parameters;
#endif
     ALLOC_INT *number_parameters;
     int *parameter_type;
     STATE *current_generated_state;
     STATE *last_saved_state;
     USER_DEFINES *OPTIONS;
#endif
{
  ALLOC_INT index_v;
  double x;
  double parameter_v, min_parameter_v, max_parameter_v, temperature_v,
    parameter_range_v;
#if USER_GENERATING_FUNCTION
  double init_param_temp_v;
  double temp_scale_params_v;
#endif
#if ASA_RESOLUTION
  double xres, xint, xminus, xplus, dx, dxminus, dxplus;
#endif

  /* generate a new value for each parameter */
  VFOR (index_v) {
    if (OPTIONS->Sequential_Parameters >= -1) {
      ++OPTIONS->Sequential_Parameters;
      if (OPTIONS->Sequential_Parameters == *number_parameters)
        OPTIONS->Sequential_Parameters = 0;
      index_v = OPTIONS->Sequential_Parameters;
    }
    min_parameter_v = parameter_minimum[index_v];
    max_parameter_v = parameter_maximum[index_v];
    parameter_range_v = max_parameter_v - min_parameter_v;

    /* ignore parameters that have too small a range */
    if (fabs (parameter_range_v) < (double) EPS_DOUBLE)
      continue;

    temperature_v = current_user_parameter_temp[index_v];
#if USER_GENERATING_FUNCTION
    init_param_temp_v = initial_user_parameter_temp[index_v];
    temp_scale_params_v = temperature_scale_parameters[index_v];
#endif
    parameter_v = last_saved_state->parameter[index_v];

    /* Handle discrete parameters. */
#if ASA_RESOLUTION
    xres = OPTIONS->Coarse_Resolution[index_v];
    if (xres > EPS_DOUBLE) {
      min_parameter_v -= (xres / TWO);
      max_parameter_v += (xres / TWO);
      parameter_range_v = max_parameter_v - min_parameter_v;
    }
#endif /* ASA_RESOLUTION */
    if (INTEGER_PARAMETER (index_v)) {
#if ASA_RESOLUTION
      if (xres > EPS_DOUBLE) {
        ;
      } else {
#endif /* ASA_RESOLUTION */
        min_parameter_v -= HALF;
        max_parameter_v += HALF;
        parameter_range_v = max_parameter_v - min_parameter_v;
      }
#if ASA_RESOLUTION
    }
#endif

    /* generate a new state x within the parameter bounds */
    for (;;) {
#if USER_GENERATING_FUNCTION
      x = OPTIONS->Generating_Distrib (seed,
                                       number_parameters,
                                       index_v,
                                       temperature_v,
                                       init_param_temp_v,
                                       temp_scale_params_v,
                                       parameter_v,
                                       parameter_range_v,
                                       last_saved_state->parameter, OPTIONS);
#else
      x = parameter_v
        + generate_asa_state (user_random_generator, seed, &temperature_v)
        * parameter_range_v;
#endif /* USER_GENERATING_FUNCTION */
#if ASA_RESOLUTION
      if (xres > EPS_DOUBLE) {
        xint = xres * (double) ((LONG_INT) (x / xres));
        xplus = xint + xres;
        xminus = xint - xres;
        dx = fabs (xint - x);
        dxminus = fabs (xminus - x);
        dxplus = fabs (xplus - x);

        if (dx < dxminus && dx < dxplus)
          x = xint;
        else if (dxminus < dxplus)
          x = xminus;
        else
          x = xplus;
      }
#endif /* ASA_RESOLUTION */

      /* exit the loop if within its valid parameter range */
      if (x <= max_parameter_v - (double) EPS_DOUBLE
          && x >= min_parameter_v + (double) EPS_DOUBLE)
        break;
    }

    /* Handle discrete parameters.
       You might have to check rounding on your machine. */
    if (INTEGER_PARAMETER (index_v)) {
#if ASA_RESOLUTION
      if (xres > EPS_DOUBLE) {
        ;
      } else {
#endif /* ASA_RESOLUTION */
        if (x < min_parameter_v + HALF)
          x = min_parameter_v + HALF + (double) EPS_DOUBLE;
        if (x > max_parameter_v - HALF)
          x = max_parameter_v - HALF + (double) EPS_DOUBLE;

        if (x + HALF > ZERO) {
          x = (double) ((LONG_INT) (x + HALF));
        } else {
          x = (double) ((LONG_INT) (x - HALF));
        }
        if (x > parameter_maximum[index_v])
          x = parameter_maximum[index_v];
        if (x < parameter_minimum[index_v])
          x = parameter_minimum[index_v];
      }
#if ASA_RESOLUTION
    }
    if (xres > EPS_DOUBLE) {
      if (x < min_parameter_v + xres / TWO)
        x = min_parameter_v + xres / TWO + (double) EPS_DOUBLE;
      if (x > max_parameter_v - xres / TWO)
        x = max_parameter_v - xres / TWO + (double) EPS_DOUBLE;

      if (x > parameter_maximum[index_v])
        x = parameter_maximum[index_v];
      if (x < parameter_minimum[index_v])
        x = parameter_minimum[index_v];
    }
#endif /* ASA_RESOLUTION */

    /* save the newly generated value */
    current_generated_state->parameter[index_v] = x;

    if (OPTIONS->Sequential_Parameters >= 0)
      break;
  }
  return (0);
}

#if ASA_PARALLEL
/***********************************************************************
* generate_new_state_par
*       Generates a valid new state from the old state
***********************************************************************/
#if HAVE_ANSI
int

generate_new_state_par (double (*user_random_generator) (LONG_INT *),
                        LONG_INT * seed,
                        double *parameter_minimum,
                        double *parameter_maximum,
                        double *current_user_parameter_temp,
#if USER_GENERATING_FUNCTION
                        double *initial_user_parameter_temp,
                        double *temperature_scale_parameters,
#endif
                        ALLOC_INT * number_parameters,
                        int *parameter_type,
                        LONG_INT i_prll,
                        STATE * gener_block_state,
                        STATE * last_saved_state, USER_DEFINES * OPTIONS)
#else
int

generate_new_state_par (user_random_generator,
                        seed,
                        parameter_minimum,
                        parameter_maximum, current_user_parameter_temp,
#if USER_GENERATING_FUNCTION
                        initial_user_parameter_temp,
                        temperature_scale_parameters,
#endif
                        number_parameters,
                        parameter_type,
                        i_prll, gener_block_state, last_saved_state, OPTIONS)
     double (*user_random_generator) ();
     LONG_INT *seed;
     double *parameter_minimum;
     double *parameter_maximum;
     double *current_user_parameter_temp;
#if USER_GENERATING_FUNCTION
     double *initial_user_parameter_temp;
     double *temperature_scale_parameters;
#endif
     ALLOC_INT *number_parameters;
     int *parameter_type;
     LONG_INT i_prll;
     STATE *gener_block_state;
     STATE *last_saved_state;
     USER_DEFINES *OPTIONS;
#endif
{
  ALLOC_INT index_v;
  double x;
  double parameter_v, min_parameter_v, max_parameter_v, temperature_v,
    parameter_range_v;
#if USER_GENERATING_FUNCTION
  double init_param_temp_v;
  double temp_scale_params_v;
#endif
#if ASA_RESOLUTION
  double xres, xint, xminus, xplus, dx, dxminus, dxplus;
#endif

  /* generate a new value for each parameter */
  VFOR (index_v) {
    if (OPTIONS->Sequential_Parameters >= -1) {
      ++OPTIONS->Sequential_Parameters;
      if (OPTIONS->Sequential_Parameters == *number_parameters)
        OPTIONS->Sequential_Parameters = 0;
      index_v = OPTIONS->Sequential_Parameters;
    }
    min_parameter_v = parameter_minimum[index_v];
    max_parameter_v = parameter_maximum[index_v];
    parameter_range_v = max_parameter_v - min_parameter_v;

    /* ignore parameters that have too small a range */
    if (fabs (parameter_range_v) < (double) EPS_DOUBLE)
      continue;

    temperature_v = current_user_parameter_temp[index_v];
#if USER_GENERATING_FUNCTION
    init_param_temp_v = initial_user_parameter_temp[index_v];
    temp_scale_params_v = temperature_scale_parameters[index_v];
#endif
    parameter_v = last_saved_state->parameter[index_v];

    /* Handle discrete parameters. */
#if ASA_RESOLUTION
    xres = OPTIONS->Coarse_Resolution[index_v];
    if (xres > EPS_DOUBLE) {
      min_parameter_v -= (xres / TWO);
      max_parameter_v += (xres / TWO);
      parameter_range_v = max_parameter_v - min_parameter_v;
    }
#endif /* ASA_RESOLUTION */
    if (INTEGER_PARAMETER (index_v)) {
#if ASA_RESOLUTION
      if (xres > EPS_DOUBLE) {
        ;
      } else {
#endif /* ASA_RESOLUTION */
        min_parameter_v -= HALF;
        max_parameter_v += HALF;
        parameter_range_v = max_parameter_v - min_parameter_v;
      }
#if ASA_RESOLUTION
    }
#endif

    /* generate a new state x within the parameter bounds */
    for (;;) {
#if USER_GENERATING_FUNCTION
      x = OPTIONS->Generating_Distrib (seed,
                                       number_parameters,
                                       index_v,
                                       temperature_v,
                                       init_param_temp_v,
                                       temp_scale_params_v,
                                       parameter_v,
                                       parameter_range_v,
                                       last_saved_state->parameter, OPTIONS);
#else
      x = parameter_v
        + generate_asa_state (user_random_generator, seed, &temperature_v)
        * parameter_range_v;
#endif /* USER_GENERATING_FUNCTION */
#if ASA_RESOLUTION
      if (xres > EPS_DOUBLE) {
        xint = xres * (double) ((LONG_INT) (x / xres));
        xplus = xint + xres;
        xminus = xint - xres;
        dx = fabs (xint - x);
        dxminus = fabs (xminus - x);
        dxplus = fabs (xplus - x);

        if (dx < dxminus && dx < dxplus)
          x = xint;
        else if (dxminus < dxplus)
          x = xminus;
        else
          x = xplus;
      }
#endif /* ASA_RESOLUTION */

      /* exit the loop if within its valid parameter range */
      if (x <= max_parameter_v - (double) EPS_DOUBLE
          && x >= min_parameter_v + (double) EPS_DOUBLE)
        break;
    }

    /* Handle discrete parameters.
       You might have to check rounding on your machine. */
    if (INTEGER_PARAMETER (index_v)) {
#if ASA_RESOLUTION
      if (xres > EPS_DOUBLE) {
        ;
      } else {
#endif /* ASA_RESOLUTION */
        if (x < min_parameter_v + HALF)
          x = min_parameter_v + HALF + (double) EPS_DOUBLE;
        if (x > max_parameter_v - HALF)
          x = max_parameter_v - HALF + (double) EPS_DOUBLE;

        if (x + HALF > ZERO) {
          x = (double) ((LONG_INT) (x + HALF));
        } else {
          x = (double) ((LONG_INT) (x - HALF));
        }
        if (x > parameter_maximum[index_v])
          x = parameter_maximum[index_v];
        if (x < parameter_minimum[index_v])
          x = parameter_minimum[index_v];
      }
#if ASA_RESOLUTION
    }
    if (xres > EPS_DOUBLE) {
      if (x < min_parameter_v + xres / TWO)
        x = min_parameter_v + xres / TWO + (double) EPS_DOUBLE;
      if (x > max_parameter_v - xres / TWO)
        x = max_parameter_v - xres / TWO + (double) EPS_DOUBLE;

      if (x > parameter_maximum[index_v])
        x = parameter_maximum[index_v];
      if (x < parameter_minimum[index_v])
        x = parameter_minimum[index_v];
    }
#endif /* ASA_RESOLUTION */

    /* save the newly generated value */
    gener_block_state[i_prll].parameter[index_v] = x;

    if (OPTIONS->Sequential_Parameters >= 0)
      break;
  }
  return (0);
}

#endif /* ASA_PARALLEL */

/***********************************************************************
* generate_asa_state
*       This function generates a single value according to the
*       ASA generating function and the passed temperature
***********************************************************************/
#if HAVE_ANSI
double

generate_asa_state (double (*user_random_generator) (LONG_INT *),
                    LONG_INT * seed, double *temp)
#else
double
generate_asa_state (user_random_generator, seed, temp)
     double (*user_random_generator) ();
     LONG_INT *seed;
     double *temp;
#endif
{
  double x, y, z;

  x = (*user_random_generator) (seed);
  y = x < HALF ? -ONE : ONE;
  z = y * *temp * (F_POW ((ONE + ONE / *temp), fabs (TWO * x - ONE)) - ONE);

  return (z);

}

/***********************************************************************
* accept_new_state
*	This procedure accepts or rejects a newly generated state,
*	depending on whether the difference between new and old
*	cost functions passes a statistical test. If accepted,
*	the current state is updated.
***********************************************************************/
#if HAVE_ANSI
void

accept_new_state (double (*user_random_generator) (LONG_INT *),
                  LONG_INT * seed,
                  double *parameter_minimum,
                  double *parameter_maximum, double *current_cost_temperature,
#if ASA_SAMPLE
                  double *current_user_parameter_temp,
#endif
                  ALLOC_INT * number_parameters,
                  LONG_INT * recent_number_acceptances,
                  LONG_INT * number_accepted,
                  LONG_INT * index_cost_acceptances,
                  LONG_INT * number_acceptances_saved,
                  LONG_INT * recent_number_generated,
                  LONG_INT * number_generated,
                  LONG_INT * index_parameter_generations,
                  STATE * current_generated_state, STATE * last_saved_state,
#if ASA_SAMPLE
                  FILE * ptr_asa_out,
#endif
                  USER_DEFINES * OPTIONS)
#else
void

accept_new_state (user_random_generator,
                  seed,
                  parameter_minimum,
                  parameter_maximum, current_cost_temperature,
#if ASA_SAMPLE
                  current_user_parameter_temp,
#endif
                  number_parameters,
                  recent_number_acceptances,
                  number_accepted,
                  index_cost_acceptances,
                  number_acceptances_saved,
                  recent_number_generated,
                  number_generated,
                  index_parameter_generations,
                  current_generated_state, last_saved_state,
#if ASA_SAMPLE
                  ptr_asa_out,
#endif
                  OPTIONS)
     double (*user_random_generator) ();
     LONG_INT *seed;
     double *parameter_minimum;
     double *parameter_maximum;
     double *current_cost_temperature;
#if ASA_SAMPLE
     double *current_user_parameter_temp;
#endif
     ALLOC_INT *number_parameters;
     LONG_INT *recent_number_acceptances;
     LONG_INT *number_accepted;
     LONG_INT *index_cost_acceptances;
     LONG_INT *number_acceptances_saved;
     LONG_INT *recent_number_generated;
     LONG_INT *number_generated;
     LONG_INT *index_parameter_generations;
     STATE *current_generated_state;
     STATE *last_saved_state;
#if ASA_SAMPLE
     FILE *ptr_asa_out;
#endif
     USER_DEFINES *OPTIONS;

#endif
{
#if USER_ACCEPTANCE_TEST
#else
  double delta_cost;
#if USER_ACCEPT_ASYMP_EXP
  double q;
#endif
#endif
  double prob_test, unif_test;
  double curr_cost_temp;
  ALLOC_INT index_v;
#if ASA_SAMPLE
  LONG_INT active_params;
  double weight_param_ind, weight_aver, range;
#endif

  /* update accepted and generated count */
  ++*number_acceptances_saved;
  ++*recent_number_generated;
  ++*number_generated;
  OPTIONS->N_Generated = *number_generated;

  /* increment the parameter index generation for each parameter */
  if (OPTIONS->Sequential_Parameters >= 0) {
    /* ignore parameters with too small a range */
    if (!PARAMETER_RANGE_TOO_SMALL (OPTIONS->Sequential_Parameters))
      ++(index_parameter_generations[OPTIONS->Sequential_Parameters]);
  } else {
    VFOR (index_v) {
      if (!PARAMETER_RANGE_TOO_SMALL (index_v))
        ++(index_parameter_generations[index_v]);
    }
  }

  /* effective cost function for testing acceptance criteria,
     calculate the cost difference and divide by the temperature */
  curr_cost_temp = *current_cost_temperature;
#if USER_ACCEPTANCE_TEST
  if (OPTIONS->Cost_Acceptance_Flag == TRUE) {
    if (OPTIONS->User_Acceptance_Flag == TRUE) {
      unif_test = ZERO;
      OPTIONS->User_Acceptance_Flag = FALSE;
      OPTIONS->Cost_Acceptance_Flag = FALSE;
    } else {
      unif_test = ONE;
      OPTIONS->Cost_Acceptance_Flag = FALSE;
    }
  } else {
    OPTIONS->Acceptance_Test (current_generated_state->cost,
                              parameter_minimum,
                              parameter_maximum, number_parameters, OPTIONS);
    if (OPTIONS->User_Acceptance_Flag == TRUE) {
      unif_test = ZERO;
      OPTIONS->User_Acceptance_Flag = FALSE;
    } else {
      unif_test = ONE;
    }
  }
  prob_test = OPTIONS->Prob_Bias;
#else /* USER_ACCEPTANCE_TEST */

#if USER_COST_SCHEDULE
  curr_cost_temp =
    (OPTIONS->Cost_Schedule (*current_cost_temperature, OPTIONS)
     + (double) EPS_DOUBLE);
#endif
  delta_cost = (current_generated_state->cost - last_saved_state->cost)
    / (curr_cost_temp + (double) EPS_DOUBLE);

#if USER_ACCEPT_ASYMP_EXP
  q = OPTIONS->Asymp_Exp_Param;
  if (fabs (ONE - q) < (double) EPS_DOUBLE)
    prob_test = MIN (ONE, (F_EXP (EXPONENT_CHECK (-delta_cost))));
  else if ((ONE - (ONE - q) * delta_cost) < (double) EPS_DOUBLE)
    prob_test = MIN (ONE, (F_EXP (EXPONENT_CHECK (-delta_cost))));
  else
    prob_test = MIN (ONE, F_POW ((ONE - (ONE - q) * delta_cost),
                                 (ONE / (ONE - q))));
#else /* USER_ACCEPT_ASYMP_EXP */

#if USER_ACCEPT_THRESHOLD       /* USER_ACCEPT_THRESHOLD */
  prob_test = delta_cost <= 1.0 ? 1.0 : 0.0;
#else /* Metropolis */
  prob_test = MIN (ONE, (F_EXP (EXPONENT_CHECK (-delta_cost))));
#endif /* USER_ACCEPT_THRESHOLD */

#endif /* USER_ACCEPT_ASYMP_EXP */

  unif_test = (*user_random_generator) (seed);
#endif /* USER_ACCEPTANCE_TEST */

#if ASA_SAMPLE
  active_params = 0;
  weight_aver = ZERO;
  VFOR (index_v) {
    /* ignore parameters with too small a range */
    if (PARAMETER_RANGE_TOO_SMALL (index_v))
      continue;
    ++active_params;
    range = parameter_maximum[index_v] - parameter_minimum[index_v];
    weight_param_ind = TWO * (fabs ((last_saved_state->parameter[index_v]
                                     -
                                     current_generated_state->parameter
                                     [index_v]) / range)
                              + current_user_parameter_temp[index_v])
      * F_LOG (ONE + ONE / current_user_parameter_temp[index_v]);
    weight_aver += weight_param_ind;
    OPTIONS->Bias_Generated[index_v] = ONE / weight_param_ind;
  }
  weight_aver /= (double) active_params;
  OPTIONS->Average_Weights = weight_aver;
  if (prob_test >= unif_test) {
    OPTIONS->Bias_Acceptance = prob_test;
  } else {
    OPTIONS->Bias_Acceptance = ONE - prob_test;
  }

#if ASA_PRINT
  if (OPTIONS->Limit_Weights < OPTIONS->Average_Weights) {
    fprintf (ptr_asa_out, ":SAMPLE#\n");
    if (prob_test >= unif_test) {
      fprintf (ptr_asa_out,
#if INT_LONG
               ":SAMPLE+ %10ld %*.*g %*.*g %*.*g %*.*g\n",
#else
               ":SAMPLE+ %10d %*.*g %*.*g %*.*g\n",
#endif
               OPTIONS->N_Accepted,
               G_FIELD, G_PRECISION, current_generated_state->cost,
               G_FIELD, G_PRECISION, *current_cost_temperature,
               G_FIELD, G_PRECISION, OPTIONS->Bias_Acceptance,
               G_FIELD, G_PRECISION, OPTIONS->Average_Weights);
      VFOR (index_v) {
        /* ignore parameters with too small a range */
        if (PARAMETER_RANGE_TOO_SMALL (index_v))
          continue;
        range = parameter_maximum[index_v] - parameter_minimum[index_v];
        fprintf (ptr_asa_out,
#if INT_ALLOC
                 ":SAMPLE %11d %*.*g %*.*g %*.*g %*.*g\n",
#else
#if INT_LONG
                 ":SAMPLE %11ld %*.*g %*.*g %*.*g %*.*g\n",
#else
                 ":SAMPLE %11d %*.*g %*.*g %*.*g %*.*g\n",
#endif
#endif
                 index_v,
                 G_FIELD, G_PRECISION,
                 current_generated_state->parameter[index_v], G_FIELD,
                 G_PRECISION, current_user_parameter_temp[index_v],
                 G_FIELD, G_PRECISION, OPTIONS->Bias_Generated[index_v],
                 G_FIELD, G_PRECISION, range);
      }
    } else {
      fprintf (ptr_asa_out,
#if INT_LONG
               ":SAMPLE %11ld %*.*g %*.*g %*.*g %*.*g\n",
#else
               ":SAMPLE %11d %*.*g %*.*g %*.*g\n",
#endif
               OPTIONS->N_Accepted,
               G_FIELD, G_PRECISION, last_saved_state->cost,
               G_FIELD, G_PRECISION, *current_cost_temperature,
               G_FIELD, G_PRECISION, OPTIONS->Bias_Acceptance,
               G_FIELD, G_PRECISION, OPTIONS->Average_Weights);
      VFOR (index_v) {
        /* ignore parameters with too small a range */
        if (PARAMETER_RANGE_TOO_SMALL (index_v))
          continue;
        range = parameter_maximum[index_v] - parameter_minimum[index_v];
        fprintf (ptr_asa_out,
#if INT_ALLOC
                 ":SAMPLE %11d %*.*g %*.*g %*.*g %*.*g\n",
#else
#if INT_LONG
                 ":SAMPLE %11ld %*.*g %*.*g %*.*g %*.*g\n",
#else
                 ":SAMPLE %11d %*.*g %*.*g %*.*g %*.*g\n",
#endif
#endif
                 index_v,
                 G_FIELD, G_PRECISION,
                 last_saved_state->parameter[index_v], G_FIELD,
                 G_PRECISION, current_user_parameter_temp[index_v],
                 G_FIELD, G_PRECISION, OPTIONS->Bias_Generated[index_v],
                 G_FIELD, G_PRECISION, range);
      }
    }
  }
#endif
#endif /* ASA_SAMPLE */

  /* accept/reject the new state */
  if (prob_test >= unif_test) {
    /* copy current state to the last saved state */

    last_saved_state->cost = current_generated_state->cost;
    VFOR (index_v) {
      /* ignore parameters with too small a range */
      if (PARAMETER_RANGE_TOO_SMALL (index_v))
        continue;
      last_saved_state->parameter[index_v] =
        current_generated_state->parameter[index_v];
    }

    /* update acceptance counts */
    ++*recent_number_acceptances;
    ++*number_accepted;
    ++*index_cost_acceptances;
    *number_acceptances_saved = *number_accepted;
    OPTIONS->N_Accepted = *number_accepted;
  }
}

/***********************************************************************
* reanneal
*	Readjust temperatures of generating and acceptance functions
***********************************************************************/
#if HAVE_ANSI
void

reanneal (double *parameter_minimum,
          double *parameter_maximum,
          double *tangents,
          double *maximum_tangent,
          double *current_cost_temperature,
          double *initial_cost_temperature,
          double *temperature_scale_cost,
          double *current_user_parameter_temp,
          double *initial_user_parameter_temp,
          double *temperature_scale_parameters,
          ALLOC_INT * number_parameters,
          int *parameter_type,
          LONG_INT * index_cost_acceptances,
          LONG_INT * index_parameter_generations,
          STATE * last_saved_state,
          STATE * best_generated_state, USER_DEFINES * OPTIONS)
#else
void

reanneal (parameter_minimum,
          parameter_maximum,
          tangents,
          maximum_tangent,
          current_cost_temperature,
          initial_cost_temperature,
          temperature_scale_cost,
          current_user_parameter_temp,
          initial_user_parameter_temp,
          temperature_scale_parameters,
          number_parameters,
          parameter_type,
          index_cost_acceptances,
          index_parameter_generations,
          last_saved_state, best_generated_state, OPTIONS)
     double *parameter_minimum;
     double *parameter_maximum;
     double *tangents;
     double *maximum_tangent;
     double *current_cost_temperature;
     double *initial_cost_temperature;
     double *temperature_scale_cost;
     double *current_user_parameter_temp;
     double *initial_user_parameter_temp;
     double *temperature_scale_parameters;
     ALLOC_INT *number_parameters;
     int *parameter_type;
     LONG_INT *index_cost_acceptances;
     LONG_INT *index_parameter_generations;
     STATE *last_saved_state;
     STATE *best_generated_state;
     USER_DEFINES *OPTIONS;
#endif
{
  ALLOC_INT index_v;
  int cost_test;
  double tmp_var_db3;
  double new_temperature;
  double log_new_temperature_ratio;
  double log_init_cur_temp_ratio;
  double temperature_rescale_power;
  double cost_best, cost_last;
  double tmp_dbl, tmp_dbl1;

  double xnumber_parameters[1];

  cost_test = cost_function_test (last_saved_state->cost,
                                  last_saved_state->parameter,
                                  parameter_minimum,
                                  parameter_maximum, number_parameters,
                                  xnumber_parameters);

  if (OPTIONS->Reanneal_Parameters == TRUE) {
    VFOR (index_v) {
      if (NO_REANNEAL (index_v))
        continue;

      /* use the temp double to prevent overflow */
      tmp_dbl = (double) index_parameter_generations[index_v];

      /* skip parameters with too small range or integer parameters */
      if (OPTIONS->Include_Integer_Parameters == TRUE) {
        if (PARAMETER_RANGE_TOO_SMALL (index_v))
          continue;
      } else {
        if (PARAMETER_RANGE_TOO_SMALL (index_v) ||
            INTEGER_PARAMETER (index_v))
          continue;
      }

      /* ignore parameters with too small tangents */
      if (fabs (tangents[index_v]) < (double) EPS_DOUBLE)
        continue;

      /* reset the index of parameter generations appropriately */
#if USER_REANNEAL_PARAMETERS
      new_temperature =
        fabs (OPTIONS->Reanneal_Params_Function (current_user_parameter_temp
                                                 [index_v], tangents[index_v],
                                                 *maximum_tangent, OPTIONS));
#else
      new_temperature =
        fabs (FUNCTION_REANNEAL_PARAMS
              (current_user_parameter_temp[index_v], tangents[index_v],
               *maximum_tangent));
#endif
      if (new_temperature < initial_user_parameter_temp[index_v]) {
        log_init_cur_temp_ratio =
          fabs (F_LOG (((double) EPS_DOUBLE
                        + initial_user_parameter_temp[index_v])
                       / ((double) EPS_DOUBLE + new_temperature)));
        tmp_dbl = (double) EPS_DOUBLE
          + F_POW (log_init_cur_temp_ratio
                   / temperature_scale_parameters[index_v],
                   *xnumber_parameters
#if QUENCH_PARAMETERS
                   / OPTIONS->User_Quench_Param_Scale[index_v]);
#else
          );
#endif
      } else {
        tmp_dbl = ONE;
      }

      /* Reset index_parameter_generations if index reset too large,
         and also reset the initial_user_parameter_temp, to achieve
         the same new temperature. */
      while (tmp_dbl > ((double) MAXIMUM_REANNEAL_INDEX)) {
        log_new_temperature_ratio =
          -temperature_scale_parameters[index_v] * F_POW (tmp_dbl,
#if QUENCH_PARAMETERS
                                                          OPTIONS->User_Quench_Param_Scale
                                                          [index_v]
#else
                                                          ONE
#endif
                                                          /
                                                          *xnumber_parameters);
        log_new_temperature_ratio =
          EXPONENT_CHECK (log_new_temperature_ratio);
        new_temperature =
          initial_user_parameter_temp[index_v] *
          F_EXP (log_new_temperature_ratio);
        tmp_dbl /= (double) REANNEAL_SCALE;
        temperature_rescale_power = ONE / F_POW ((double) REANNEAL_SCALE,
#if QUENCH_PARAMETERS
                                                 OPTIONS->User_Quench_Param_Scale
                                                 [index_v]
#else
                                                 ONE
#endif
                                                 / *xnumber_parameters);
        initial_user_parameter_temp[index_v] =
          new_temperature * F_POW (initial_user_parameter_temp[index_v] /
                                   new_temperature,
                                   temperature_rescale_power);
      }
      /* restore from temporary double */
      index_parameter_generations[index_v] = (LONG_INT) tmp_dbl;
    }
  }

  if (OPTIONS->Reanneal_Cost == 0) {
    ;
  } else if (OPTIONS->Reanneal_Cost < -1) {
    *index_cost_acceptances = 1;
  } else {
    /* reanneal : Reset the current cost temp and rescale the
       index of cost acceptances. */

    cost_best = best_generated_state->cost;
    cost_last = last_saved_state->cost;
#if USER_REANNEAL_COST
    cost_test = OPTIONS->Reanneal_Cost_Function (&cost_best,
                                                 &cost_last,
                                                 initial_cost_temperature,
                                                 current_cost_temperature,
                                                 OPTIONS);
    tmp_dbl1 = *current_cost_temperature;
#else
    cost_test = TRUE;
    if (OPTIONS->Reanneal_Cost == 1) {
      /* (re)set the initial cost_temperature */
      tmp_dbl = MAX (fabs (cost_last), fabs (cost_best));
      tmp_dbl = MAX (tmp_dbl, fabs (cost_best - cost_last));
      tmp_dbl = MAX ((double) EPS_DOUBLE, tmp_dbl);
      *initial_cost_temperature = MIN (*initial_cost_temperature, tmp_dbl);
    }

    tmp_dbl = (double) *index_cost_acceptances;

    tmp_dbl1 = MAX (fabs (cost_last - cost_best), *current_cost_temperature);
    tmp_dbl1 = MAX ((double) EPS_DOUBLE, tmp_dbl1);
    tmp_dbl1 = MIN (tmp_dbl1, *initial_cost_temperature);
#endif /* USER_REANNEAL_COST */
    if (cost_test == TRUE && (*current_cost_temperature > tmp_dbl1)) {
      tmp_var_db3 =
        fabs (F_LOG (((double) EPS_DOUBLE + *initial_cost_temperature) /
                     (tmp_dbl1)));
      tmp_dbl = (double) EPS_DOUBLE + F_POW (tmp_var_db3
                                             / *temperature_scale_cost,
                                             *xnumber_parameters
#if QUENCH_COST
                                             /
                                             OPTIONS->User_Quench_Cost_Scale
                                             [0]);
#else
        );
#endif
    } else {
      log_init_cur_temp_ratio =
        fabs (F_LOG (((double) EPS_DOUBLE + *initial_cost_temperature) /
                     ((double) EPS_DOUBLE + *current_cost_temperature)));
      tmp_dbl = (double) EPS_DOUBLE
        + F_POW (log_init_cur_temp_ratio
                 / *temperature_scale_cost, *xnumber_parameters
#if QUENCH_COST
                 / OPTIONS->User_Quench_Cost_Scale[0]
#else
#endif
        );
    }

    /* reset index_cost_temperature if index reset too large */
    while (tmp_dbl > ((double) MAXIMUM_REANNEAL_INDEX)) {
      log_new_temperature_ratio = -*temperature_scale_cost * F_POW (tmp_dbl,
#if QUENCH_COST
                                                                    OPTIONS->User_Quench_Cost_Scale
                                                                    [0]
#else
                                                                    ONE
#endif
                                                                    /
                                                                    *xnumber_parameters);
      log_new_temperature_ratio = EXPONENT_CHECK (log_new_temperature_ratio);
      new_temperature =
        *initial_cost_temperature * F_EXP (log_new_temperature_ratio);
      tmp_dbl /= (double) REANNEAL_SCALE;
      temperature_rescale_power = ONE / F_POW ((double) REANNEAL_SCALE,
#if QUENCH_COST
                                               OPTIONS->User_Quench_Cost_Scale
                                               [0]
#else
                                               ONE
#endif
                                               / *xnumber_parameters);
      *initial_cost_temperature =
        new_temperature * F_POW (*initial_cost_temperature /
                                 new_temperature, temperature_rescale_power);
    }
    *index_cost_acceptances = (LONG_INT) tmp_dbl;
#if USER_ACCEPTANCE_TEST
    OPTIONS->Cost_Temp_Init = *initial_cost_temperature;
#endif
  }
}

/***********************************************************************
* cost_derivatives
*	This procedure calculates the derivatives of the cost function
*	with respect to its parameters.  The first derivatives are
*	used as a sensitivity measure for reannealing.  The second
*	derivatives are calculated only if *curvature_flag=TRUE;
*	these are a measure of the covariance of the fit when a
*	minimum is found.
***********************************************************************/
  /* Calculate the numerical derivatives of the best
     generated state found so far */

  /* Assuming no information is given about the metric of the parameter
     space, use simple Cartesian space to calculate curvatures. */

#if HAVE_ANSI
void
cost_derivatives (double (*user_cost_function)

                   
                  (double *, double *, double *, double *, double *,
                   ALLOC_INT *, int *, int *, int *, USER_DEFINES *),
                  double *parameter_minimum, double *parameter_maximum,
                  double *tangents, double *curvature,
                  double *maximum_tangent, ALLOC_INT * number_parameters,
                  int *parameter_type, int *exit_status,
                  int *curvature_flag, int *valid_state_generated_flag,
                  LONG_INT * number_invalid_generated_states,
                  STATE * current_generated_state,
                  STATE * best_generated_state, FILE * ptr_asa_out,
                  USER_DEFINES * OPTIONS)
#else
void

cost_derivatives (user_cost_function,
                  parameter_minimum,
                  parameter_maximum,
                  tangents,
                  curvature,
                  maximum_tangent,
                  number_parameters,
                  parameter_type,
                  exit_status,
                  curvature_flag,
                  valid_state_generated_flag,
                  number_invalid_generated_states,
                  current_generated_state,
                  best_generated_state, ptr_asa_out, OPTIONS)
     double (*user_cost_function) ();
     double *parameter_minimum;
     double *parameter_maximum;
     double *tangents;
     double *curvature;
     double *maximum_tangent;
     ALLOC_INT *number_parameters;
     int *parameter_type;
     int *exit_status;
     int *curvature_flag;
     int *valid_state_generated_flag;
     LONG_INT *number_invalid_generated_states;
     STATE *current_generated_state;
     STATE *best_generated_state;
     FILE *ptr_asa_out;
     USER_DEFINES *OPTIONS;
#endif
{
  ALLOC_INT index_v, index_vv, index_v_vv, index_vv_v;
  LONG_INT saved_num_invalid_gen_states;
#if ASA_PRINT
  LONG_INT tmp_saved;
#endif
  double parameter_v, parameter_vv, parameter_v_offset, parameter_vv_offset;
  double recent_best_cost;
  double new_cost_state_1, new_cost_state_2, new_cost_state_3;
  double delta_parameter_v, delta_parameter_vv;
  int immediate_flag;

  if (OPTIONS->Curvature_0 == TRUE)
    *curvature_flag = FALSE;
  if (OPTIONS->Curvature_0 == -1)
    *curvature_flag = TRUE;

  /* save Immediate_Exit flag */
  immediate_flag = OPTIONS->Immediate_Exit;

  /* save the best cost */
  recent_best_cost = best_generated_state->cost;

  /* copy the best state into the current state */
  VFOR (index_v) {
    /* ignore parameters with too small ranges */
    if (PARAMETER_RANGE_TOO_SMALL (index_v))
      continue;
    current_generated_state->parameter[index_v] =
      best_generated_state->parameter[index_v];
  }

  saved_num_invalid_gen_states = (*number_invalid_generated_states);

  /* set parameters (& possibly constraints) to best state */
  *valid_state_generated_flag = TRUE;
#if USER_ACCEPTANCE_TEST
  OPTIONS->User_Acceptance_Flag = TRUE;
  OPTIONS->Cost_Acceptance_Flag = FALSE;
#endif
  current_generated_state->cost =
    user_cost_function (current_generated_state->parameter,
                        parameter_minimum,
                        parameter_maximum,
                        tangents,
                        curvature,
                        number_parameters,
                        parameter_type,
                        valid_state_generated_flag, exit_status, OPTIONS);
  if ((*valid_state_generated_flag == FALSE)
      || ((current_generated_state->cost) != (current_generated_state->cost))
      || current_generated_state->cost < -MAX_DOUBLE
      || current_generated_state->cost > MAX_DOUBLE) {
    *exit_status = INVALID_COST_FUNCTION_DERIV;
    return;
  }
  if (*valid_state_generated_flag == FALSE)
    ++(*number_invalid_generated_states);

  if (OPTIONS->User_Tangents == TRUE) {
    *valid_state_generated_flag = -1;
#if USER_ACCEPTANCE_TEST
    OPTIONS->User_Acceptance_Flag = TRUE;
    OPTIONS->Cost_Acceptance_Flag = FALSE;
#endif
    current_generated_state->cost =
      user_cost_function (current_generated_state->parameter,
                          parameter_minimum,
                          parameter_maximum,
                          tangents,
                          curvature,
                          number_parameters,
                          parameter_type,
                          valid_state_generated_flag, exit_status, OPTIONS);
    if ((*valid_state_generated_flag == FALSE)
        || ((current_generated_state->cost) !=
            (current_generated_state->cost))
        || current_generated_state->cost < -MAX_DOUBLE
        || current_generated_state->cost > MAX_DOUBLE) {
      *exit_status = INVALID_COST_FUNCTION_DERIV;
      return;
    }
    if (*valid_state_generated_flag == FALSE)
      ++(*number_invalid_generated_states);
  } else {
    /* calculate tangents */
    VFOR (index_v) {
      if (NO_REANNEAL (index_v)) {
        tangents[index_v] = ZERO;
        continue;
      }
      /* skip parameters with too small range or integer parameters */
      if (OPTIONS->Include_Integer_Parameters == TRUE) {
        if (PARAMETER_RANGE_TOO_SMALL (index_v)) {
          tangents[index_v] = ZERO;
          continue;
        }
      } else {
        if (PARAMETER_RANGE_TOO_SMALL (index_v) ||
            INTEGER_PARAMETER (index_v)) {
          tangents[index_v] = ZERO;
          continue;
        }
      }
#if DELTA_PARAMETERS
      delta_parameter_v = OPTIONS->User_Delta_Parameter[index_v];
#else
      delta_parameter_v = OPTIONS->Delta_X;
#endif
      if (delta_parameter_v < SMALL_FLOAT) {
        tangents[index_v] = 0;
        continue;
      }

      /* save the v_th parameter and delta_parameter */
      parameter_v = best_generated_state->parameter[index_v];

      parameter_v_offset = (ONE + delta_parameter_v) * parameter_v;
      if (parameter_v_offset > parameter_maximum[index_v] ||
          parameter_v_offset < parameter_minimum[index_v]) {
        delta_parameter_v = -delta_parameter_v;
        parameter_v_offset = (ONE + delta_parameter_v) * parameter_v;
      }

      /* generate the first sample point */
      current_generated_state->parameter[index_v] = parameter_v_offset;
      *valid_state_generated_flag = TRUE;
#if USER_ACCEPTANCE_TEST
      OPTIONS->User_Acceptance_Flag = TRUE;
      OPTIONS->Cost_Acceptance_Flag = FALSE;
#endif
      current_generated_state->cost =
        user_cost_function (current_generated_state->parameter,
                            parameter_minimum,
                            parameter_maximum,
                            tangents,
                            curvature,
                            number_parameters,
                            parameter_type,
                            valid_state_generated_flag, exit_status, OPTIONS);
      if ((*valid_state_generated_flag == FALSE)
          || ((current_generated_state->cost) !=
              (current_generated_state->cost))
          || current_generated_state->cost < -MAX_DOUBLE
          || current_generated_state->cost > MAX_DOUBLE) {
        *exit_status = INVALID_COST_FUNCTION_DERIV;
        return;
      }
      if (*valid_state_generated_flag == FALSE)
        ++(*number_invalid_generated_states);
      new_cost_state_1 = current_generated_state->cost;

      /* restore the parameter state */
      current_generated_state->parameter[index_v] = parameter_v;

      /* calculate the numerical derivative */
      tangents[index_v] = (new_cost_state_1 - recent_best_cost)
        / (delta_parameter_v * parameter_v + (double) EPS_DOUBLE);

    }
  }

  /* find the maximum |tangent| from all tangents */
  *maximum_tangent = 0;
  VFOR (index_v) {
    if (NO_REANNEAL (index_v))
      continue;

    /* ignore too small ranges and integer parameters types */
    if (OPTIONS->Include_Integer_Parameters == TRUE) {
      if (PARAMETER_RANGE_TOO_SMALL (index_v))
        continue;
    } else {
      if (PARAMETER_RANGE_TOO_SMALL (index_v)
          || INTEGER_PARAMETER (index_v))
        continue;
    }

    /* find the maximum |tangent| (from all tangents) */
    if (fabs (tangents[index_v]) > *maximum_tangent) {
      *maximum_tangent = fabs (tangents[index_v]);
    }
  }

  if (*curvature_flag == TRUE || *curvature_flag == -1) {
    /* calculate diagonal curvatures */
    VFOR (index_v) {
      /* index_v_vv: row index_v, column index_v */
      index_v_vv = ROW_COL_INDEX (index_v, index_v);

      if (NO_REANNEAL (index_v)) {
        curvature[index_v_vv] = ZERO;
        continue;
      }
      /* skip parameters with too small range or integer parameters */
      if (OPTIONS->Include_Integer_Parameters == TRUE) {
        if (PARAMETER_RANGE_TOO_SMALL (index_v)) {
          curvature[index_v_vv] = ZERO;
          continue;
        }
      } else {
        if (PARAMETER_RANGE_TOO_SMALL (index_v) ||
            INTEGER_PARAMETER (index_v)) {
          curvature[index_v_vv] = ZERO;
          continue;
        }
      }
#if DELTA_PARAMETERS
      delta_parameter_v = OPTIONS->User_Delta_Parameter[index_v];
#else
      delta_parameter_v = OPTIONS->Delta_X;
#endif
      if (delta_parameter_v < SMALL_FLOAT) {
        curvature[index_v_vv] = ZERO;
        continue;
      }

      /* save the v_th parameter and delta_parameter */
      parameter_v = best_generated_state->parameter[index_v];

      if (parameter_v + delta_parameter_v * fabs (parameter_v)
          > parameter_maximum[index_v]) {
        /* generate the first sample point */
        current_generated_state->parameter[index_v] =
          parameter_v - TWO * delta_parameter_v * fabs (parameter_v);
        *valid_state_generated_flag = TRUE;
#if USER_ACCEPTANCE_TEST
        OPTIONS->User_Acceptance_Flag = TRUE;
        OPTIONS->Cost_Acceptance_Flag = FALSE;
#endif
        current_generated_state->cost =
          user_cost_function (current_generated_state->parameter,
                              parameter_minimum,
                              parameter_maximum,
                              tangents,
                              curvature,
                              number_parameters,
                              parameter_type,
                              valid_state_generated_flag,
                              exit_status, OPTIONS);
        if ((*valid_state_generated_flag == FALSE)
            || ((current_generated_state->cost) !=
                (current_generated_state->cost))
            || current_generated_state->cost < -MAX_DOUBLE
            || current_generated_state->cost > MAX_DOUBLE) {
          *exit_status = INVALID_COST_FUNCTION_DERIV;
          return;
        }
        if (*valid_state_generated_flag == FALSE)
          ++(*number_invalid_generated_states);
        new_cost_state_1 = current_generated_state->cost;

        /* generate the second sample point */
        current_generated_state->parameter[index_v] =
          parameter_v - delta_parameter_v * fabs (parameter_v);

        *valid_state_generated_flag = TRUE;
#if USER_ACCEPTANCE_TEST
        OPTIONS->User_Acceptance_Flag = TRUE;
        OPTIONS->Cost_Acceptance_Flag = FALSE;
#endif
        current_generated_state->cost =
          user_cost_function (current_generated_state->parameter,
                              parameter_minimum,
                              parameter_maximum,
                              tangents,
                              curvature,
                              number_parameters,
                              parameter_type,
                              valid_state_generated_flag,
                              exit_status, OPTIONS);
        if ((*valid_state_generated_flag == FALSE)
            || ((current_generated_state->cost) !=
                (current_generated_state->cost))
            || current_generated_state->cost < -MAX_DOUBLE
            || current_generated_state->cost > MAX_DOUBLE) {
          *exit_status = INVALID_COST_FUNCTION_DERIV;
          return;
        }
        if (*valid_state_generated_flag == FALSE)
          ++(*number_invalid_generated_states);
        new_cost_state_2 = current_generated_state->cost;

        /* restore the parameter state */
        current_generated_state->parameter[index_v] = parameter_v;

        /* calculate and store the curvature */
        curvature[index_v_vv] =
          (recent_best_cost - TWO * new_cost_state_2
           + new_cost_state_1) / (delta_parameter_v * delta_parameter_v
                                  * parameter_v * parameter_v +
                                  (double) EPS_DOUBLE);
      } else if (parameter_v - delta_parameter_v * fabs (parameter_v)
                 < parameter_minimum[index_v]) {
        /* generate the first sample point */
        current_generated_state->parameter[index_v] =
          parameter_v + TWO * delta_parameter_v * fabs (parameter_v);
        *valid_state_generated_flag = TRUE;
#if USER_ACCEPTANCE_TEST
        OPTIONS->User_Acceptance_Flag = TRUE;
        OPTIONS->Cost_Acceptance_Flag = FALSE;
#endif
        current_generated_state->cost =
          user_cost_function (current_generated_state->parameter,
                              parameter_minimum,
                              parameter_maximum,
                              tangents,
                              curvature,
                              number_parameters,
                              parameter_type,
                              valid_state_generated_flag,
                              exit_status, OPTIONS);
        if ((*valid_state_generated_flag == FALSE)
            || ((current_generated_state->cost) !=
                (current_generated_state->cost))
            || current_generated_state->cost < -MAX_DOUBLE
            || current_generated_state->cost > MAX_DOUBLE) {
          *exit_status = INVALID_COST_FUNCTION_DERIV;
          return;
        }
        if (*valid_state_generated_flag == FALSE)
          ++(*number_invalid_generated_states);
        new_cost_state_1 = current_generated_state->cost;

        /* generate the second sample point */
        current_generated_state->parameter[index_v] =
          parameter_v + delta_parameter_v * fabs (parameter_v);

        *valid_state_generated_flag = TRUE;
#if USER_ACCEPTANCE_TEST
        OPTIONS->User_Acceptance_Flag = TRUE;
        OPTIONS->Cost_Acceptance_Flag = FALSE;
#endif
        current_generated_state->cost =
          user_cost_function (current_generated_state->parameter,
                              parameter_minimum,
                              parameter_maximum,
                              tangents,
                              curvature,
                              number_parameters,
                              parameter_type,
                              valid_state_generated_flag,
                              exit_status, OPTIONS);
        if ((*valid_state_generated_flag == FALSE)
            || ((current_generated_state->cost) !=
                (current_generated_state->cost))
            || current_generated_state->cost < -MAX_DOUBLE
            || current_generated_state->cost > MAX_DOUBLE) {
          *exit_status = INVALID_COST_FUNCTION_DERIV;
          return;
        }
        if (*valid_state_generated_flag == FALSE)
          ++(*number_invalid_generated_states);
        new_cost_state_2 = current_generated_state->cost;

        /* restore the parameter state */
        current_generated_state->parameter[index_v] = parameter_v;

        /* index_v_vv: row index_v, column index_v */
        index_v_vv = ROW_COL_INDEX (index_v, index_v);

        /* calculate and store the curvature */
        curvature[index_v_vv] =
          (recent_best_cost - TWO * new_cost_state_2
           + new_cost_state_1) / (delta_parameter_v * delta_parameter_v
                                  * parameter_v * parameter_v +
                                  (double) EPS_DOUBLE);
      } else {
        /* generate the first sample point */
        parameter_v_offset = (ONE + delta_parameter_v) * parameter_v;
        current_generated_state->parameter[index_v] = parameter_v_offset;
        *valid_state_generated_flag = TRUE;
#if USER_ACCEPTANCE_TEST
        OPTIONS->User_Acceptance_Flag = TRUE;
        OPTIONS->Cost_Acceptance_Flag = FALSE;
#endif
        current_generated_state->cost =
          user_cost_function (current_generated_state->parameter,
                              parameter_minimum,
                              parameter_maximum,
                              tangents,
                              curvature,
                              number_parameters,
                              parameter_type,
                              valid_state_generated_flag,
                              exit_status, OPTIONS);
        if ((*valid_state_generated_flag == FALSE)
            || ((current_generated_state->cost) !=
                (current_generated_state->cost))
            || current_generated_state->cost < -MAX_DOUBLE
            || current_generated_state->cost > MAX_DOUBLE) {
          *exit_status = INVALID_COST_FUNCTION_DERIV;
          return;
        }
        if (*valid_state_generated_flag == FALSE)
          ++(*number_invalid_generated_states);
        new_cost_state_1 = current_generated_state->cost;

        /* generate the second sample point */
        current_generated_state->parameter[index_v] =
          (ONE - delta_parameter_v) * parameter_v;

        *valid_state_generated_flag = TRUE;
#if USER_ACCEPTANCE_TEST
        OPTIONS->User_Acceptance_Flag = TRUE;
        OPTIONS->Cost_Acceptance_Flag = FALSE;
#endif
        current_generated_state->cost =
          user_cost_function (current_generated_state->parameter,
                              parameter_minimum,
                              parameter_maximum,
                              tangents,
                              curvature,
                              number_parameters,
                              parameter_type,
                              valid_state_generated_flag,
                              exit_status, OPTIONS);
        if ((*valid_state_generated_flag == FALSE)
            || ((current_generated_state->cost) !=
                (current_generated_state->cost))
            || current_generated_state->cost < -MAX_DOUBLE
            || current_generated_state->cost > MAX_DOUBLE) {
          *exit_status = INVALID_COST_FUNCTION_DERIV;
          return;
        }
        if (*valid_state_generated_flag == FALSE)
          ++(*number_invalid_generated_states);
        new_cost_state_2 = current_generated_state->cost;

        /* restore the parameter state */
        current_generated_state->parameter[index_v] = parameter_v;

        /* calculate and store the curvature */
        curvature[index_v_vv] =
          (new_cost_state_2 - TWO * recent_best_cost
           + new_cost_state_1) / (delta_parameter_v * delta_parameter_v
                                  * parameter_v * parameter_v +
                                  (double) EPS_DOUBLE);
      }
    }

    /* calculate off-diagonal curvatures */
    VFOR (index_v) {
#if DELTA_PARAMETERS
      delta_parameter_v = OPTIONS->User_Delta_Parameter[index_v];
#else
      delta_parameter_v = OPTIONS->Delta_X;
#endif
      if (delta_parameter_v < SMALL_FLOAT) {
        VFOR (index_vv) {
          /* index_v_vv: row index_v, column index_vv */
          index_v_vv = ROW_COL_INDEX (index_v, index_vv);
          index_vv_v = ROW_COL_INDEX (index_vv, index_v);
          curvature[index_vv_v] = curvature[index_v_vv] = ZERO;
        }
        continue;
      }

      /* save the v_th parameter and delta_x */
      parameter_v = current_generated_state->parameter[index_v];

      VFOR (index_vv) {
        /* index_v_vv: row index_v, column index_vv */
        index_v_vv = ROW_COL_INDEX (index_v, index_vv);
        index_vv_v = ROW_COL_INDEX (index_vv, index_v);

        if (NO_REANNEAL (index_vv) || NO_REANNEAL (index_v)) {
          curvature[index_vv_v] = curvature[index_v_vv] = ZERO;
          continue;
        }
        /* calculate only the upper diagonal */
        if (index_v <= index_vv) {
          continue;
        }
        /* skip parms with too small range or integer parameters */
        if (OPTIONS->Include_Integer_Parameters == TRUE) {
          if (PARAMETER_RANGE_TOO_SMALL (index_v) ||
              PARAMETER_RANGE_TOO_SMALL (index_vv)) {
            curvature[index_vv_v] = curvature[index_v_vv] = ZERO;
            continue;
          }
        } else {
          if (INTEGER_PARAMETER (index_v) ||
              INTEGER_PARAMETER (index_vv) ||
              PARAMETER_RANGE_TOO_SMALL (index_v) ||
              PARAMETER_RANGE_TOO_SMALL (index_vv)) {
            curvature[index_vv_v] = curvature[index_v_vv] = ZERO;
            continue;
          }
        }
#if DELTA_PARAMETERS
        delta_parameter_vv = OPTIONS->User_Delta_Parameter[index_vv];
#else
        delta_parameter_vv = OPTIONS->Delta_X;
#endif
        if (delta_parameter_vv < SMALL_FLOAT) {
          curvature[index_vv_v] = curvature[index_v_vv] = ZERO;
          continue;
        }

        /* save the vv_th parameter and delta_parameter */
        parameter_vv = current_generated_state->parameter[index_vv];

        /* generate first sample point */
        parameter_v_offset = current_generated_state->parameter[index_v] =
          (ONE + delta_parameter_v) * parameter_v;
        parameter_vv_offset = current_generated_state->parameter[index_vv] =
          (ONE + delta_parameter_vv) * parameter_vv;
        if (parameter_v_offset > parameter_maximum[index_v] ||
            parameter_v_offset < parameter_minimum[index_v]) {
          delta_parameter_v = -delta_parameter_v;
          current_generated_state->parameter[index_v] =
            (ONE + delta_parameter_v) * parameter_v;
        }
        if (parameter_vv_offset > parameter_maximum[index_vv] ||
            parameter_vv_offset < parameter_minimum[index_vv]) {
          delta_parameter_vv = -delta_parameter_vv;
          current_generated_state->parameter[index_vv] =
            (ONE + delta_parameter_vv) * parameter_vv;
        }

        *valid_state_generated_flag = TRUE;
#if USER_ACCEPTANCE_TEST
        OPTIONS->User_Acceptance_Flag = TRUE;
        OPTIONS->Cost_Acceptance_Flag = FALSE;
#endif
        current_generated_state->cost =
          user_cost_function (current_generated_state->parameter,
                              parameter_minimum,
                              parameter_maximum,
                              tangents,
                              curvature,
                              number_parameters,
                              parameter_type,
                              valid_state_generated_flag,
                              exit_status, OPTIONS);
        if ((*valid_state_generated_flag == FALSE)
            || ((current_generated_state->cost) !=
                (current_generated_state->cost))
            || current_generated_state->cost < -MAX_DOUBLE
            || current_generated_state->cost > MAX_DOUBLE) {
          *exit_status = INVALID_COST_FUNCTION_DERIV;
          return;
        }
        if (*valid_state_generated_flag == FALSE)
          ++(*number_invalid_generated_states);
        new_cost_state_1 = current_generated_state->cost;

        /* restore the v_th parameter */
        current_generated_state->parameter[index_v] = parameter_v;

        /* generate second sample point */
        *valid_state_generated_flag = TRUE;
#if USER_ACCEPTANCE_TEST
        OPTIONS->User_Acceptance_Flag = TRUE;
        OPTIONS->Cost_Acceptance_Flag = FALSE;
#endif
        current_generated_state->cost =
          user_cost_function (current_generated_state->parameter,
                              parameter_minimum,
                              parameter_maximum,
                              tangents,
                              curvature,
                              number_parameters,
                              parameter_type,
                              valid_state_generated_flag,
                              exit_status, OPTIONS);
        if ((*valid_state_generated_flag == FALSE)
            || ((current_generated_state->cost) !=
                (current_generated_state->cost))
            || current_generated_state->cost < -MAX_DOUBLE
            || current_generated_state->cost > MAX_DOUBLE) {
          *exit_status = INVALID_COST_FUNCTION_DERIV;
          return;
        }
        if (*valid_state_generated_flag == FALSE)
          ++(*number_invalid_generated_states);
        new_cost_state_2 = current_generated_state->cost;

        /* restore the vv_th parameter */
        current_generated_state->parameter[index_vv] = parameter_vv;

        /* generate third sample point */
        current_generated_state->parameter[index_v] =
          (ONE + delta_parameter_v) * parameter_v;
        *valid_state_generated_flag = TRUE;
#if USER_ACCEPTANCE_TEST
        OPTIONS->User_Acceptance_Flag = TRUE;
        OPTIONS->Cost_Acceptance_Flag = FALSE;
#endif
        current_generated_state->cost =
          user_cost_function (current_generated_state->parameter,
                              parameter_minimum,
                              parameter_maximum,
                              tangents,
                              curvature,
                              number_parameters,
                              parameter_type,
                              valid_state_generated_flag,
                              exit_status, OPTIONS);
        if ((*valid_state_generated_flag == FALSE)
            || ((current_generated_state->cost) !=
                (current_generated_state->cost))
            || current_generated_state->cost < -MAX_DOUBLE
            || current_generated_state->cost > MAX_DOUBLE) {
          *exit_status = INVALID_COST_FUNCTION_DERIV;
          return;
        }
        if (*valid_state_generated_flag == FALSE)
          ++(*number_invalid_generated_states);
        new_cost_state_3 = current_generated_state->cost;

        /* restore the v_th parameter */
        current_generated_state->parameter[index_v] = parameter_v;

        /* calculate and store the curvature */
        curvature[index_vv_v] = curvature[index_v_vv] =
          (new_cost_state_1 - new_cost_state_2
           - new_cost_state_3 + recent_best_cost)
          / (delta_parameter_v * delta_parameter_vv
             * parameter_v * parameter_vv + (double) EPS_DOUBLE);
      }
    }
  }

  /* restore Immediate_Exit flag */
  OPTIONS->Immediate_Exit = immediate_flag;

  /* restore the best cost function value */
  current_generated_state->cost = recent_best_cost;
#if ASA_PRINT
  tmp_saved = *number_invalid_generated_states - saved_num_invalid_gen_states;
  if (tmp_saved > 0)
#if INT_LONG
    fprintf (ptr_asa_out,
             "Generated %ld invalid states when calculating the derivatives\n",
             tmp_saved);
#else
    fprintf (ptr_asa_out,
             "Generated %d invalid states when calculating the derivatives\n",
             tmp_saved);
#endif
#endif /* ASA_PRINT */
  *number_invalid_generated_states = saved_num_invalid_gen_states;
#if USER_ACCEPTANCE_TEST
  OPTIONS->User_Acceptance_Flag = TRUE;
  OPTIONS->Cost_Acceptance_Flag = FALSE;
#endif
}

/***********************************************************************
* asa_test_asa_options
*       Tests user's selected options
***********************************************************************/
#if HAVE_ANSI
int

asa_test_asa_options (LONG_INT * seed,
                      double *parameter_initial_final,
                      double *parameter_minimum,
                      double *parameter_maximum,
                      double *tangents,
                      double *curvature,
                      ALLOC_INT * number_parameters,
                      int *parameter_type,
                      int *valid_state_generated_flag,
                      int *exit_status,
                      FILE * ptr_asa_out, USER_DEFINES * OPTIONS)
#else
int

asa_test_asa_options (seed,
                      parameter_initial_final,
                      parameter_minimum,
                      parameter_maximum,
                      tangents,
                      curvature,
                      number_parameters,
                      parameter_type,
                      valid_state_generated_flag,
                      exit_status, ptr_asa_out, OPTIONS)
     LONG_INT *seed;
     double *parameter_initial_final;
     double *parameter_minimum;
     double *parameter_maximum;
     double *tangents;
     double *curvature;
     ALLOC_INT *number_parameters;
     int *parameter_type;
     int *valid_state_generated_flag;
     int *exit_status;
     FILE *ptr_asa_out;
     USER_DEFINES *OPTIONS;
#endif /* HAVE_ANSI */
{
  int invalid, index_v;

  invalid = 0;

  if (seed == NULL) {
    strcpy (exit_msg, "*** seed == NULL ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (parameter_initial_final == NULL) {
    strcpy (exit_msg, "*** parameter_initial_final == NULL ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (parameter_minimum == NULL) {
    strcpy (exit_msg, "*** parameter_minimum == NULL ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (parameter_maximum == NULL) {
    strcpy (exit_msg, "*** parameter_maximum == NULL ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (tangents == NULL) {
    strcpy (exit_msg, "*** tangents == NULL ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if ((OPTIONS->Curvature_0 == FALSE) || (OPTIONS->Curvature_0 == -1)) {
    if (curvature == NULL) {
      strcpy (exit_msg, "*** curvature == NULL ***");
      print_string (ptr_asa_out, exit_msg);
      ++invalid;
    }
  }
  if (number_parameters == NULL) {
    strcpy (exit_msg, "*** number_parameters == NULL ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (parameter_type == NULL) {
    strcpy (exit_msg, "*** parameter_type == NULL ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (valid_state_generated_flag == NULL) {
    strcpy (exit_msg, "*** valid_state_generated_flag == NULL ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (exit_status == NULL) {
    strcpy (exit_msg, "*** exit_status == NULL ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS == NULL) {
    strcpy (exit_msg, "*** OPTIONS == NULL ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }

  VFOR (index_v) if (parameter_minimum[index_v] > parameter_maximum[index_v]) {
    strcpy (exit_msg, "*** parameter_minimum[] > parameter_maximum[] ***");
    print_string_index (ptr_asa_out, exit_msg, index_v);
    ++invalid;
  }
  VFOR (index_v)
    if (parameter_initial_final[index_v] < parameter_minimum[index_v]) {
    if (PARAMETER_RANGE_TOO_SMALL (index_v))
      continue;
    strcpy (exit_msg, "*** parameter_initial[] < parameter_minimum[] ***");
    print_string_index (ptr_asa_out, exit_msg, index_v);
    ++invalid;
  }
  VFOR (index_v)
    if (parameter_initial_final[index_v] > parameter_maximum[index_v]) {
    if (PARAMETER_RANGE_TOO_SMALL (index_v))
      continue;
    strcpy (exit_msg, "*** parameter_initial[] > parameter_maximum[] ***");
    print_string_index (ptr_asa_out, exit_msg, index_v);
    ++invalid;
  }
  if (*number_parameters < 1) {
    strcpy (exit_msg, "*** *number_parameters < 1 ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  VFOR (index_v)
    if (parameter_type[index_v] != -2 && parameter_type[index_v] != 2
        && parameter_type[index_v] != -1 && parameter_type[index_v] != 1) {
    strcpy (exit_msg,
            "*** parameter_type[] != -2 && parameter_type[] != 2 && parameter_type[] != -1 && parameter_type[] != 1 ***");
    print_string_index (ptr_asa_out, exit_msg, index_v);
    ++invalid;
  }

  if (OPTIONS_FILE != FALSE && OPTIONS_FILE != TRUE) {
    strcpy (exit_msg,
            "*** OPTIONS_FILE != FALSE && OPTIONS_FILE != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS_FILE_DATA != FALSE && OPTIONS_FILE_DATA != TRUE) {
    strcpy (exit_msg,
            "*** OPTIONS_FILE_DATA != FALSE && OPTIONS_FILE_DATA != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (RECUR_OPTIONS_FILE != FALSE && RECUR_OPTIONS_FILE != TRUE) {
    strcpy (exit_msg,
            "*** RECUR_OPTIONS_FILE != FALSE && RECUR_OPTIONS_FILE != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (RECUR_OPTIONS_FILE_DATA != FALSE && RECUR_OPTIONS_FILE_DATA != TRUE) {
    strcpy (exit_msg,
            "*** RECUR_OPTIONS_FILE_DATA != FALSE && RECUR_OPTIONS_FILE_DATA != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (COST_FILE != FALSE && COST_FILE != TRUE) {
    strcpy (exit_msg, "*** COST_FILE != FALSE && COST_FILE != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_LIB != FALSE && ASA_LIB != TRUE) {
    strcpy (exit_msg, "*** ASA_LIB != FALSE && ASA_LIB != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (MY_TEMPLATE != FALSE && MY_TEMPLATE != TRUE) {
    strcpy (exit_msg, "*** MY_TEMPLATE != FALSE && MY_TEMPLATE != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_TEMPLATE_LIB != FALSE && ASA_TEMPLATE_LIB != TRUE) {
    strcpy (exit_msg,
            "*** ASA_TEMPLATE_LIB != FALSE && ASA_TEMPLATE_LIB != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (HAVE_ANSI != FALSE && HAVE_ANSI != TRUE) {
    strcpy (exit_msg, "*** HAVE_ANSI != FALSE && HAVE_ANSI != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (IO_PROTOTYPES != FALSE && IO_PROTOTYPES != TRUE) {
    strcpy (exit_msg,
            "*** IO_PROTOTYPES != FALSE && IO_PROTOTYPES != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (TIME_CALC != FALSE && TIME_CALC != TRUE) {
    strcpy (exit_msg, "*** TIME_CALC != FALSE && TIME_CALC != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (TIME_STD != FALSE && TIME_STD != TRUE) {
    strcpy (exit_msg, "*** TIME_STD != FALSE && TIME_STD != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (TIME_GETRUSAGE != FALSE && TIME_GETRUSAGE != TRUE) {
    strcpy (exit_msg,
            "*** TIME_GETRUSAGE != FALSE && TIME_GETRUSAGE != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (INT_LONG != FALSE && INT_LONG != TRUE) {
    strcpy (exit_msg, "*** INT_LONG != FALSE && INT_LONG != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (INT_ALLOC != FALSE && INT_ALLOC != TRUE) {
    strcpy (exit_msg, "*** INT_ALLOC != FALSE && INT_ALLOC != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (SMALL_FLOAT < ZERO) {
    strcpy (exit_msg, "*** SMALL_FLOAT < ZERO ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (MIN_DOUBLE < ZERO) {
    strcpy (exit_msg, "*** MIN_DOUBLE < ZERO ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (MAX_DOUBLE < ZERO) {
    strcpy (exit_msg, "*** MAX_DOUBLE < ZERO ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (EPS_DOUBLE < ZERO) {
    strcpy (exit_msg, "*** EPS_DOUBLE < ZERO ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (CHECK_EXPONENT != FALSE && CHECK_EXPONENT != TRUE) {
    strcpy (exit_msg,
            "*** CHECK_EXPONENT != FALSE && CHECK_EXPONENT != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (NO_PARAM_TEMP_TEST != FALSE && NO_PARAM_TEMP_TEST != TRUE) {
    strcpy (exit_msg,
            "*** NO_PARAM_TEMP_TEST != FALSE && NO_PARAM_TEMP_TEST != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (NO_COST_TEMP_TEST != FALSE && NO_COST_TEMP_TEST != TRUE) {
    strcpy (exit_msg,
            "*** NO_COST_TEMP_TEST != FALSE && NO_COST_TEMP_TEST != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (SELF_OPTIMIZE != FALSE && SELF_OPTIMIZE != TRUE) {
    strcpy (exit_msg,
            "*** SELF_OPTIMIZE != FALSE && SELF_OPTIMIZE != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_TEST != FALSE && ASA_TEST != TRUE) {
    strcpy (exit_msg, "*** ASA_TEST != FALSE && ASA_TEST != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_TEST_POINT != FALSE && ASA_TEST_POINT != TRUE) {
    strcpy (exit_msg,
            "*** ASA_TEST_POINT != FALSE && ASA_TEST_POINT != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_EXIT_ANYTIME != FALSE && ASA_EXIT_ANYTIME != TRUE) {
    strcpy (exit_msg,
            "*** ASA_EXIT_ANYTIME != FALSE && ASA_EXIT_ANYTIME != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_TEMPLATE != FALSE) {
    strcpy (exit_msg, "*** ASA_TEMPLATE != FALSE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_TEMPLATE_ASA_OUT_PID != FALSE && ASA_TEMPLATE_ASA_OUT_PID != TRUE) {
    strcpy (exit_msg,
            "*** ASA_TEMPLATE_ASA_OUT_PID != FALSE && ASA_TEMPLATE_ASA_OUT_PID != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_TEMPLATE_MULTIPLE != FALSE && ASA_TEMPLATE_MULTIPLE != TRUE) {
    strcpy (exit_msg,
            "*** ASA_TEMPLATE_MULTIPLE != FALSE && ASA_TEMPLATE_MULTIPLE != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_TEMPLATE_SELFOPT != FALSE && ASA_TEMPLATE_SELFOPT != TRUE) {
    strcpy (exit_msg,
            "*** ASA_TEMPLATE_SELFOPT != FALSE && ASA_TEMPLATE_SELFOPT != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_TEMPLATE_SAMPLE != FALSE && ASA_TEMPLATE_SAMPLE != TRUE) {
    strcpy (exit_msg,
            "*** ASA_TEMPLATE_SAMPLE != FALSE && ASA_TEMPLATE_SAMPLE != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_TEMPLATE_QUEUE != FALSE && ASA_TEMPLATE_QUEUE != TRUE) {
    strcpy (exit_msg,
            "*** ASA_TEMPLATE_QUEUE != FALSE && ASA_TEMPLATE_QUEUE != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_TEMPLATE_PARALLEL != FALSE && ASA_TEMPLATE_PARALLEL != TRUE) {
    strcpy (exit_msg,
            "*** ASA_TEMPLATE_PARALLEL != FALSE && ASA_TEMPLATE_PARALLEL != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_TEMPLATE_SAVE != FALSE && ASA_TEMPLATE_SAVE != TRUE) {
    strcpy (exit_msg,
            "*** ASA_TEMPLATE_SAVE != FALSE && ASA_TEMPLATE_SAVE != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (USER_INITIAL_COST_TEMP != FALSE && USER_INITIAL_COST_TEMP != TRUE) {
    strcpy (exit_msg,
            "*** USER_INITIAL_COST_TEMP != FALSE && USER_INITIAL_COST_TEMP != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (RATIO_TEMPERATURE_SCALES != FALSE && RATIO_TEMPERATURE_SCALES != TRUE) {
    strcpy (exit_msg,
            "*** RATIO_TEMPERATURE_SCALES != FALSE && RATIO_TEMPERATURE_SCALES != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (USER_INITIAL_PARAMETERS_TEMPS != FALSE
      && USER_INITIAL_PARAMETERS_TEMPS != TRUE) {
    strcpy (exit_msg,
            "*** USER_INITIAL_PARAMETERS_TEMPS != FALSE && USER_INITIAL_PARAMETERS_TEMPS != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (DELTA_PARAMETERS != FALSE && DELTA_PARAMETERS != TRUE) {
    strcpy (exit_msg,
            "*** DELTA_PARAMETERS != FALSE && DELTA_PARAMETERS != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (QUENCH_PARAMETERS != FALSE && QUENCH_PARAMETERS != TRUE) {
    strcpy (exit_msg,
            "*** QUENCH_PARAMETERS != FALSE && QUENCH_PARAMETERS != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (QUENCH_COST != FALSE && QUENCH_COST != TRUE) {
    strcpy (exit_msg, "*** QUENCH_COST != FALSE && QUENCH_COST != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (QUENCH_PARAMETERS_SCALE != FALSE && QUENCH_PARAMETERS_SCALE != TRUE) {
    strcpy (exit_msg,
            "*** QUENCH_PARAMETERS_SCALE != FALSE && QUENCH_PARAMETERS_SCALE != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (QUENCH_COST_SCALE != FALSE && QUENCH_COST_SCALE != TRUE) {
    strcpy (exit_msg,
            "*** QUENCH_COST_SCALE != FALSE && QUENCH_COST_SCALE != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONAL_DATA_DBL != FALSE && OPTIONAL_DATA_DBL != TRUE) {
    strcpy (exit_msg,
            "*** OPTIONAL_DATA_DBL != FALSE && OPTIONAL_DATA_DBL != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONAL_DATA_INT != FALSE && OPTIONAL_DATA_INT != TRUE) {
    strcpy (exit_msg,
            "*** OPTIONAL_DATA_INT != FALSE && OPTIONAL_DATA_INT != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONAL_DATA_PTR != FALSE && OPTIONAL_DATA_PTR != TRUE) {
    strcpy (exit_msg,
            "*** OPTIONAL_DATA_PTR != FALSE && OPTIONAL_DATA_PTR != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (USER_COST_SCHEDULE != FALSE && USER_COST_SCHEDULE != TRUE) {
    strcpy (exit_msg,
            "*** USER_COST_SCHEDULE != FALSE && USER_COST_SCHEDULE != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (USER_ACCEPT_ASYMP_EXP != FALSE && USER_ACCEPT_ASYMP_EXP != TRUE) {
    strcpy (exit_msg,
            "*** USER_ACCEPT_ASYMP_EXP != FALSE && USER_ACCEPT_ASYMP_EXP != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (USER_ACCEPT_THRESHOLD != FALSE && USER_ACCEPT_THRESHOLD != TRUE) {
    strcpy (exit_msg,
            "*** USER_ACCEPT_THRESHOLD != FALSE && USER_ACCEPT_THRESHOLD != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (USER_ACCEPTANCE_TEST != FALSE && USER_ACCEPTANCE_TEST != TRUE) {
    strcpy (exit_msg,
            "*** USER_ACCEPTANCE_TEST != FALSE && USER_ACCEPTANCE_TEST != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (USER_GENERATING_FUNCTION != FALSE && USER_GENERATING_FUNCTION != TRUE) {
    strcpy (exit_msg,
            "*** USER_GENERATING_FUNCTION != FALSE && USER_GENERATING_FUNCTION != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (USER_REANNEAL_COST != FALSE && USER_REANNEAL_COST != TRUE) {
    strcpy (exit_msg,
            "*** USER_REANNEAL_COST != FALSE && USER_REANNEAL_COST != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (USER_REANNEAL_PARAMETERS != FALSE && USER_REANNEAL_PARAMETERS != TRUE) {
    strcpy (exit_msg,
            "*** USER_REANNEAL_PARAMETERS != FALSE && USER_REANNEAL_PARAMETERS != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (MAXIMUM_REANNEAL_INDEX < 1) {
    strcpy (exit_msg, "*** MAXIMUM_REANNEAL_INDEX < 1 ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (REANNEAL_SCALE < ZERO) {
    strcpy (exit_msg, "*** REANNEAL_SCALE < ZERO ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_SAMPLE != FALSE && ASA_SAMPLE != TRUE) {
    strcpy (exit_msg, "*** ASA_SAMPLE != FALSE && ASA_SAMPLE != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ADAPTIVE_OPTIONS != FALSE && ADAPTIVE_OPTIONS != TRUE) {
    strcpy (exit_msg,
            "*** ADAPTIVE_OPTIONS != FALSE && ADAPTIVE_OPTIONS != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_QUEUE != FALSE && ASA_QUEUE != TRUE) {
    strcpy (exit_msg, "*** ASA_QUEUE != FALSE && ASA_QUEUE != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_RESOLUTION != FALSE && ASA_RESOLUTION != TRUE) {
    strcpy (exit_msg,
            "*** ASA_RESOLUTION != FALSE && ASA_RESOLUTION != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_FUZZY != FALSE && ASA_FUZZY != TRUE) {
    strcpy (exit_msg, "*** ASA_FUZZY != FALSE && ASA_FUZZY != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_FUZZY_PRINT != FALSE && ASA_FUZZY_PRINT != TRUE) {
    strcpy (exit_msg,
            "*** ASA_FUZZY_PRINT != FALSE && ASA_FUZZY_PRINT != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (FITLOC != FALSE && FITLOC != TRUE) {
    strcpy (exit_msg, "*** FITLOC != FALSE && FITLOC != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (FITLOC_ROUND != FALSE && FITLOC_ROUND != TRUE) {
    strcpy (exit_msg,
            "*** FITLOC_ROUND != FALSE && FITLOC_ROUND != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (FITLOC_PRINT != FALSE && FITLOC_PRINT != TRUE) {
    strcpy (exit_msg,
            "*** FITLOC_PRINT != FALSE && FITLOC_PRINT != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (MULTI_MIN != FALSE && MULTI_MIN != TRUE) {
    strcpy (exit_msg, "*** MULTI_MIN != FALSE && MULTI_MIN != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
#if MULTI_MIN
  if (OPTIONS->Multi_Number <= 0) {
    strcpy (exit_msg, "*** OPTIONS->Multi_Number <= 0 ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  VFOR (index_v) {
    if (((OPTIONS->Multi_Grid[index_v]) != (OPTIONS->Multi_Grid[index_v]))
        || OPTIONS->Multi_Grid[index_v] < 0) {
      strcpy (exit_msg,
              "*** (OPTIONS->Multi_Grid[]) != (OPTIONS->Multi_Grid[]) || OPTIONS->Multi_Grid[] < 0 ***");
      print_string_index (ptr_asa_out, exit_msg, index_v);
      ++invalid;
    }
  }
  if (OPTIONS->Multi_Specify != 0 && OPTIONS->Multi_Specify != 1) {
    strcpy (exit_msg,
            "*** OPTIONS->Multi_Specify != 0 && OPTIONS->Multi_Specify != 1 ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
#endif
  if (ASA_PARALLEL != FALSE && ASA_PARALLEL != TRUE) {
    strcpy (exit_msg,
            "*** ASA_PARALLEL != FALSE && ASA_PARALLEL != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_SAVE != FALSE && ASA_SAVE != TRUE) {
    strcpy (exit_msg, "*** ASA_SAVE != FALSE && ASA_SAVE != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_SAVE_OPT != FALSE && ASA_SAVE_OPT != TRUE) {
    strcpy (exit_msg,
            "*** ASA_SAVE_OPT != FALSE && ASA_SAVE_OPT != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_SAVE_BACKUP != FALSE && ASA_SAVE_BACKUP != TRUE) {
    strcpy (exit_msg,
            "*** ASA_SAVE_BACKUP != FALSE && ASA_SAVE_BACKUP != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_PIPE != FALSE && ASA_PIPE != TRUE) {
    strcpy (exit_msg, "*** ASA_PIPE != FALSE && ASA_PIPE != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_PIPE_FILE != FALSE && ASA_PIPE_FILE != TRUE) {
    strcpy (exit_msg,
            "*** ASA_PIPE_FILE != FALSE && ASA_PIPE_FILE != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (SYSTEM_CALL != FALSE && SYSTEM_CALL != TRUE) {
    strcpy (exit_msg, "*** SYSTEM_CALL != FALSE && SYSTEM_CALL != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (FDLIBM_POW != FALSE && FDLIBM_POW != TRUE) {
    strcpy (exit_msg, "*** FDLIBM_POW != FALSE && FDLIBM_POW != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (FDLIBM_LOG != FALSE && FDLIBM_LOG != TRUE) {
    strcpy (exit_msg, "*** FDLIBM_LOG != FALSE && FDLIBM_LOG != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (FDLIBM_EXP != FALSE && FDLIBM_EXP != TRUE) {
    strcpy (exit_msg, "*** FDLIBM_EXP != FALSE && FDLIBM_EXP != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_PRINT != FALSE && ASA_PRINT != TRUE) {
    strcpy (exit_msg, "*** ASA_PRINT != FALSE && ASA_PRINT != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (USER_ASA_OUT != FALSE && USER_ASA_OUT != TRUE) {
    strcpy (exit_msg,
            "*** USER_ASA_OUT != FALSE && USER_ASA_OUT != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (USER_ASA_USR_OUT != FALSE && USER_ASA_USR_OUT != TRUE) {
    strcpy (exit_msg,
            "*** USER_ASA_USR_OUT != FALSE && USER_ASA_USR_OUT != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_PRINT_INTERMED != FALSE && ASA_PRINT_INTERMED != TRUE) {
    strcpy (exit_msg,
            "*** ASA_PRINT_INTERMED != FALSE && ASA_PRINT_INTERMED != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (ASA_PRINT_MORE != FALSE && ASA_PRINT_MORE != TRUE) {
    strcpy (exit_msg,
            "*** ASA_PRINT_MORE != FALSE && ASA_PRINT_MORE != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (G_FIELD < 0) {
    strcpy (exit_msg, "*** G_FIELD < 0 ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (G_PRECISION < 0) {
    strcpy (exit_msg, "*** G_PRECISION < 0 ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }

  if (OPTIONS->Limit_Acceptances < 0) {
    strcpy (exit_msg, "*** Limit_Acceptances < 0 ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Limit_Generated < 0) {
    strcpy (exit_msg, "*** Limit_Generated < 0 ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Limit_Invalid_Generated_States < 0) {
    strcpy (exit_msg, "*** Limit_Invalid_Generated_States < 0 ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Accepted_To_Generated_Ratio <= ZERO) {
    strcpy (exit_msg, "*** Accepted_To_Generated_Ratio <= ZERO ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Cost_Precision <= ZERO) {
    strcpy (exit_msg, "*** Cost_Precision <= ZERO ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Maximum_Cost_Repeat < 0) {
    strcpy (exit_msg, "*** Maximum_Cost_Repeat < 0 ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Number_Cost_Samples == 0 || OPTIONS->Number_Cost_Samples == -1) {
    strcpy (exit_msg,
            "*** Number_Cost_Samples == 0 || Number_Cost_Samples == -1 ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Temperature_Ratio_Scale <= ZERO) {
    strcpy (exit_msg, "*** Temperature_Ratio_Scale <= ZERO ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Cost_Parameter_Scale_Ratio <= ZERO) {
    strcpy (exit_msg, "*** Cost_Parameter_Scale_Ratio <= ZERO ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Temperature_Anneal_Scale <= ZERO) {
    strcpy (exit_msg, "*** Temperature_Anneal_Scale <= ZERO ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
#if USER_INITIAL_COST_TEMP
  if (OPTIONS->User_Cost_Temperature[0] <= ZERO) {
    strcpy (exit_msg, "*** User_Cost_Temperature[0] <= ZERO ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
#endif
  if (OPTIONS->Include_Integer_Parameters != FALSE
      && OPTIONS->Include_Integer_Parameters != TRUE) {
    strcpy (exit_msg, "");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->User_Initial_Parameters != FALSE
      && OPTIONS->User_Initial_Parameters != TRUE) {
    strcpy (exit_msg,
            "*** User_Initial_Parameters != FALSE && User_Initial_Parameters != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Sequential_Parameters >= *number_parameters) {
    strcpy (exit_msg, "*** Sequential_Parameters >= *number_parameters ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Initial_Parameter_Temperature <= ZERO) {
    strcpy (exit_msg, "*** Initial_Parameter_Temperature <= ZERO ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
#if RATIO_TEMPERATURE_SCALES
  VFOR (index_v) if (OPTIONS->User_Temperature_Ratio[index_v] <= ZERO) {
    strcpy (exit_msg, "*** User_Temperature_Ratio[] <= ZERO ***");
    print_string_index (ptr_asa_out, exit_msg, index_v);
    ++invalid;
  }
#endif
#if USER_INITIAL_PARAMETERS_TEMPS
  VFOR (index_v) if (OPTIONS->User_Parameter_Temperature[index_v] <= ZERO) {
    strcpy (exit_msg, "*** User_Parameter_Temperature[] <= ZERO ***");
    print_string_index (ptr_asa_out, exit_msg, index_v);
    ++invalid;
  }
#endif
  if (OPTIONS->Acceptance_Frequency_Modulus < 0) {
    strcpy (exit_msg, "*** Acceptance_Frequency_Modulus < 0 ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Generated_Frequency_Modulus < 0) {
    strcpy (exit_msg, "*** Generated_Frequency_Modulus < 0 ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Reanneal_Cost == -1) {
    strcpy (exit_msg, "*** Reanneal_Cost == -1 ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Reanneal_Parameters != FALSE
      && OPTIONS->Reanneal_Parameters != TRUE) {
    strcpy (exit_msg,
            "*** Reanneal_Parameters != FALSE && Reanneal_Parameters != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Delta_X < ZERO) {
    strcpy (exit_msg, "*** Delta_X < ZERO ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
#if DELTA_PARAMETERS
  VFOR (index_v) if (OPTIONS->User_Delta_Parameter[index_v] < ZERO) {
    strcpy (exit_msg, "*** User_Delta_Parameter[] < ZERO ***");
    print_string_index (ptr_asa_out, exit_msg, index_v);
    ++invalid;
  }
#endif
  if (OPTIONS->User_Tangents != FALSE && OPTIONS->User_Tangents != TRUE) {
    strcpy (exit_msg,
            "*** User_Tangents != FALSE && User_Tangents != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Curvature_0 != -1 && OPTIONS->Curvature_0 != FALSE
      && OPTIONS->Curvature_0 != TRUE) {
    strcpy (exit_msg,
            "*** Curvature_0 -1 && Curvature_0 != FALSE && Curvature_0 != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
#if QUENCH_PARAMETERS
  VFOR (index_v) if (OPTIONS->User_Quench_Param_Scale[index_v] <= ZERO) {
    strcpy (exit_msg, "*** User_Quench_Param_Scale[] <= ZERO ***");
    print_string_index (ptr_asa_out, exit_msg, index_v);
    ++invalid;
  }
#endif
#if QUENCH_COST
  if (OPTIONS->User_Quench_Cost_Scale[0] <= ZERO) {
    strcpy (exit_msg, "*** User_Quench_Cost_Scale[0] <= ZERO ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
#endif
#if OPTIONAL_DATA_DBL
  if (OPTIONS->Asa_Data_Dim_Dbl < 1) {
    strcpy (exit_msg, "*** Asa_Data_Dim_Dbl < 1 ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Asa_Data_Dbl == NULL) {
    strcpy (exit_msg, "*** Asa_Data_Dbl == NULL ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
#endif
#if ASA_SAVE
  if (OPTIONS->Random_Array_Dim < 1) {
    strcpy (exit_msg, "*** Random_Array_Dim < 1 ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Random_Array == NULL) {
    strcpy (exit_msg, "*** Random_Array == NULL ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
#endif
#if OPTIONAL_DATA_INT
  if (OPTIONS->Asa_Data_Dim_Int < 1) {
    strcpy (exit_msg, "*** Asa_Data_Dim_Int < 1 ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Asa_Data_Int == NULL) {
    strcpy (exit_msg, "*** Asa_Data_Int == NULL ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
#endif
#if OPTIONAL_DATA_PTR
  if (OPTIONS->Asa_Data_Dim_Ptr < 1) {
    strcpy (exit_msg, "*** Asa_Data_Dim_Ptr < 1 ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Asa_Data_Ptr == NULL) {
    strcpy (exit_msg, "*** Asa_Data_Ptr == NULL ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
#endif
#if USER_ASA_OUT
  if (OPTIONS->Asa_Out_File == NULL) {
    strcpy (exit_msg, "*** Asa_Out_File == NULL ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
#endif
#if USER_COST_SCHEDULE
  if (OPTIONS->Cost_Schedule == NULL) {
    strcpy (exit_msg, "*** Cost_Schedule == NULL ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
#endif
#if USER_ACCEPTANCE_TEST
  if (OPTIONS->Acceptance_Test == NULL) {
    strcpy (exit_msg, "*** Acceptance_Test == NULL ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->User_Acceptance_Flag != FALSE
      && OPTIONS->User_Acceptance_Flag != TRUE) {
    strcpy (exit_msg,
            "*** User_Acceptance_Flag != FALSE && User_Acceptance_Flag != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Cost_Acceptance_Flag != FALSE
      && OPTIONS->Cost_Acceptance_Flag != TRUE) {
    strcpy (exit_msg,
            "*** Cost_Acceptance_Flag != FALSE && Cost_Acceptance_Flag != TRUE ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
#endif
#if USER_GENERATING_FUNCTION
  if (OPTIONS->Generating_Distrib == NULL) {
    strcpy (exit_msg, "*** Generating_Distrib == NULL ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
#endif
#if USER_REANNEAL_COST
  if (OPTIONS->Reanneal_Cost_Function == NULL) {
    strcpy (exit_msg, "*** Reanneal_Cost_Function == NULL ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
#endif
#if USER_REANNEAL_PARAMETERS
  if (OPTIONS->Reanneal_Params_Function == NULL) {
    strcpy (exit_msg, "*** Reanneal_Params_Function == NULL ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
#endif
#if ASA_SAMPLE
  if (OPTIONS->Bias_Generated == NULL) {
    strcpy (exit_msg, "*** Bias_Generated == NULL ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Limit_Weights < ZERO) {
    strcpy (exit_msg, "*** Limit_Weights < ZERO ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
#endif
#if ASA_QUEUE
  if (OPTIONS->Queue_Size < 0) {
    strcpy (exit_msg, "*** Queue_Size < 0 ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Queue_Size > 0) {
    if (OPTIONS->Queue_Resolution == NULL) {
      strcpy (exit_msg, "*** Queue_Resolution == NULL ***");
      print_string (ptr_asa_out, exit_msg);
      ++invalid;
    }
  }
#endif /* ASA_QUEUE */
#if ASA_RESOLUTION
  if (OPTIONS->Coarse_Resolution == NULL) {
    strcpy (exit_msg, "*** Coarse_Resolution == NULL ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
#endif
#if ASA_PARALLEL
  if (OPTIONS->Gener_Block < 1) {
    strcpy (exit_msg, "*** Gener_Block < 1 ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Gener_Block_Max < 1) {
    strcpy (exit_msg, "*** Gener_Block_Max < 1 ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
  if (OPTIONS->Gener_Mov_Avr < 1) {
    strcpy (exit_msg, "*** Gener_Mov_Avr < 1 ***");
    print_string (ptr_asa_out, exit_msg);
    ++invalid;
  }
#endif /* ASA_PARALLEL */

  return (invalid);
}

/***********************************************************************
* cost_function_test
*       Tests user's returned cost function values and parameters
***********************************************************************/
#if HAVE_ANSI
int

cost_function_test (double cost,
                    double *parameter,
                    double *parameter_minimum,
                    double *parameter_maximum,
                    ALLOC_INT * number_parameters, double *xnumber_parameters)
#else
int

cost_function_test (cost,
                    parameter,
                    parameter_minimum, parameter_maximum,
                    number_parameters, xnumber_parameters)
     double cost;
     double *parameter;
     double *parameter_minimum;
     double *parameter_maximum;
     ALLOC_INT *number_parameters;
     double *xnumber_parameters;
#endif /* HAVE_ANSI */
{
  ALLOC_INT index_v;
  int test_flag;

  test_flag = 1;

  if (((cost) != (cost)) || (cost < -MAX_DOUBLE || cost > MAX_DOUBLE))
    test_flag = 0;

  *xnumber_parameters = (double) *number_parameters;
  VFOR (index_v) {
    if (PARAMETER_RANGE_TOO_SMALL (index_v)) {
      *xnumber_parameters -= 1.0;
      continue;
    }
    if (parameter[index_v] < parameter_minimum[index_v] ||
        parameter[index_v] > parameter_maximum[index_v]) {
      test_flag = 0;
    }
  }

  return (test_flag);
}

/***********************************************************************
* print_string
*	This prints the designated string
***********************************************************************/
#if HAVE_ANSI
void
print_string (FILE * ptr_asa_out, char *string)
#else
void
print_string (ptr_asa_out, string)
     FILE *ptr_asa_out;
     char *string;
#endif /* HAVE_ANSI */
{
#if INCL_STDOUT
  printf ("\n\n%s\n\n", string);
  fflush (stdout);
#endif /* INCL_STDOUT */
#if ASA_PRINT
  fprintf (ptr_asa_out, "\n\n%s\n\n", string);
  fflush (ptr_asa_out);
#else
#endif
}

/***********************************************************************
* print_string_index
*	This prints the designated string and index
***********************************************************************/
#if HAVE_ANSI
void
print_string_index (FILE * ptr_asa_out, char *string, ALLOC_INT index)
#else
void
print_string_index (ptr_asa_out, string, index)
     FILE *ptr_asa_out;
     char *string;
     ALLOC_INT index;
#endif /* HAVE_ANSI */
{
#if INCL_STDOUT
#if INT_ALLOC
  printf ("\n\n%s index = %d\n\n", string, index);
#else /* INT_ALLOC */
#if INT_LONG
  printf ("\n\n%s index = %ld\n\n", string, index);
#else /* INT_LONG */
  printf ("\n\n%s index = %ld\n\n", string, index);
#endif /* INT_LONG */
#endif /* INT_ALLOC */
  fflush (stdout);
#endif /* INCL_STDOUT */

#if ASA_PRINT
#if INT_ALLOC
  fprintf (ptr_asa_out, "\n\n%s index = %d\n\n", string, index);
#else /* INT_ALLOC */
#if INT_LONG
  fprintf (ptr_asa_out, "\n\n%s index = %ld\n\n", string, index);
#else /* INT_LONG */
  fprintf (ptr_asa_out, "\n\n%s index = %d\n\n", string, index);
#endif /* INT_LONG */
#endif /* INT_ALLOC */
  fflush (ptr_asa_out);
#else /* ASA_PRINT */
  ;
#endif /* ASA_PRINT */
}

#if ASA_PRINT
/***********************************************************************
* print_state
*	Prints a description of the current state of the system
***********************************************************************/
#if HAVE_ANSI
void

print_state (double *parameter_minimum,
             double *parameter_maximum,
             double *tangents,
             double *curvature,
             double *current_cost_temperature,
             double *current_user_parameter_temp,
             double *accepted_to_generated_ratio,
             ALLOC_INT * number_parameters,
             int *curvature_flag,
             LONG_INT * number_accepted,
             LONG_INT * index_cost_acceptances,
             LONG_INT * number_generated,
             LONG_INT * number_invalid_generated_states,
             STATE * last_saved_state,
             STATE * best_generated_state,
             FILE * ptr_asa_out, USER_DEFINES * OPTIONS)
#else
void

print_state (parameter_minimum,
             parameter_maximum,
             tangents,
             curvature,
             current_cost_temperature,
             current_user_parameter_temp,
             accepted_to_generated_ratio,
             number_parameters,
             curvature_flag,
             number_accepted,
             index_cost_acceptances,
             number_generated,
             number_invalid_generated_states,
             last_saved_state, best_generated_state, ptr_asa_out, OPTIONS)
     double *parameter_minimum;
     double *parameter_maximum;
     double *tangents;
     double *curvature;
     double *current_cost_temperature;
     double *current_user_parameter_temp;
     double *accepted_to_generated_ratio;
     ALLOC_INT *number_parameters;
     int *curvature_flag;
     LONG_INT *number_accepted;
     LONG_INT *index_cost_acceptances;
     LONG_INT *number_generated;
     LONG_INT *number_invalid_generated_states;
     STATE *last_saved_state;
     STATE *best_generated_state;
     FILE *ptr_asa_out;
     USER_DEFINES *OPTIONS;
#endif /* HAVE_ANSI */
{
  ALLOC_INT index_v;
  ALLOC_INT index_vv, index_v_vv;

  fprintf (ptr_asa_out, "\n");
#if TIME_CALC
  print_time ("", ptr_asa_out);
#endif

  if (OPTIONS->Curvature_0 == TRUE)
    *curvature_flag = FALSE;
  if (OPTIONS->Curvature_0 == -1)
    *curvature_flag = TRUE;

#if INT_LONG
  fprintf (ptr_asa_out,
           "*index_cost_acceptances = %ld, *current_cost_temperature = %*.*g\n",
           *index_cost_acceptances,
           G_FIELD, G_PRECISION, *current_cost_temperature);
  fprintf (ptr_asa_out,
           "*accepted_to_generated_ratio = %*.*g, *number_invalid... = %ld\n",
           G_FIELD, G_PRECISION, *accepted_to_generated_ratio,
           (*number_invalid_generated_states));
  fprintf (ptr_asa_out, "*number_generated = %ld, *number_accepted = %ld\n",
           *number_generated, *number_accepted);
#else
  fprintf (ptr_asa_out,
           "*index_cost_acceptances = %d, *current_cost_temperature = %*.*g\n",
           *index_cost_acceptances,
           G_FIELD, G_PRECISION, *current_cost_temperature);
  fprintf (ptr_asa_out,
           "*accepted_to_generated_ratio = %*.*g, *number_invalid... = %d\n",
           G_FIELD, G_PRECISION, *accepted_to_generated_ratio,
           *number_invalid_generated_states);
  fprintf (ptr_asa_out, "*number_generated = %d, *number_accepted = %d\n",
           *number_generated, *number_accepted);
#endif

  fprintf (ptr_asa_out, "best...->cost = %*.*g, last...->cost = %*.*g\n",
           G_FIELD, G_PRECISION, best_generated_state->cost, G_FIELD,
           G_PRECISION, last_saved_state->cost);

  /* Note that tangents will not be calculated until reanneal
     is called, and therefore their listing in the printout only
     is relevant then */

  fprintf (ptr_asa_out,
           "index_v  best...->parameter current_parameter_temp\ttangent\n");
  VFOR (index_v) {
    /* ignore too small ranges */
#if DROPPED_PARAMETERS
    if (PARAMETER_RANGE_TOO_SMALL (index_v))
      continue;
#endif
    fprintf (ptr_asa_out,
#if INT_ALLOC
             "%d\t%*.*g\t\t%*.*g\t%*.*g\n",
#else
#if INT_LONG
             "%ld\t%*.*g\t\t%*.*g\t%*.*g\n",
#else
             "%d\t%*.*g\t\t%*.*g\t%*.*g\n",
#endif
#endif
             index_v,
             G_FIELD, G_PRECISION, best_generated_state->parameter[index_v],
             G_FIELD, G_PRECISION, current_user_parameter_temp[index_v],
             G_FIELD, G_PRECISION, tangents[index_v]);
  }

  if (*curvature_flag == TRUE) {
    /* print curvatures */
    VFOR (index_v) {
      /* ignore too small ranges */
      if (PARAMETER_RANGE_TOO_SMALL (index_v))
        continue;
      fprintf (ptr_asa_out, "\n");
      VFOR (index_vv) {
        /* only print upper diagonal of matrix */
        if (index_v < index_vv)
          continue;
        /* ignore too small ranges (index_vv) */
        if (PARAMETER_RANGE_TOO_SMALL (index_vv))
          continue;

        /* index_v_vv: row index_v, column index_vv */
        index_v_vv = ROW_COL_INDEX (index_v, index_vv);

        if (index_v == index_vv) {
          fprintf (ptr_asa_out,
#if INT_ALLOC
                   "curvature[%d][%d] = %*.*g\n",
#else
#if INT_LONG
                   "curvature[%ld][%ld] = %*.*g\n",
#else
                   "curvature[%d][%d] = %*.*g\n",
#endif
#endif
                   index_v, index_vv,
                   G_FIELD, G_PRECISION, curvature[index_v_vv]);
        } else {
          fprintf (ptr_asa_out,
#if INT_ALLOC
                   "curvature[%d][%d] = %*.*g \t = curvature[%d][%d]\n",
#else
#if INT_LONG
                   "curvature[%ld][%ld] = %*.*g \t = curvature[%ld][%ld]\n",
#else
                   "curvature[%d][%d] = %*.*g \t = curvature[%d][%d]\n",
#endif
#endif
                   index_v, index_vv,
                   G_FIELD, G_PRECISION, curvature[index_v_vv],
                   index_vv, index_v);
        }
      }
    }
  }
  fprintf (ptr_asa_out, "\n");
  fflush (ptr_asa_out);

}

/***********************************************************************
* print_asa_options
*	Prints user's selected options
***********************************************************************/
#if HAVE_ANSI
void
print_asa_options (FILE * ptr_asa_out, USER_DEFINES * OPTIONS)
#else
void
print_asa_options (ptr_asa_out, OPTIONS)
     FILE *ptr_asa_out;
     USER_DEFINES *OPTIONS;
#endif /* HAVE_ANSI */
{
  fprintf (ptr_asa_out, "\t\tADAPTIVE SIMULATED ANNEALING\n\n");

  fprintf (ptr_asa_out, "%s\n\n", ASA_ID);

  fprintf (ptr_asa_out, "OPTIONS_FILE = %d\n", (int) OPTIONS_FILE);
  fprintf (ptr_asa_out, "OPTIONS_FILE_DATA = %d\n", (int) OPTIONS_FILE_DATA);
  fprintf (ptr_asa_out, "RECUR_OPTIONS_FILE = %d\n",
           (int) RECUR_OPTIONS_FILE);
  fprintf (ptr_asa_out, "RECUR_OPTIONS_FILE_DATA = %d\n",
           (int) RECUR_OPTIONS_FILE_DATA);
  fprintf (ptr_asa_out, "COST_FILE = %d\n", (int) COST_FILE);
  fprintf (ptr_asa_out, "ASA_LIB = %d\n", (int) ASA_LIB);
  fprintf (ptr_asa_out, "HAVE_ANSI = %d\n", (int) HAVE_ANSI);
  fprintf (ptr_asa_out, "IO_PROTOTYPES = %d\n", (int) IO_PROTOTYPES);
  fprintf (ptr_asa_out, "TIME_CALC = %d\n", (int) TIME_CALC);
  fprintf (ptr_asa_out, "TIME_STD = %d\n", (int) TIME_STD);
  fprintf (ptr_asa_out, "TIME_GETRUSAGE = %d\n", (int) TIME_GETRUSAGE);
  fprintf (ptr_asa_out, "INT_LONG = %d\n", (int) INT_LONG);
  fprintf (ptr_asa_out, "INT_ALLOC = %d\n", (int) INT_ALLOC);
  fprintf (ptr_asa_out, "SMALL_FLOAT = %*.*g\n",
           G_FIELD, G_PRECISION, (double) SMALL_FLOAT);
  fprintf (ptr_asa_out, "MIN_DOUBLE = %*.*g\n",
           G_FIELD, G_PRECISION, (double) MIN_DOUBLE);
  fprintf (ptr_asa_out, "MAX_DOUBLE = %*.*g\n",
           G_FIELD, G_PRECISION, (double) MAX_DOUBLE);
  fprintf (ptr_asa_out, "EPS_DOUBLE = %*.*g\n",
           G_FIELD, G_PRECISION, (double) EPS_DOUBLE);
  fprintf (ptr_asa_out, "CHECK_EXPONENT = %d\n", (int) CHECK_EXPONENT);
  fprintf (ptr_asa_out, "NO_PARAM_TEMP_TEST = %d\n",
           (int) NO_PARAM_TEMP_TEST);
  fprintf (ptr_asa_out, "NO_COST_TEMP_TEST = %d\n", (int) NO_COST_TEMP_TEST);
  fprintf (ptr_asa_out, "SELF_OPTIMIZE = %d\n", (int) SELF_OPTIMIZE);
  fprintf (ptr_asa_out, "ASA_TEST = %d\n", (int) ASA_TEST);
  fprintf (ptr_asa_out, "ASA_TEST_POINT = %d\n", (int) ASA_TEST_POINT);
  fprintf (ptr_asa_out, "ASA_EXIT_ANYTIME = %d\n", (int) ASA_EXIT_ANYTIME);
  fprintf (ptr_asa_out, "ASA_TEMPLATE = %d\n", (int) ASA_TEMPLATE);
  fprintf (ptr_asa_out, "MY_TEMPLATE = %d\n", (int) MY_TEMPLATE);
  fprintf (ptr_asa_out, "ASA_TEMPLATE_LIB = %d\n", (int) ASA_TEMPLATE_LIB);
  fprintf (ptr_asa_out, "ASA_TEMPLATE_ASA_OUT_PID = %d\n",
           (int) ASA_TEMPLATE_ASA_OUT_PID);
  fprintf (ptr_asa_out, "ASA_TEMPLATE_MULTIPLE = %d\n",
           (int) ASA_TEMPLATE_MULTIPLE);
  fprintf (ptr_asa_out, "ASA_TEMPLATE_SELFOPT = %d\n",
           (int) ASA_TEMPLATE_SELFOPT);
  fprintf (ptr_asa_out, "ASA_TEMPLATE_SAMPLE = %d\n",
           (int) ASA_TEMPLATE_SAMPLE);
  fprintf (ptr_asa_out, "ASA_TEMPLATE_QUEUE = %d\n",
           (int) ASA_TEMPLATE_QUEUE);
  fprintf (ptr_asa_out, "ASA_TEMPLATE_PARALLEL = %d\n",
           (int) ASA_TEMPLATE_PARALLEL);
  fprintf (ptr_asa_out, "ASA_TEMPLATE_SAVE = %d\n", (int) ASA_TEMPLATE_SAVE);
  fprintf (ptr_asa_out, "USER_INITIAL_COST_TEMP = %d\n",
           (int) USER_INITIAL_COST_TEMP);
  fprintf (ptr_asa_out, "RATIO_TEMPERATURE_SCALES = %d\n",
           (int) RATIO_TEMPERATURE_SCALES);
  fprintf (ptr_asa_out, "USER_INITIAL_PARAMETERS_TEMPS = %d\n",
           (int) USER_INITIAL_PARAMETERS_TEMPS);
  fprintf (ptr_asa_out, "DELTA_PARAMETERS = %d\n", (int) DELTA_PARAMETERS);
  fprintf (ptr_asa_out, "QUENCH_PARAMETERS = %d\n", (int) QUENCH_PARAMETERS);
  fprintf (ptr_asa_out, "QUENCH_COST = %d\n", (int) QUENCH_COST);
  fprintf (ptr_asa_out, "QUENCH_PARAMETERS_SCALE = %d\n",
           (int) QUENCH_PARAMETERS_SCALE);
  fprintf (ptr_asa_out, "QUENCH_COST_SCALE = %d\n", (int) QUENCH_COST_SCALE);
  fprintf (ptr_asa_out, "OPTIONAL_DATA_DBL = %d\n", (int) OPTIONAL_DATA_DBL);
  fprintf (ptr_asa_out, "OPTIONAL_DATA_INT = %d\n", (int) OPTIONAL_DATA_INT);
  fprintf (ptr_asa_out, "OPTIONAL_DATA_PTR = %d\n", (int) OPTIONAL_DATA_PTR);
  fprintf (ptr_asa_out, "USER_COST_SCHEDULE = %d\n",
           (int) USER_COST_SCHEDULE);
  fprintf (ptr_asa_out, "USER_ACCEPT_ASYMP_EXP = %d\n",
           (int) USER_ACCEPT_ASYMP_EXP);
  fprintf (ptr_asa_out, "USER_ACCEPT_THRESHOLD = %d\n",
           (int) USER_ACCEPT_THRESHOLD);
  fprintf (ptr_asa_out, "USER_ACCEPTANCE_TEST = %d\n",
           (int) USER_ACCEPTANCE_TEST);
  fprintf (ptr_asa_out, "USER_GENERATING_FUNCTION = %d\n",
           (int) USER_GENERATING_FUNCTION);
  fprintf (ptr_asa_out, "USER_REANNEAL_COST = %d\n",
           (int) USER_REANNEAL_COST);
  fprintf (ptr_asa_out, "USER_REANNEAL_PARAMETERS = %d\n",
           (int) USER_REANNEAL_PARAMETERS);
#if INT_LONG
  fprintf (ptr_asa_out, "MAXIMUM_REANNEAL_INDEX = %ld\n",
           (LONG_INT) MAXIMUM_REANNEAL_INDEX);
#else
  fprintf (ptr_asa_out, "MAXIMUM_REANNEAL_INDEX = %d\n",
           (LONG_INT) MAXIMUM_REANNEAL_INDEX);
#endif
  fprintf (ptr_asa_out, "REANNEAL_SCALE = %*.*g\n",
           G_FIELD, G_PRECISION, (double) REANNEAL_SCALE);
  fprintf (ptr_asa_out, "ASA_SAMPLE = %d\n", (int) ASA_SAMPLE);
  fprintf (ptr_asa_out, "ADAPTIVE_OPTIONS = %d\n", (int) ADAPTIVE_OPTIONS);
  fprintf (ptr_asa_out, "ASA_QUEUE = %d\n", (int) ASA_QUEUE);
  fprintf (ptr_asa_out, "ASA_RESOLUTION = %d\n", (int) ASA_RESOLUTION);
  fprintf (ptr_asa_out, "ASA_FUZZY = %d\n", (int) ASA_FUZZY);
  fprintf (ptr_asa_out, "ASA_FUZZY_PRINT = %d\n", (int) ASA_FUZZY_PRINT);
  fprintf (ptr_asa_out, "FITLOC = %d\n", (int) FITLOC);
  fprintf (ptr_asa_out, "FITLOC_ROUND = %d\n", (int) FITLOC_ROUND);
  fprintf (ptr_asa_out, "FITLOC_PRINT = %d\n", (int) FITLOC_PRINT);
  fprintf (ptr_asa_out, "MULTI_MIN = %d\n", (int) MULTI_MIN);
  fprintf (ptr_asa_out, "ASA_PARALLEL = %d\n", (int) ASA_PARALLEL);
  fprintf (ptr_asa_out, "FDLIBM_POW = %d\n", (int) FDLIBM_POW);
  fprintf (ptr_asa_out, "FDLIBM_LOG = %d\n", (int) FDLIBM_LOG);
  fprintf (ptr_asa_out, "FDLIBM_EXP = %d\n\n", (int) FDLIBM_EXP);

  fprintf (ptr_asa_out, "ASA_PRINT = %d\n", (int) ASA_PRINT);
  fprintf (ptr_asa_out, "USER_OUT = %s\n", USER_OUT);
#if USER_ASA_OUT
  fprintf (ptr_asa_out, "ASA_OUT = %s\n", OPTIONS->Asa_Out_File);
#else
  fprintf (ptr_asa_out, "ASA_OUT = %s\n", ASA_OUT);
#endif
  fprintf (ptr_asa_out, "USER_ASA_OUT = %d\n", (int) USER_ASA_OUT);
  fprintf (ptr_asa_out, "USER_ASA_USR_OUT = %d\n", (int) USER_ASA_USR_OUT);
  fprintf (ptr_asa_out, "ASA_PRINT_INTERMED = %d\n",
           (int) ASA_PRINT_INTERMED);
  fprintf (ptr_asa_out, "ASA_PRINT_MORE = %d\n", (int) ASA_PRINT_MORE);
  fprintf (ptr_asa_out, "INCL_STDOUT = %d\n", (int) INCL_STDOUT);
  fprintf (ptr_asa_out, "G_FIELD = %d\n", (int) G_FIELD);
  fprintf (ptr_asa_out, "G_PRECISION = %d\n", (int) G_PRECISION);
  fprintf (ptr_asa_out, "ASA_SAVE = %d\n", (int) ASA_SAVE);
  fprintf (ptr_asa_out, "ASA_SAVE_OPT = %d\n", (int) ASA_SAVE_OPT);
  fprintf (ptr_asa_out, "ASA_SAVE_BACKUP = %d\n", (int) ASA_SAVE_BACKUP);
  fprintf (ptr_asa_out, "ASA_PIPE = %d\n", (int) ASA_PIPE);
  fprintf (ptr_asa_out, "ASA_PIPE_FILE = %d\n", (int) ASA_PIPE_FILE);
  fprintf (ptr_asa_out, "SYSTEM_CALL = %d\n\n", (int) SYSTEM_CALL);

#if INT_LONG
  fprintf (ptr_asa_out, "OPTIONS->Limit_Acceptances = %ld\n",
           (LONG_INT) OPTIONS->Limit_Acceptances);
  fprintf (ptr_asa_out, "OPTIONS->Limit_Generated = %ld\n",
           (LONG_INT) OPTIONS->Limit_Generated);
#else
  fprintf (ptr_asa_out, "OPTIONS->Limit_Acceptances = %d\n",
           (LONG_INT) OPTIONS->Limit_Acceptances);
  fprintf (ptr_asa_out, "OPTIONS->Limit_Generated = %d\n",
           (LONG_INT) OPTIONS->Limit_Generated);
#endif
  fprintf (ptr_asa_out, "OPTIONS->Limit_Invalid_Generated_States = %d\n",
           OPTIONS->Limit_Invalid_Generated_States);
  fprintf (ptr_asa_out, "OPTIONS->Accepted_To_Generated_Ratio = %*.*g\n\n",
           G_FIELD, G_PRECISION, OPTIONS->Accepted_To_Generated_Ratio);

  fprintf (ptr_asa_out, "OPTIONS->Cost_Precision = %*.*g\n",
           G_FIELD, G_PRECISION, OPTIONS->Cost_Precision);
  fprintf (ptr_asa_out, "OPTIONS->Maximum_Cost_Repeat = %d\n",
           OPTIONS->Maximum_Cost_Repeat);
  fprintf (ptr_asa_out, "OPTIONS->Number_Cost_Samples = %d\n",
           OPTIONS->Number_Cost_Samples);
  fprintf (ptr_asa_out, "OPTIONS->Temperature_Ratio_Scale = %*.*g\n",
           G_FIELD, G_PRECISION, OPTIONS->Temperature_Ratio_Scale);
  fprintf (ptr_asa_out, "OPTIONS->Cost_Parameter_Scale_Ratio = %*.*g\n",
           G_FIELD, G_PRECISION, OPTIONS->Cost_Parameter_Scale_Ratio);
  fprintf (ptr_asa_out, "OPTIONS->Temperature_Anneal_Scale = %*.*g\n",
           G_FIELD, G_PRECISION, OPTIONS->Temperature_Anneal_Scale);

  fprintf (ptr_asa_out, "OPTIONS->Include_Integer_Parameters = %d\n",
           OPTIONS->Include_Integer_Parameters);
  fprintf (ptr_asa_out, "OPTIONS->User_Initial_Parameters = %d\n",
           OPTIONS->User_Initial_Parameters);
#if INT_ALLOC
  fprintf (ptr_asa_out, "OPTIONS->Sequential_Parameters = %d\n",
           (int) OPTIONS->Sequential_Parameters);
#else
#if INT_LONG
  fprintf (ptr_asa_out, "OPTIONS->Sequential_Parameters = %ld\n",
           (LONG_INT) OPTIONS->Sequential_Parameters);
#else
  fprintf (ptr_asa_out, "OPTIONS->Sequential_Parameters = %d\n",
           (LONG_INT) OPTIONS->Sequential_Parameters);
#endif
#endif
  fprintf (ptr_asa_out, "OPTIONS->Initial_Parameter_Temperature = %*.*g\n",
           G_FIELD, G_PRECISION, OPTIONS->Initial_Parameter_Temperature);

  fprintf (ptr_asa_out, "OPTIONS->Acceptance_Frequency_Modulus = %d\n",
           OPTIONS->Acceptance_Frequency_Modulus);
  fprintf (ptr_asa_out, "OPTIONS->Generated_Frequency_Modulus = %d\n",
           OPTIONS->Generated_Frequency_Modulus);
  fprintf (ptr_asa_out, "OPTIONS->Reanneal_Cost = %d\n",
           OPTIONS->Reanneal_Cost);
  fprintf (ptr_asa_out, "OPTIONS->Reanneal_Parameters = %d\n\n",
           OPTIONS->Reanneal_Parameters);

  fprintf (ptr_asa_out, "OPTIONS->Delta_X = %*.*g\n",
           G_FIELD, G_PRECISION, OPTIONS->Delta_X);
  fprintf (ptr_asa_out, "OPTIONS->User_Tangents = %d\n",
           OPTIONS->User_Tangents);
  fprintf (ptr_asa_out, "OPTIONS->Curvature_0 = %d\n", OPTIONS->Curvature_0);
  fprintf (ptr_asa_out, "OPTIONS->Asa_Recursive_Level = %d\n\n",
           OPTIONS->Asa_Recursive_Level);

  fprintf (ptr_asa_out, "\n");
}
#endif /* ASA_PRINT */

#if TIME_CALC
#if TIME_GETRUSAGE
/***********************************************************************
* print_time
*	This calculates the time and runtime and prints it.
***********************************************************************/
#if HAVE_ANSI
void
print_time (char *message, FILE * ptr_asa_out)
#else
void
print_time (message, ptr_asa_out)
     char *message;
     FILE *ptr_asa_out;
#endif /* HAVE_ANSI */
{
  int who = RUSAGE_SELF;        /* Check our own time */
  struct rusage usage;

  /* get the resource usage information */
#if TIME_STD
  syscall (SYS_GETRUSAGE, who, &usage);
#else
  getrusage (who, &usage);
#endif

  /* print the usage time in reasonable form */
  aux_print_time (&usage.ru_utime, message, ptr_asa_out);
}

/***********************************************************************
* aux_print_time
*      auxiliary print the time routine
***********************************************************************/
#if HAVE_ANSI
void
aux_print_time (struct timeval *time, char *message, FILE * ptr_asa_out)
#else
void
aux_print_time (time, message, ptr_asa_out)
     struct timeval *time;
     char *message;
     FILE *ptr_asa_out;
#endif /* HAVE_ANSI */
{
  static double sx;
  double us, s, m, h;
  double ds, dm, dh;

  /* calculate the new microseconds, seconds, minutes, hours
     and the differences since the last call */
  us = (double) ((int) ((double) EPS_DOUBLE + time->tv_usec)) / 1.E6;
  s = (double) ((int) ((double) EPS_DOUBLE + time->tv_sec)) + us;
  ds = s - sx;
  sx = s;

  h = (int) ((double) EPS_DOUBLE + s / 3600.);
  m = (int) ((double) EPS_DOUBLE + s / 60.) - 60. * h;
  s -= (3600. * h + 60. * m);
  dh = (int) ((double) EPS_DOUBLE + ds / 3600.);
  dm = (int) ((double) EPS_DOUBLE + ds / 60.) - 60. * dh;
  ds -= (3600. * dh + 60. * dm);

  /* print the statistics */
  fprintf (ptr_asa_out,
           "%s:time: %gh %gm %gs; incr: %gh %gm %gs\n",
           message, h, m, s, dh, dm, ds);
}
#else /* TIME_GETRUSAGE */
  /* Note that on many machines the time resolution of this algorithm
   * may be less than the other alternatives, e.g., rounding off the
   * number of ticks to the nearest tens of thousands.  Also, because
   * time here is typically indexed by a long integer, there typically
   * is a cycle of time in periods of fractions of an hour.  For
   * example, under Solaris 2.5.1:  The value returned by clock() is
   * defined in microseconds, since the first call to clock(), for
   * compatibility with  systems that have CPU clocks with much higher
   * resolution.  Because of this, the value returned will wrap around
   * after accumulating only 2147 seconds of CPU time (about 36 minutes).
   *
   * Set TIME_GETRUSAGE to FALSE and TIME_STD to TRUE under
   * Cygwin with -mno-cygwin
   *
   * See asa.h for two places where some additional modifications should
   * be made under SunOS 4.1.x. */

#if HAVE_ANSI
void
print_time (char *message, FILE * ptr_asa_out)
#else
void
print_time (message, ptr_asa_out)
     char *message;
     FILE *ptr_asa_out;
#endif /* HAVE_ANSI */
{
  aux_print_time (clock (), message, ptr_asa_out);

}                               /*print_time */

/***********************************************************************
* aux_print_time
*      auxiliary print the time routine
***********************************************************************/
#if HAVE_ANSI
void
aux_print_time (clock_t time, char *message, FILE * ptr_asa_out)
#else
void
aux_print_time (time, message, ptr_asa_out)
     clock_t time;
     char *message;
     FILE *ptr_asa_out;
#endif /* HAVE_ANSI */
{
  static clock_t previousTime = -1;
  clock_t diffTime;
  double clocksPerSecF = CLOCKS_PER_SEC;
  double timeF, diffF;
  double s, m, h;
  double ds, dm, dh;

  if (previousTime != -1) {
    diffTime = time - previousTime;
    timeF = time;
    diffF = diffTime;
    previousTime = time;

    s = timeF / clocksPerSecF;
    ds = diffF / clocksPerSecF;

    h = (int) ((double) EPS_DOUBLE + s / 3600.);
    m = (int) ((double) EPS_DOUBLE + s / 60.) - 60. * h;
    s -= (3600. * h + 60. * m);
    dh = (int) ((double) EPS_DOUBLE + ds / 3600.);
    dm = (int) ((double) EPS_DOUBLE + ds / 60.) - 60. * dh;
    ds -= (3600. * dh + 60. * dm);

    fprintf (ptr_asa_out,
             "%s:time: %gh %gm %gs; incr: %gh %gm %gs\n",
             message, h, m, s, dh, dm, ds);
  } else {
    /* The first call will be invalid - don't output anything. */
    fprintf (ptr_asa_out, "TIMING PARAMETERS: ticks/sec: %lu\n",
             CLOCKS_PER_SEC);
    previousTime = time;
    /* Output initial message. */
    print_time (message, ptr_asa_out);
  }
}                               /* aux_print_time */

#endif /* TIME_GETRUSAGE */

#endif /* TIME_CALC */

#if MULTI_MIN
#if HAVE_ANSI
static int
multi_compare (const void *ii, const void *jj)
#else /* HAVE_ANSI */
static int
multi_compare (ii, jj)
     char *ii;
     char *jj;
#endif /* HAVE_ANSI */
{
  int i;
  int j;

  i = *(int *) ii;
  j = *(int *) jj;

  if (multi_cost_qsort[i] > multi_cost_qsort[j] + (double) EPS_DOUBLE)
    return (1);
  else if (multi_cost_qsort[i] < multi_cost_qsort[j] - (double) EPS_DOUBLE)
    return (-1);
  else
    return (0);
}
#endif /* MULTI_MIN */

#if ASA_PARALLEL
#if HAVE_ANSI
static int
sort_parallel (const void *ii, const void *jj)
#else /* HAVE_ANSI */
static int
sort_parallel (ii, jj)
     void *ii;
     void *jj;
#endif /* HAVE_ANSI */
{
  LONG_INT i;
  LONG_INT j;

  i = *(LONG_INT *) ii;
  j = *(LONG_INT *) jj;

  if (gener_block_state_qsort[i].cost > gener_block_state_qsort[j].cost)
    return (1);
  else if (gener_block_state_qsort[i].cost < gener_block_state_qsort[j].cost)
    return (-1);
  else
    return (0);
}
#endif /* ASA_PARALLEL */
#if HAVE_ANSI
void
Exit_ASA (char *statement)
#else /* HAVE_ANSI */
void
Exit_ASA (statement)
     char *statement;
#endif /* HAVE_ANSI */
{
#if INCL_STDOUT
  printf ("\n\n*** EXIT calloc failed in ASA *** %s\n\n", statement);
#else
  ;
#endif /* INCL_STDOUT */
}
#ifndef _ASA_H_
#define _ASA_H_
#ifdef __cplusplus
extern "C" {
#endif

/***********************************************************************
* Adaptive Simulated Annealing (ASA)
* Lester Ingber <ingber@ingber.com>
* Copyright (c) 1987-2016 Lester Ingber.  All Rights Reserved.
* ASA-LICENSE file has the license that must be included with ASA code.
***********************************************************************/

  /* $Id: asa.h,v 30.21 2016/02/02 15:49:44 ingber Exp ingber $ */

  /* asa.h for Adaptive Simulated Annealing */

#include "asa_usr_asa.h"

#define ZERO			((double) 0.0)
#define ONE			((double) 1.0)
#define TWO			((double) 2.0)
#define TEN			((double) 10.0)
#define HALF			((double) 0.5)

#define NORMAL_EXIT			((int) 0)
#define P_TEMP_TOO_SMALL		((int) 1)
#define C_TEMP_TOO_SMALL		((int) 2)
#define COST_REPEATING			((int) 3)
#define TOO_MANY_INVALID_STATES		((int) 4)
#define IMMEDIATE_EXIT			((int) 5)
#define INVALID_USER_INPUT		((int) 7)
#define INVALID_COST_FUNCTION		((int) 8)
#define INVALID_COST_FUNCTION_DERIV	((int) 9)
#define CALLOC_FAILED			((int) -1)

#ifndef TIME_STD
#define TIME_STD FALSE
#endif

#ifndef TIME_GETRUSAGE
#define TIME_GETRUSAGE TRUE
#endif

#if TIME_CALC
#if TIME_GETRUSAGE
#include <sys/time.h>
#include <sys/resource.h>
#if TIME_STD
#include <sys/syscall.h>
#endif                          /* TIME_STD */
#else                           /* TIME_GETRUSAGE */
#if TRUE                        /* change to FALSE for SunOS 4.1.x */
#include <time.h>
#else
#include </usr/5include/time.h>
#endif
#endif                          /* TIME_GETRUSAGE */
#endif                          /* TIME_CALC */

  /* Set this to TRUE to override the P_TEMP_TOO_SMALL test */
#ifndef NO_PARAM_TEMP_TEST
#define NO_PARAM_TEMP_TEST FALSE
#endif

  /* Set this to TRUE to override the C_TEMP_TOO_SMALL test */
#ifndef NO_COST_TEMP_TEST
#define NO_COST_TEMP_TEST FALSE
#endif

#ifndef SYSTEM_CALL
#define SYSTEM_CALL TRUE
#endif

  /* Printing Options */

#ifndef ASA_PRINT
#define ASA_PRINT TRUE
#endif

#if ASA_PRINT
#else
#if ASA_SAMPLE
#define ASA_PRINT TRUE
#endif
#endif

#ifndef ASA_OUT
#define ASA_OUT "asa_out"
#endif

#ifndef DROPPED_PARAMETERS
#define DROPPED_PARAMETERS FALSE
#endif

  /* You can set ASA_PRINT_INTERMED to TRUE to print out
     intermediate data when SELF_OPTIMIZE is set to TRUE */
#ifndef ASA_PRINT_INTERMED
#if SELF_OPTIMIZE
#define ASA_PRINT_INTERMED FALSE
#else
#define ASA_PRINT_INTERMED TRUE
#endif
#endif

#ifndef ASA_PRINT_MORE
#define ASA_PRINT_MORE FALSE
#endif

  /* The state of the system in terms of parameters and function value */
  typedef struct {
    double cost;
    double *parameter;
#if ASA_PARALLEL
#if USER_ACCEPTANCE_TEST
    int par_user_accept_flag;
    int par_cost_accept_flag;
#endif
#endif
  } STATE;

#if ASA_PARALLEL
  /* parallel generated states */
  STATE *gener_block_state_qsort;
#endif

  /* essential MACROS */

#if USER_REANNEAL_PARAMETERS
#else
  /* FUNCTION_REANNEAL_PARAMS(temperature, tangent, max_tangent)
     determines the reannealed temperature. */
#define FUNCTION_REANNEAL_PARAMS(temperature, tangent, max_tangent) (temperature * (max_tangent / tangent))
#endif

  /* IABS(i)
     absolute value for integers, in stdlib.h on _some_ machines */
#define IABS(i) ((i) < 0? -(i) : (i))

  /*  NO_REANNEAL(x)
     can determine whether to calculate derivatives. */
#define NO_REANNEAL(x)	(IABS(parameter_type[x]) == 2)

  /* VFOR
     is a simple macro to iterate on each parameter index. */

#define VFOR(index_v) for (index_v = 0; index_v < *number_parameters; ++index_v)

#if CHECK_EXPONENT
  /* EXPONENT_CHECK
     checks that an exponent x is within a valid range and,
     if not, adjusts its magnitude to fit in the range. */
#define MIN_EXPONENT (0.9 * F_LOG ((double) MIN_DOUBLE))
#define MAX_EXPONENT (0.9 * F_LOG ((double) MAX_DOUBLE))
#define EXPONENT_CHECK(x) ((x) < MIN_EXPONENT ? MIN_EXPONENT : ((x) > MAX_EXPONENT ? MAX_EXPONENT : (x)))
#else
#define EXPONENT_CHECK(x) (x)
#endif                          /* CHECK_EXPONENT */

  /* PARAMETER_RANGE_TOO_SMALL(x)
     checks if the range of parameter x is too small to work with.
     If user_cost_function changes the parameter ranges,
     this test could be used to adaptively bypass
     some parameters, e.g., depending on constraints. */
#define PARAMETER_RANGE_TOO_SMALL(x) (fabs(parameter_minimum[x] - parameter_maximum[x]) < (double) EPS_DOUBLE)

  /* INTEGER_PARAMETER(x)
     determines if the parameter is an integer type. */
#define INTEGER_PARAMETER(x) (parameter_type[x] > 0)

  /* ROW_COL_INDEX(i, j)
     converts from row i, column j to an index. */
#define ROW_COL_INDEX(i, j) ((i) + *number_parameters * (j))

#if HAVE_ANSI

  /* asa function prototypes */
  void accept_new_state (double (*user_random_generator) (LONG_INT *),
                         LONG_INT * seed,
                         double *parameter_minimum,
                         double *parameter_maximum,
                         double *current_cost_temperature,
#if ASA_SAMPLE
                         double *current_user_parameter_temp,
#endif
                         ALLOC_INT * number_parameters,
                         LONG_INT * recent_number_acceptances,
                         LONG_INT * number_accepted,
                         LONG_INT * index_cost_acceptances,
                         LONG_INT * number_acceptances_saved,
                         LONG_INT * recent_number_generated,
                         LONG_INT * number_generated,
                         LONG_INT * index_parameter_generations,
                         STATE * current_generated_state,
                         STATE * last_saved_state,
#if ASA_SAMPLE
                         FILE * ptr_asa_out,
#endif
                         USER_DEFINES * OPTIONS);

  int generate_new_state (double (*user_random_generator) (LONG_INT *),
                          LONG_INT * seed,
                          double *parameter_minimum,
                          double *parameter_maximum,
                          double *current_parameter_temperature,
#if USER_GENERATING_FUNCTION
                          double *initial_user_parameter_temp,
                          double *temperature_scale_parameters,
#endif
                          ALLOC_INT * number_parameters,
                          int *parameter_type,
                          STATE * current_generated_state,
                          STATE * last_saved_state, USER_DEFINES * OPTIONS);
#if ASA_PARALLEL
  int generate_new_state_par (double (*user_random_generator) (LONG_INT *),
                              LONG_INT * seed,
                              double *parameter_minimum,
                              double *parameter_maximum,
                              double *current_parameter_temperature,
#if USER_GENERATING_FUNCTION
                              double *initial_user_parameter_temp,
                              double *temperature_scale_parameters,
#endif
                              ALLOC_INT * number_parameters,
                              int *parameter_type,
                              LONG_INT i_prll,
                              STATE * gener_block_state,
                              STATE * last_saved_state,
                              USER_DEFINES * OPTIONS);
#endif                          /* ASA_PARALLEL */

  void reanneal (double *parameter_minimum,
                 double *parameter_maximum,
                 double *tangents,
                 double *maximum_tangent,
                 double *current_cost_temperature,
                 double *initial_cost_temperature,
                 double *temperature_scale_cost,
                 double *current_user_parameter_temp,
                 double *initial_user_parameter_temp,
                 double *temperature_scale_parameters,
                 ALLOC_INT * number_parameters,
                 int *parameter_type,
                 LONG_INT * index_cost_acceptances,
                 LONG_INT * index_parameter_generations,
                 STATE * last_saved_state,
                 STATE * best_generated_state, USER_DEFINES * OPTIONS);

  void
    cost_derivatives (double (*user_cost_function)

                       
                      (double *, double *, double *, double *, double *,
                       ALLOC_INT *, int *, int *, int *, USER_DEFINES *),
                      double *parameter_minimum, double *parameter_maximum,
                      double *tangents, double *curvature,
                      double *maximum_tangent, ALLOC_INT * number_parameters,
                      int *parameter_type, int *exit_status,
                      int *curvature_flag, int *valid_state_generated_flag,
                      LONG_INT * number_invalid_generated_states,
                      STATE * current_generated_state,
                      STATE * best_generated_state, FILE * ptr_asa_out,
                      USER_DEFINES * OPTIONS);

  double generate_asa_state (double (*user_random_generator) (LONG_INT *),
                             LONG_INT * seed, double *temp);

  int
    asa_exit (double (*user_cost_function)

               
              (double *, double *, double *, double *, double *, ALLOC_INT *,
               int *, int *, int *, USER_DEFINES *), double *final_cost,
              double *parameter_initial_final, double *parameter_minimum,
              double *parameter_maximum, double *tangents, double *curvature,
              double *maximum_tangent, double *current_cost_temperature,
              double *initial_user_parameter_temp,
              double *current_user_parameter_temp,
              double *accepted_to_generated_ratio,
              ALLOC_INT * number_parameters, int *parameter_type,
              int *valid_state_generated_flag, int *exit_status,
              ALLOC_INT * index_exit_v, ALLOC_INT * start_sequence,
              LONG_INT * number_accepted,
              LONG_INT * best_number_accepted_saved,
              LONG_INT * index_cost_acceptances, LONG_INT * number_generated,
              LONG_INT * number_invalid_generated_states,
              LONG_INT * index_parameter_generations,
              LONG_INT * best_number_generated_saved,
              STATE * current_generated_state, STATE * last_saved_state,
              STATE * best_generated_state, FILE * ptr_asa_out,
              USER_DEFINES * OPTIONS);

  void Exit_ASA (char *statement);

  int asa_test_asa_options (LONG_INT * seed,
                            double *parameter_initial_final,
                            double *parameter_minimum,
                            double *parameter_maximum,
                            double *tangents,
                            double *curvature,
                            ALLOC_INT * number_parameters,
                            int *parameter_type,
                            int *valid_state_generated_flag,
                            int *exit_status,
                            FILE * ptr_asa_out, USER_DEFINES * OPTIONS);

  int cost_function_test (double cost,
                          double *parameter,
                          double *parameter_minimum,
                          double *parameter_maximum,
                          ALLOC_INT * number_parameters,
                          double *xnumber_parameters);

  void print_string (FILE * ptr_asa_out, char *string);
  void print_string_index (FILE * ptr_asa_out, char *string, ALLOC_INT index);

#if ASA_PRINT
  void print_state (double *parameter_minimum,
                    double *parameter_maximum,
                    double *tangents,
                    double *curvature,
                    double *current_cost_temperature,
                    double *current_user_parameter_temp,
                    double *accepted_to_generated_ratio,
                    ALLOC_INT * number_parameters,
                    int *curvature_flag,
                    LONG_INT * number_accepted,
                    LONG_INT * index_cost_acceptances,
                    LONG_INT * number_generated,
                    LONG_INT * number_invalid_generated_states,
                    STATE * last_saved_state,
                    STATE * best_generated_state,
                    FILE * ptr_asa_out, USER_DEFINES * OPTIONS);

  void print_asa_options (FILE * ptr_asa_out, USER_DEFINES * OPTIONS);
#endif                          /* ASA_PRINT */

#if TIME_CALC
#if TIME_GETRUSAGE
  void aux_print_time (struct timeval *time, char *message,
                       FILE * ptr_asa_out);
#if TIME_STD
  int syscall (int sys_option, int who, struct rusage *usage);
#else
  int getrusage (int who, struct rusage *usage);
#endif                          /* TIME_STD */
#else                           /* TIME_GETRUSAGE */
  void aux_print_time (clock_t time, char *message, FILE * ptr_asa_out);
#if FALSE                       /* change to TRUE for SunOS 4.1.x */
  clock_t clock ();
#endif
#endif                          /* TIME_GETRUSAGE */
#endif                          /* TIME_CALC */

#if MULTI_MIN
  static int multi_compare (const void *cost_ii, const void *cost_jj);
  double *multi_cost_qsort;
#endif

#if ASA_PARALLEL
  static int sort_parallel (const void *cost_ii, const void *cost_jj);
#endif

#else                           /* HAVE_ANSI */

  void accept_new_state ();
  int generate_new_state ();
#if ASA_PARALLEL
  int generate_new_state_par ();
#endif                          /* ASA_PARALLEL */
  void reanneal ();
  void cost_derivatives ();
  double generate_asa_state ();
  int asa_exit ();
  void Exit_ASA ();
  int asa_test_asa_options ();
  int cost_function_test ();
  void print_string ();
  void print_string_index ();

#if ASA_PRINT
  void print_state ();
  void print_asa_options ();
#endif                          /* ASA_PRINT */

#if TIME_CALC
  void aux_print_time ();
#if TIME_GETRUSAGE
#if TIME_STD
  int syscall ();
#else
  int getrusage ();
#endif                          /* TIME_STD */
#else                           /* TIME_GETRUSAGE */
#if FALSE                       /* change to TRUE for SunOS 4.1.x */
  clock_t clock ();
#endif
#endif                          /* TIME_GETRUSAGE */
#endif                          /* TIME_CALC */

#if MULTI_MIN
  static int multi_compare ();
  double *multi_cost_qsort;
#endif

#if ASA_PARALLEL
  static int sort_parallel ();
#endif

#endif                          /* HAVE_ANSI */
  static int asa_recursive_max = 0;     /* record of max recursions */

#ifdef __cplusplus
}
#endif
#endif                          /* _ASA_H_ */
		  http://www.ingber.com/asa_examples.txt

This file contains some "toy" problems optimized using ASA, which can
provide immediate examples on how you can optimize your own problem.
For papers dealing with difficult systems across a wide range of
disciplines, see
	http://www.ingber.com/asa_papers.html
	http://www.ingber.com/asa_papers.txt

			CONTENTS

@@CHANGES
@@Note on ASA Versions
@@Some Helpful Code Snippets
	@@Independent Coordinates When Sampling Large Spaces
@@Use of ASA_TEST_POINT=TRUE
@@Quenching ASA_TEST Problem
@@Use of COST_FILE on Shubert Problem - SA vs Taboo
@@Colville Examples
@@OPTIONAL_DATA_PTR and MULTI_MIN

========================================================================
22 Feb 03

@@CHANGES

Renamed files to faciliate their use in larger projects:
asa_user.h -> asa_usr_asa.h
user.c -> asa_usr.c
user.h -> asa_usr.h
user_cst.c -> asa_usr_cst.c
readme.ms -> ASA-README.ms
test_asa -> asa_test_asa
test_usr -> asa_test_usr

========================================================================
@@Note on ASA Versions

The instructions given below to run various examples should be correct
as of the date and/or ASA versions given.  Later ASA versions may have
had some defaults changed, and this will change the nature of the
runs.  Tuning is essential for any global optimization code that is to
be applied successfully to many classes of nonlinear/stochastic
systems.  I of course have archived all previous ASA versions so that
results given here should be reproducible by anyone that can compile
the given version of the ASA code.

Lester

========================================================================
@@Some Helpful Code Snippets

========================================================================
	@@Independent Coordinates When Sampling Large Spaces
16 Jan 09

Here is something you might try in a large parameter space of size
*parameter_dimension:  For the first *parameter_dimension generated
states (+1; see below), it might be reasonable to "seed" the sampling
by at least first calculating each parameter independently -- like each
axis of a coordinate system.

In your cost function, you could add something like:

  for (i = 0; i < *parameter_dimension; ++i) {
...
    /* first sample independent parameter coordinates */
    if (USER_OPTIONS->N_Generated > 0   /* skip cost temperature tests */
        && USER_OPTIONS->N_Generated <= *parameter_dimension) {
      if ((LONG_INT) i == USER_OPTIONS->N_Generated - 1) {
        x[i] = 1; /* some reasonable value */
      } else {
        x[i] = 0; /* some reasonable value */
      }
    }
...
  }

Of course, you likely want to respect parameter_upper_bound[] and
parameter_lower_bound[], and any OPTIONS like ASA_RESOLUTION set to
TRUE, etc.

========================================================================
========================================================================
@@Use of ASA_TEST_POINT=TRUE

15 Feb 08

Since 1997 the ASA defaults have changed.  To get good results with
ASA_TEST_POINT=TRUE, the suggestions made for changes in asa_opt in 1997
can be changed to
Limit_Acceptances[10000][ASA_TEST:1000]                 99999
Limit_Generated[99999]                                  999999
Maximum_Cost_Repeat[5]                                  0
Temperature_Ratio_Scale[1.0E-5]                         5.0E-3
Reanneal_Cost[1]                                        5
Reanneal_Parameters[TRUE=1]                             0

(No change in User_Quench_Cost_Scale[0])

This gives at the end of asa_out:
*index_cost_acceptances = 9218, *current_cost_temperature = 3.553019e-14
*accepted_to_generated_ratio =   0.05473632, *number_invalid... = 0
*number_generated = 978255, *number_accepted = 100000
best...->cost = 3.364429e-15, last...->cost = 1.995893e-13
index_v  best...->parameter current_parameter_temp      tangent
0       -2.993211e-08           1.305639e-23    -5.989416e-08
1       -1.235232e-09           1.305639e-23     -2.4717e-06
2        5.21106e-10            1.305639e-23    1.042733e-08
3       -3.065916e-09           1.305639e-23    -6.134897e-07

curvature[0][0] =            2

curvature[1][0] =            0   = curvature[0][1]
curvature[1][1] =         2000

curvature[2][0] =           -0   = curvature[0][2]
curvature[2][1] = -6.127676e-07          = curvature[1][2]
curvature[2][2] =           20

curvature[3][0] = -4.298064e-09          = curvature[0][3]
curvature[3][1] =            0   = curvature[1][3]
curvature[3][2] =           -0   = curvature[2][3]
curvature[3][3] =          200

 NORMAL_EXIT exit_status = 0
 Locate_Cost = 5, calculating curvatures while exiting asa ()
final_cost = best_generated_state->cost = 3.364429e-15
*number_accepted at best_generated_state->cost = 99782
*number_generated at best_generated_state->cost = 974255

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

13 Mar 97

The code used for the ASA_TEST problem closely follows the reference
given in user.c,
	%A A. Corana
	%A M. Marchesi
	%A C. Martini
	%A S. Ridella
	%T Minimizing multimodal functions of continuous variables
	   with the "simulated annealing" algorithm
	%J ACM Trans. Mathl. Software
	%V 13
	%N 3
	%P 262-279
	%D 1987
and was rewritten from code given to the author in 1992.  Other
researchers have sent the author different code for this system, and
all results have agreed within round-off errors.

However, note that the actual problem stated in the above reference is
harder, as pointed out by Dietmar Auferkorte
<dietmar.auferkorte@fernuni-hagen.de>, requiring the finding of an
optimal point and not an optimal region.  The code for that problem is
given when ASA_TEST_POINT is set to TRUE, and the asa_examples.txt file
illustrates how that global minimum can be attained.

The following OPTIONS give one instance of tuning that achieves the
optimal point.  When ASA_TEST_POINT is TRUE, requiring at least ASA
version 12.14, then in asa_user.h SMALL_FLOAT is set to 1.0E-50,
QUENCH_COST is set to TRUE, and COST_FILE is set to FALSE.  The
following OPTIONS also are changed from their defaults:

Limit_Acceptances[10000][ASA_TEST:1000]			99999
Limit_Generated[99999]					999999
Maximum_Cost_Repeat[5]					0
Temperature_Ratio_Scale[1.0E-5]				1.0E-3
Reanneal_Cost[1]					5
Reanneal_Parameters[TRUE=1]				0

User_Quench_Cost_Scale[0]=1.0				0.9

I only tuned to the point where I felt there was no longer any trapping
for long periods in local minima, while the *current_cost_temperature
reasonably reflected changes in the last...->cost.  The above reference
usually achieved a cost function of approximately 1.0E-7 in about 1.4E6
function evaluations.  Some excerpts from the ASA run, using
ASA_PRINT_MORE set to TRUE, are:

best...->cost=1.769186e+09  *number_accepted=3  *number_generated=10
best...->cost=101.7291      *number_accepted=1208  *number_generated=8366
best...->cost=0.3420184     *number_accepted=2698  *number_generated=19687
best...->cost=0.03375       *number_accepted=4117  *number_generated=28825
best...->cost=0.003375      *number_accepted=6553  *number_generated=43480
best...->cost=0.0001313457  *number_accepted=22501  *number_generated=126766
best...->cost=9.976521e-06  *number_accepted=23174  *number_generated=131821
best...->cost=4.748379e-07  *number_accepted=24849  *number_generated=145542
index_v  best...->parameter current_parameter_temp      tangent
0       -7.698884e-05           2.953263e-19               0
1       6.797281e-06            2.953263e-19               0
2       0.0001912543            2.953263e-19               0
3       -2.385909e-05           2.953263e-19               0

best...->cost=9.07589e-08   *number_accepted=26580  *number_generated=159669
best...->cost=8.795788e-09  *number_accepted=32810  *number_generated=209870
best...->cost=1.088038e-10  *number_accepted=39744  *number_generated=266565
index_v  best...->parameter current_parameter_temp      tangent
0       8.817353e-06            2.778487e-22               0
1       1.006906e-07            2.778487e-22               0
2       9.071919e-07            2.778487e-22               0
3       3.562237e-07            2.778487e-22               0

best...->cost=7.750598e-13  *number_accepted=61731  *number_generated=451282
best...->cost=9.92982e-16   *number_accepted=86071  *number_generated=666200
index_v  best...->parameter current_parameter_temp      tangent
0       1.111623e-08            7.882882e-28               0
1       -2.796306e-10           7.882882e-28               0
2       4.326713e-09            7.882882e-28               0
3       2.457669e-09            7.882882e-28               0

========================================================================
@@Quenching ASA_TEST Problem

5 Jan 96

A researcher sent a query, questioning why a new genetic algorithm (GA)
could find optimal states of the ASA_TEST problem more efficiently than
ASA, and why ASA failed completely for N = 12 for this system.

: Thank you very much for all the informations. The function we were
: using was the same as yours. It is indeed a very interesting
: function. Our results with the GA were closed to VFSR for N=4. For N=8
: we were faster, for N=12 VFSR does not seem to be able to find the
: optimum (we find it in an average 63000 evaluations on 10 runs of the
: GA).

I replied:

> I insisted in this project on not tuning VFSR at all.  In subsequent
> runs I had no problem getting the global minimum with VFSR for as high
> as N=12.
>
> Tuning of course is quite important as nonlinear systems typically are
> non-typical, and I do not believe any method of global optimization can
> perform well across most nonlinear problems without tuning.
>
> ...
>
> As I said, I'm pretty busy right now, so I do not have time to spend on
> these test problems.  I gave myself a limit of 15 minutes to play with
> N=12.  The run is given below.  Within machine accuracy, I get the
> optimal state with cost = 0 in 5410 generations.  I'm sure I could do
> better, even having to play more to take into account different random
> seeds (which of course could require tuning to take into account
> missing the global optimal point sometimes, etc.)

Here is this quick example (_not_ a statistical study) of the power of
quenching to solve the 12-dimensional ASA_TEST problem.  The use of
quenching with ASA is more appropriate to make comparisons with GA, as
GA techniques by themselves do not offer any kind of weak ergodic
sampling.

In the Makefile, use

DEFINE_OPTIONS = -DASA_TEST=TRUE -DQUENCH_COST=TRUE \
-DQUENCH_PARAMETERS=TRUE -DSMALL_FLOAT=1.0E-60

In the asa_opt file, modify as follows:

Limit_Acceptances[10000][ASA_TEST:1000]
99999
...
Cost_Parameter_Scale_Ratio[1.0]
0.1
...
Acceptance_Frequency_Modulus[100]
50
...
Reanneal_Cost[1]
5
Reanneal_Parameters[TRUE=1]
0
...
___Define_below_if_OPTIONS_FILE_DATA=TRUE
 
number_parameters=*parameter_dimension
12
 
Param#:Minimum:Maximum:InitialValue:Integer[1or2]orReal[-1or-2]
0       -10000  10000   999.0                   -1
1       -10000  10000   -1007.0                 -1
2       -10000  10000   1001.0                  -1
3       -10000  10000   -903.0                  -1
4       -10000  10000   999.0                   -1
5       -10000  10000   -1007.0                 -1
6       -10000  10000   1001.0                  -1
7       -10000  10000   -903.0                  -1
8       -10000  10000   999.0                   -1
9       -10000  10000   -1007.0                 -1
10      -10000  10000   1001.0                  -1
11      -10000  10000   -903.0                  -1
 
___Define_below_if_QUENCH_COST_and_OPTIONS_FILE_DATA=TRUE
 
*User_Quench_Cost_Scale
18.0
 
___Define_below_if_QUENCH_PARAMETERS_and_QUENCH_COST_and_OPTIONS_FILE_DATA=TRUE
 
Param#:User_Quench_Param_Scale[]
0       18.0
1       18.0
2       18.0
3       18.0
4       18.0
5       18.0
6       18.0
7       18.0
8       18.0
9       18.0
10      18.0
11      18.0

Versions after 11.22 do not need any additional changes.  At the end of
asa_out you should get on a Sun SPARC-2/4.1.3 (other machines may give
somewhat different results due to their precision and double limit
defaults)

 COST_REPEATING exit_status = 3
final_cost = best_generated_state->cost = 0           
*number_accepted at best_generated_state->cost = 1857
*number_generated at best_generated_state->cost = 5410

The conclusion to draw is:

> I have no doubts that you could find another algorithm faster than ASA
> for any particular problem.  I just do not accept that a GA algorithm
> can solve a system that cannot be solved by ASA.  This may require some
> different computer resources though, e.g., as ASA may require a very
> high precision capability to deal with very low temperatures, etc.
>  
> At least one moral to draw is that in the hands of an expert a
> particular global optimization algorithm can usually do quite well on a
> large number of systems.

========================================================================
@@Use of COST_FILE on Shubert Problem - SA vs Taboo

12 Feb 95 (updated using version 13.5 on 30 Aug 96)

In
	%A D. Cvijovic\*'
	%A J. Klinowski
	%T Taboo search: An approach to the multiple minima problem
	%J Science
	%V 267
	%D 1995
	%P 664-666
some strong claims about the superiority of taboo search over
genetic algorithms and simulated annealing were made.

I took the only function given that also gave all parameters in this
article, the Shubert function, and ran a straight ASA test with
absolutely no tuning.  (I _do_ consider tuning essential for optimum
use of any global optimization algorithm.  Furthermore, since schedules
and algorithms used by the other techniques are equivalent to
quenching, QUENCHing in ASA could have been used to even greater
advantage in lowering #generated.)  The article states that the numbers
in Table 3 were obtained by counting the number of generated cost
functions needed to first attain a known global minimum of -186.7309.
(There are 18 global minima out of 760 local minima).  Below, the first
3 lines are the results in that paper for taboo search (TS), and two
variants of simulated annealing, SA1 and SA2, averaged over 100 runs.
The last line is the result from ASA.
		Method		#generated
		--------------------------
		SA1		241,215
		SA2		    780
		TS		    727
		ASA		     21

The result of course will vary somewhat with the initial seed for the
RNG and with the initial guess for the 2 parameters.  As argued for
many other cases, the fat tail of ASA, creating a rather large
generated to acceptance ratio, usually insures that the variance of the
results is not too large.  (Note that here there are 18 global minima
which may cause more of a spread.)  The 100 iterations of asa() were
developed from starting values of (5, 5), but using the default to let
ASA randomly select the initial values for the annealing loop, getting
		min	=	0
		max	=	136
		mean	=	20.5
		sd	=	22.1

Another criteria used by these authors is that the algorithm be able to
find the global region 95% of the time.  Although ASA finds the global
region all the time, if the highest 5% are dropped, then the stats are
		min	=	0
		max	=	57
		mean	=	16.8
		sd	=	14.0

In general, all authors should exercise caution in promoting any one
global optimization algorithm over all others for all problems.

To run this, e.g., just modify ASA in four (4) steps:
 
(1)
Makefile: Change the DEFINE_OPTIONS just above the line
	## This will run the ASA problem.
to
	DEFINE_OPTIONS = -DG_FIELD=14 -DG_PRECISION=9
(or feed these DEFINE_OPTIONS to your compiler as described in the
ASA-README).  This just affects the format of the information printed out
to asa_out.  If you do not have an ANSI compiler, add -DHAVE_ANSI=FALSE
to these DEFINE_OPTIONS.

(2) In asa_opt set:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
number_parameters=*parameter_dimension                  2

Param#:Minimum:Maximum:InitialValue:Integer[1or2]orReal[-1or-2]
0       -10     10      5.0             -1
1       -10     10      5.0             -1

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

(3) Insert into user_cst.c (user_cst.h prior to version 22):
(4 Oct 2010 corrected by Ceren Kayalar <ckayalar@sabanciuniv.edu>)
 /* --8<--------8<---- CUT HERE TO CUT-LINE BELOW ----8<--------8<-- */
  int n, i;
  double cost, tmp;
 
  cost = 1.0;
  for (n = 0; n < *parameter_dimension; ++n)
    {
      tmp = 0.0;
      for (i = 1; i < 6; ++i)
        {
          tmp += (i * cos ((i + 1) * x[n] + i));
        }
        cost *= tmp;
 
      if (cost <= -186.7309 && USER_OPTIONS->N_Accepted > 0)
        USER_OPTIONS->Immediate_Exit = 1;
 
      return (cost);
    }
 /* -->8-------->8---- CUT HERE TO CUT-LINE ABOVE ---->8-------->8-- */

(4)
In user.c, modify the call to asa() to add a loop with index ngen:
          for (ngen = 0; ngen < 100; ++ngen)
            {
              cost_value =
                asa (cost_function,
                     ...
              fprintf (ptr_out, "Generated %ld\n", USER_OPTIONS->N_Generated);
            }
and define "int ngen;" at the top of main.

========================================================================
@@Colville Examples

12 Feb 93

I was contacted by Zbigniew Michalewicz, author of a new code, GENECOP,
a  GA-based optimization package available via anonymous ftp from
unccsun.uncc.edu in directory coe/evol.  He stated that the ASA code
failed to get any reasonable fit to two Colville problems, a set of
problems developed by Colville, Floudas and Pardalos.  He demonstrated
this by offering his own results with GENECOP in which he obtained
better results that that obtained previously in the literature on one
these problems.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
On one Colville problem, after I learned that GENECOP first made
algebraic substitutions to eliminate equality constraints, this also
was performed within ASA/VFSR.  GENECOP had produced better results
than previously obtained in the literature for this example, and
ASA/VFSR obtained even better results than GENECOP.  The previously
published results gave a final cost = -47.707579; GENECOP gave cost =
-47.760765; ASA/VFSR gave cost = -47.76109.  For such systems I have
suggested that GENECOP be used as a front end to ASA.

________________________________________________________________________
LIMIT_ACCEPTANCES=1000
ACCEPTED_TO_GENERATED_RATIO=1.0E-4
 
    parameter_dimension = 7;
 
    parameter_lower_bound[0] = parameter_lower_bound[1] =
        parameter_lower_bound[2] = parameter_lower_bound[3] =
        parameter_lower_bound[4] = parameter_lower_bound[5] =
        parameter_lower_bound[6] =
        0.00005;
    parameter_upper_bound[0] = parameter_upper_bound[1] =
        parameter_upper_bound[2] = parameter_upper_bound[3] =
        parameter_upper_bound[4] = parameter_upper_bound[5] =
        parameter_upper_bound[6] =
        1.0;
 
    parameter_int_real[0] = parameter_int_real[1] =
        parameter_int_real[2] = parameter_int_real[3] =
        parameter_int_real[4] = parameter_int_real[5] =
        parameter_int_real[6] =
        REAL_TYPE;
 
    c[0] = -6.089;
    c[1] = -17.164;
    c[2] = -34.054;
    c[3] = -5.914;
    c[4] = -24.721;
    c[5] = -14.986;
    c[6] = -24.100;
    c[7] = -10.708;
    c[8] = -26.662;
    c[9] = -22.179;
 
    y[0] = x[0];
    y[1] = x[1];
    y[2] = x[2];
    y[3] = x[3];
    y[4] = x[4];
    y[5] = x[5];
 
    y[7] = x[6];
 
    y[9] = -(y[0] + 2 * y[1] + 2 * y[2] + y[5] - 2.0);
    y[6] = -(y[3] + 2 * y[4] + y[5] - 1.0);
    y[8] = -0.5 * (y[2] + y[6] + y[7] + y[9] - 1.0);
 
    if (y[6] < 0.000001 || y[8] < 0.000001 || y[9] < 0.000001) {
        *cost_flag = FALSE;
        return (0);
    }
    res = 0.0;
    sum = 0.0;
    for (i = 0; i < 10; ++i)
        sum = sum + y[i];
    for (i = 0; i < 10; ++i)
        res = res + y[i] * (c[i] + log(y[i] / sum));
 
    return (res);
________________________________________________________________________
RESULTS
 
best_generated_state=-42.69152   number_accepted=3 number_generated=3
best_generated_state=-47.15469   number_accepted=45 number_generated=106
best_generated_state=-47.5866    number_accepted=76 number_generated=200
best_generated_state=-47.71714   number_accepted=95 number_generated=300
best_generated_state=-47.73446   number_accepted=109 number_generated=398
best_generated_state=-47.73524   number_accepted=110 number_generated=401
best_generated_state=-47.74599   number_accepted=134 number_generated=510
best_generated_state=-47.7487    number_accepted=145 number_generated=607
best_generated_state=-47.75136   number_accepted=159 number_generated=718
best_generated_state=-47.75847   number_accepted=172 number_generated=812
best_generated_state=-47.75889   number_accepted=190 number_generated=919
best_generated_state=-47.75908   number_accepted=202 number_generated=1028
best_generated_state=-47.75932   number_accepted=218 number_generated=1180
best_generated_state=-47.75936   number_accepted=234 number_generated=1305
best_generated_state=-47.75999   number_accepted=246 number_generated=1407
best_generated_state=-47.76015   number_accepted=257 number_generated=1513
best_generated_state=-47.7606    number_accepted=274 number_generated=1599
best_generated_state=-47.76061   number_accepted=275 number_generated=1600
best_generated_state=-47.76084   number_accepted=294 number_generated=1758
best_generated_state=-47.76097   number_accepted=301 number_generated=1809
best_generated_state=-47.76106   number_accepted=433 number_generated=3134
best_generated_state=-47.76108   number_accepted=694 number_generated=6180
best_generated_state=-47.76109   number_accepted=956 number_generated=9645
 
best_generated_state.parameter[0] =   0.04068754
best_generated_state.parameter[1] =    0.1481389
best_generated_state.parameter[2] =     0.782566
best_generated_state.parameter[3] =  0.001349356
best_generated_state.parameter[4] =    0.4852847
best_generated_state.parameter[5] = 0.0006843851
best_generated_state.parameter[6] =   0.01820262
 
final_cost = best_generated_state.cost = -47.76109   
number_accepted at best_generated_state.cost = 957
number_generated at best_generated_state.cost = 9671

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
On the other Colville problem, using the default parameters of ASA, the
code did indeed hover in a local minimum, likely for so long that it
might take an enormous amount of human time and unrealistic computer
precision (to keep sampling at incredibly small temperatures) to find
the global minimum.  However, just a few minutes of modestly tuning a
few ASA parameters produced the global minimum.  I felt the default
options gave starting cost-temperature rates too high, so I changed
this scale.  I selected the starting values at the arbitrary points 0,
added greater precision, and also permitted the runs to go longer than
the "standard" specifications.  Using the ASA options given below, the
actual set of optimal parameters is found to machine precision.  ASA
achieves the actual global minimum (within machine precision).  I did
not spend any extra time fine-tuning options to increase ASA
efficiency.

________________________________________________________________________
SMALL_FLOAT=1.0E-35
Limit_Acceptances=50000
Temperature_Anneal_Scale=1000
Cost_Parameter_Scale_Ratio=1.0E-1
User_Initial_Parameters=TRUE
Accepted_To_Generated_Ratio=1.0E-4

parameter_dimension = 4;

for (n = 0; n < 4; ++n) {
    parameter_lower_bound[n] = -10.0;
    parameter_upper_bound[n] = 10.0;
    cost_parameters[n] = 0.0;
    parameter_int_real[n] = REAL_TYPE;
}

summ = 100.*(x[1]-(x[0]*x[0]))*(x[1]-(x[0]*x[0]))
    + (1.-x[0])*(1.-x[0])
    + 90.*(x[3]-(x[2]*x[2]))*(x[3]-(x[2]*x[2]))
    + (1.-x[2])*(1.-x[2])
    + 10.1*((x[1]-1.)*(x[1]-1.) + (x[3]-1.)*(x[3]-1.))
    + 19.8*(x[1]-1.)*(x[3]-1.);

return (summ);
________________________________________________________________________
RESULTS

best_generated_state=23.69555     number_accepted=120 number_generated=232
best_generated_state=0.2942304    number_accepted=429 number_generated=2496
best_generated_state=0.0005834838 number_accepted=733 number_generated=6229
best_generated_state=7.848137e-05 number_accepted=3185 number_generated=44762
best_generated_state=6.384848e-15 number_accepted=19968 number_generated=604224
[Here, all the best parameters were 1 to printout precision, %12.7g.]
best_generated_state=7.750362e-23 number_accepted=30510 number_generated=1767254
[About here some current_parameter_temperature's became the order of
SMALL_FLOAT.  Resetting SMALL_FLOAT would produce much more efficient
calculations at and after this point, assuming machine precision is
still meaningful.]
best_generated_state=3.736047e-24 number_accepted=33046 number_generated=2194731

GENECOP gave a final cost of 0.0000012 after 10,000 generated states.

========================================================================
@@OPTIONAL_DATA_PTR and MULTI_MIN

19 Feb 08
See ASA-README.[], version >= 26.27, for additional guidance on the
use of OPTIONAL_DATA_PTR and Asa_Data_Ptr.  The section below has been
edited in a couple of places to conform with the later discussion.
(Changes in prototypes in asa_usr.h are not included here.)

26 Aug 05

For complex recursive optimization, it is recommended that
OPTIONAL_DATA_PTR be used instead of trying to adapt SELF_OPTIMIZE.

The following is a section of a `diff -r` of ASA version 26.1 asa_usr.c,
asa_usr_asa.h and asa_usr_cst.c files with a current project, illustrating
the use of OPTIONAL_DATA_PTR (and Asa_Data_Ptr) and MULTI_MIN (and
Multi_[] OPTIONS).  These are the most important files to consider
for changes.

These excerpts from one of my projects are only meant to be illustrative.
It is unlikely they can be used directly as templates, especially since
I have not included other code.  Please be sure to read the Section
"Use of Documentation for Tuning" in the ASA-README.[] file.

    ------------8<------------ top cut -> bottom ------------->8------------
diff -r ASA/asa_usr.c SRC/asa_usr.c
9c9
< "/* $Id: asa_examples.txt,v 10.26 2011/12/18 13:31:51 ingber Exp $ */"
---
> "/* $Id: asa_examples.txt,v 10.26 2011/12/18 13:31:51 ingber Exp $ */"
39a40,42
> #if TRD
>            OPTIONAL_PTR_TYPE * OptionalPointer
> #endif                          /* TRD */
88a92,100
> #if TRD
>   int n_market;
>   int index;
>   int param_bnd_flg;
>   char infoFile[FNAME_LENGTH];
>   static int nTrdRulesCalls = 0;
>   static int nPortRiskCalls = 0;
>   static Lvl lvlSave;
> #endif /* TRD */
135a148,156
> #if TRD
> #if FREQ_ENTRY
>   static int place_flg = 0;
> 
>   ++place_flg;
>   util_errRetPlace (__FILE__, __FUNCTION__, __LINE__, (RETURN) place_flg);
> #endif /* FREQ_ENTRY */
> #endif /* TRD */
> 
154a176,181
> 
> #if TRD                         /* put here to change asa_usr_out... */
>   USER_OPTIONS->Asa_Data_Dim_Ptr = 1;
>   USER_OPTIONS->Asa_Data_Ptr = OptionalPointer;
> #endif /* TRD */
> 
166a194,210
> #if TRD
>   lvlSave = USER_OPTIONS->Asa_Data_Ptr->lvlCurrent;
>   if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == TRD_RULES) {
>     sprintf (infoFile, "%s%s%s%s", SLASHPTH_TRD, "IO", SLASH,
>              "asa_usr_out_trd_rules.txt");
>     ptr_out = fopen (infoFile, "a");
>   } else if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == PORT_RISK) {
>     sprintf (infoFile, "%s%s%s%s", SLASHPTH_TRD, "IO", SLASH,
>              "asa_usr_out_port_risk.txt");
>     ptr_out = fopen (infoFile, "a");
>   } else {
>     strcpy (user_exit_msg, "asa_main(): incorrect lvlCurrent");
>     Exit_USER (user_exit_msg);
>     return (-3);
>   }
> #else /* TRD */
> 
262a307
> #endif /* TRD */
318a364,367
> #if TRD
>   sprintf (infoFile, "%s%s%s%s", SLASHPTH_TRD, "RUN", SLASH, "asa_opt");
>   if ((ptr_options = fopen (infoFile, "r")) == NULL) {
> #else /* TRD */
319a369
> #endif /* TRD */
457d506
< 
468a518,534
> #if TRD
>   /* overrride some defaults in asa_opt */
>   if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == TRD_RULES) {
>     USER_OPTIONS->Limit_Invalid_Generated_States = 10;
>     /* USER_OPTIONS->Cost_Parameter_Scale_Ratio = 1.0; */
>     /* USER_OPTIONS->Temperature_Ratio_Scale = 0.001; */
>   } else if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == PORT_RISK) {
>     USER_OPTIONS->Limit_Invalid_Generated_States = 10;
>     /* USER_OPTIONS->Cost_Parameter_Scale_Ratio = 1.0; */
>     /* USER_OPTIONS->Temperature_Ratio_Scale = 0.001; */
>   } else {
>     strcpy (user_exit_msg, "asa_main(): incorrect lvlCurrent");
>     Exit_USER (user_exit_msg);
>     return (-3);
>   }
> #endif /* TRD */
> 
475a542,552
> #if TRD
>   if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == TRD_RULES) {
>     strcpy (USER_OPTIONS->Asa_Out_File, "../IO/asa_out_trd_rules.txt");
>   } else if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == PORT_RISK) {
>     strcpy (USER_OPTIONS->Asa_Out_File, "../IO/asa_out_port_risk.txt");
>   } else {
>     strcpy (user_exit_msg, "asa_main(): incorrect lvlCurrent");
>     Exit_USER (user_exit_msg);
>     return (-3);
>   }
> #endif /* TRD */
505a583,594
> #if TRD
>   if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == TRD_RULES) {
>     *parameter_dimension = USER_OPTIONS->Asa_Data_Ptr->nTrdParam;
>   } else if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == PORT_RISK) {
>     *parameter_dimension = USER_OPTIONS->Asa_Data_Ptr->nMarkets;
>   } else {
>     strcpy (user_exit_msg, "asa_main(): incorrect lvlCurrent");
>     Exit_USER (user_exit_msg);
>     return (-3);
>   }
> #endif /* TRD */
> 
643,653c732,804
<       cost_value =
<         asa (USER_COST_FUNCTION,
<              randflt,
<              rand_seed,
<              cost_parameters,
<              parameter_lower_bound,
<              parameter_upper_bound,
<              cost_tangents,
<              cost_curvature,
<              parameter_dimension,
<              parameter_int_real, cost_flag, exit_code, USER_OPTIONS);
---
> #if TRD
>       if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == TRD_RULES) {
>         ++nTrdRulesCalls;
>       } else if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == PORT_RISK) {
>         ++nPortRiskCalls;
>       } else {
>         ;
>       }
>       fprintf (ptr_out, "\nnTrdRulesCalls=%d, nPortRiskCalls=%d\n",
>                nTrdRulesCalls, nPortRiskCalls);
>       fflush (ptr_out);
> 
>       param_bnd_flg = 0;
>       for (index = 0; index < *parameter_dimension; ++index) {
>         if (fabs (parameter_upper_bound[index] - parameter_lower_bound[index])
>             < (double) EPS_DOUBLE) {
>           ++param_bnd_flg;
>         } else {
>           continue;
>         }
>       }
>       if (param_bnd_flg == *parameter_dimension) {
>         fprintf (ptr_out,
>                  "\n** asa_main: all parameter_upper_bound=parameter_lower_bound **\n");
>         fflush (ptr_out);
>         cost_value =
>           cost_function (cost_parameters,
>                          parameter_lower_bound,
>                          parameter_upper_bound,
>                          cost_tangents,
>                          cost_curvature,
>                          parameter_dimension,
>                          parameter_int_real, cost_flag, exit_code,
>                          USER_OPTIONS);
>         if (((cost_value) != (cost_value))
>             || (cost_value < -MAX_DOUBLE || cost_value > MAX_DOUBLE)) {
>           fprintf (ptr_out, "** asa_main: Invalid Cost Function **\n");
>           fflush (ptr_out);
>           *exit_code = 8;
>         } else {
>           *exit_code = 0;
>         }
>       } else {
>         cost_value =
>           asa (USER_COST_FUNCTION,
>                randflt,
>                rand_seed,
>                cost_parameters,
>                parameter_lower_bound,
>                parameter_upper_bound,
>                cost_tangents,
>                cost_curvature,
>                parameter_dimension,
>                parameter_int_real, cost_flag, exit_code, USER_OPTIONS);
>       }
>       USER_OPTIONS->Asa_Data_Ptr->exit_code = *exit_code;
>       if (lvlSave != USER_OPTIONS->Asa_Data_Ptr->lvlCurrent) {
>         /* reset ptr_out */
>         if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == TRD_RULES) {
>           sprintf (infoFile, "%s%s%s%s", SLASHPTH_TRD, "IO", SLASH,
>                    "asa_usr_out_trd_rules.txt");
>           ptr_out = fopen (infoFile, "a");
>         } else if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == PORT_RISK) {
>           sprintf (infoFile, "%s%s%s%s", SLASHPTH_TRD, "IO", SLASH,
>                    "asa_usr_out_port_risk.txt");
>           ptr_out = fopen (infoFile, "a");
>         } else {
>           strcpy (user_exit_msg, "asa_main(): incorrect lvlCurrent");
>           Exit_USER (user_exit_msg);
>           return (-3);
>         }
>       }
> #endif /* TRD */
785a937,989
> #if TRD
>   /* multiple sets of parameters */
>   if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == TRD_RULES) {
>     if (param_bnd_flg == *parameter_dimension) {
>       for (multi_index = 0; multi_index < USER_OPTIONS->Multi_Number;
>            multi_index++) {
>         USER_OPTIONS->Asa_Data_Ptr->Pmulti[multi_index] = cost_value;
>         for (n_param = 0; n_param < USER_OPTIONS->Asa_Data_Ptr->nTrdParam;
>              ++n_param) {
>           USER_OPTIONS->Multi_Params[multi_index][n_param] =
>             cost_parameters[n_param];
>         }
>       }
>     }
>     for (multi_index = 0; multi_index < USER_OPTIONS->Multi_Number;
>          multi_index++) {
>       USER_OPTIONS->Asa_Data_Ptr->Pmulti[multi_index] =
>         USER_OPTIONS->Multi_Cost[multi_index];
>       for (n_param = 0; n_param < *parameter_dimension; ++n_param) {
>         USER_OPTIONS->Asa_Data_Ptr->trdParamMulti[n_param][multi_index] =
>           USER_OPTIONS->Multi_Params[multi_index][n_param];
>       }
>     }
>   } else if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == PORT_RISK) {
>     /* multiple sets of contracts */
>     if (param_bnd_flg == *parameter_dimension) {
>       for (multi_index = 0; multi_index < USER_OPTIONS->Multi_Number;
>            multi_index++) {
>         USER_OPTIONS->Asa_Data_Ptr->Qmulti[multi_index] = cost_value;
>         for (n_market = 0; n_market < *parameter_dimension; n_market++) {
>           USER_OPTIONS->Multi_Params[multi_index][n_market] =
>             cost_parameters[n_market];
>         }
>       }
>     }
>     for (multi_index = 0; multi_index < USER_OPTIONS->Multi_Number;
>          multi_index++) {
>       USER_OPTIONS->Asa_Data_Ptr->Qmulti[multi_index] =
>         USER_OPTIONS->Multi_Cost[multi_index];
>       for (n_market = 0; n_market < *parameter_dimension; n_market++) {
>         USER_OPTIONS->Asa_Data_Ptr->Market[n_market].
>           contractMulti[multi_index] =
>           USER_OPTIONS->Asa_Data_Ptr->Market[n_market].contractPre +
>           (int) USER_OPTIONS->Multi_Params[multi_index][n_market];
>       }
>     }
>   } else {
>     strcpy (user_exit_msg, "asa_main(): incorrect lvlCurrent");
>     Exit_USER (user_exit_msg);
>     return (-3);
>   }
> #endif /* TRD */
> 
799a1004,1008
> #if TRD
>   if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == TRD_RULES) {
>     USER_OPTIONS->Asa_Data_Ptr = NULL;
>   }
> #else
800a1010
> #endif /* TRD */
843a1054
> 
963a1175,1203
> 
> #if TRD
>   if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == TRD_RULES) {
>     for (index = 0; index < *parameter_dimension; ++index) {
>       parameter_lower_bound[index] =
>         USER_OPTIONS->Asa_Data_Ptr->trdParamMin[index];
>       parameter_upper_bound[index] =
>         USER_OPTIONS->Asa_Data_Ptr->trdParamMax[index];
>       parameter_int_real[index] = REAL_TYPE;
>       cost_parameters[index] = USER_OPTIONS->Asa_Data_Ptr->trdParam[index];
>     }
>   } else if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == PORT_RISK) {
>     for (index = 0; index < *parameter_dimension; ++index) {
>       parameter_lower_bound[index] =
>         (double) USER_OPTIONS->Asa_Data_Ptr->Market[index].bndOrderDn;
>       parameter_upper_bound[index] =
>         (double) USER_OPTIONS->Asa_Data_Ptr->Market[index].bndOrderUp;
>       parameter_int_real[index] = INTEGER_TYPE;
>       cost_parameters[index] = (int) (0.5 *
>                                       (parameter_lower_bound[index] +
>                                        parameter_upper_bound[index]));
>     }
>   } else {
>     strcpy (user_exit_msg, "initialize_parameters(): incorrect lvlCurrent");
>     Exit_USER (user_exit_msg);
>     return (-3);
>   }
> #endif /* TRD */
> 
1080a1321,1339
> #if TRD
>   /* TRD_ASA -- tag to locate these settings */
>   if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == TRD_RULES) {
>     USER_OPTIONS->User_Quench_Cost_Scale[0] = 0.7;
>     for (index = 0; index < *parameter_dimension; ++index) {
>       USER_OPTIONS->User_Quench_Param_Scale[index] = 0.7;
>     }
>   } else if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == PORT_RISK) {
>     USER_OPTIONS->User_Quench_Cost_Scale[0] = 1;
>     for (index = 0; index < *parameter_dimension; ++index) {
>       USER_OPTIONS->User_Quench_Param_Scale[index] = 1;
>     }
>   } else {
>     strcpy (user_exit_msg, "initialize_parameters(): incorrect lvlCurrent");
>     Exit_USER (user_exit_msg);
>     return (-3);
>   }
> #endif /* TRD */
> 
1117a1377,1393
> 
> #if TRD
>   if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == TRD_RULES) {
>     USER_OPTIONS->Multi_Specify = 0;
>     for (index = 0; index < *parameter_dimension; ++index)
>       USER_OPTIONS->Coarse_Resolution[index] = 0.05;
>   } else if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == PORT_RISK) {
>     USER_OPTIONS->Multi_Specify = 0;
>     for (index = 0; index < *parameter_dimension; ++index)
>       USER_OPTIONS->Coarse_Resolution[index] = 100;     /* 100 contracts */
>   } else {
>     strcpy (user_exit_msg, "initialize_parameters(): incorrect lvlCurrent");
>     Exit_USER (user_exit_msg);
>     return (-3);
>   }
> #endif /* TRD */
> 
1137a1414,1416
> #if TRD
>   USER_OPTIONS->Queue_Size = 0; /* set Queue_Size=0 while tuning */
> #endif /* TRD */
1142a1422,1434
> 
> #if TRD
>   if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == TRD_RULES) {
>     USER_OPTIONS->Multi_Number = USER_OPTIONS->Asa_Data_Ptr->multiTrdParam;
>   } else if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == PORT_RISK) {
>     USER_OPTIONS->Multi_Number = USER_OPTIONS->Asa_Data_Ptr->multiContracts;
>   } else {
>     strcpy (user_exit_msg, "initialize_parameters(): incorrect lvlCurrent");
>     Exit_USER (user_exit_msg);
>     return (-3);
>   }
> #endif /* TRD */
> 
diff -r ASA/asa_usr_asa.h SRC/asa_usr_asa.h
14c14
<   /* $Id: asa_examples.txt,v 10.26 2011/12/18 13:31:51 ingber Exp $ */
---
>   /* $Id: asa_examples.txt,v 10.26 2011/12/18 13:31:51 ingber Exp $ */
46a47,92
> #ifndef TRD
> #define TRD TRUE
> #endif
> 
>   /* also in trd.h */
> #if TRD
> #ifndef LONGINT
> #define LONGINT 1
> #else
> #define LONGINT 0
> #endif
> #if LONGINT
> #define TRD_LONGINT long int
> #else
> #define TRD_LONGINT int
> #endif
> 
> #include "trd_struct.h"
> 
>   void util_errRetPlace (const char *File, const char *Function,
>                          const int Line, RETURN returnflg);
> 
> #define SMALL_FLOAT 1.0E-12
> #define OPTIONS_FILE TRUE
> #define OPTIONS_FILE_DATA FALSE
> #define USER_ASA_OUT TRUE
> #define USER_OUT "defined_by_lvlCurrent"
> 
> #define ASA_LIB TRUE
> #define QUENCH_PARAMETERS TRUE
> #define QUENCH_COST TRUE
> #define ASA_RESOLUTION TRUE
> #define ASA_QUEUE TRUE
> #define MULTI_MIN TRUE
> #define FITLOC FALSE
> #define ASA_PRINT_MORE TRUE     /* for tuning */
> #define ASA_PIPE_FILE FALSE
> 
> #define OPTIONAL_DATA_PTR TRUE
> #define OPTIONAL_PTR_TYPE PORTFOLIO
> #ifndef TIME_CALC
> #define TIME_CALC FALSE
> #endif
> 
> #define INCL_STDOUT FALSE
> #endif                          /* TRD */
diff -r ASA/asa_usr_cst.c SRC/asa_usr_cst.c
8c8
<  /* $Id: asa_examples.txt,v 10.26 2011/12/18 13:31:51 ingber Exp $ */
---
>  /* $Id: asa_examples.txt,v 10.26 2011/12/18 13:31:51 ingber Exp $ */
65a66,113
> #if TRD
>   int n, p;
>   double cost;
>   char usr_cst_exit_msg[160];   /* temp storage for exit messages */
> 
> #if FREQ_ENTRY
>   static int place_flg = 0;
> 
>   ++place_flg;
>   util_errRetPlace (__FILE__, __FUNCTION__, __LINE__, (RETURN) place_flg);
> #endif /* FREQ_ENTRY */
> 
>   cost = 0;
>   n = p = 0;
> 
>   if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == TRD_RULES) {
>     for (p = 0; p < USER_OPTIONS->Asa_Data_Ptr->nTrdParam; ++p) {
>       USER_OPTIONS->Asa_Data_Ptr->trdParam[p] = x[p];
>     }
>     trad_objective (USER_OPTIONS->Asa_Data_Ptr);
>     if (USER_OPTIONS->Asa_Data_Ptr->returnflg != ERR_NONE) {
>       USER_OPTIONS->Immediate_Exit = TRUE;
>     }
>     cost = USER_OPTIONS->Asa_Data_Ptr->cost_function_trad;
>   } else if (USER_OPTIONS->Asa_Data_Ptr->lvlCurrent == PORT_RISK) {
>     for (n = 0; n < USER_OPTIONS->Asa_Data_Ptr->nMarkets; ++n) {
>       /* optimize dContracts */
>       USER_OPTIONS->Asa_Data_Ptr->Market[n].contractPst =
>         USER_OPTIONS->Asa_Data_Ptr->Market[n].contractPre + (int) x[n];
>     }
>     risk_objective (USER_OPTIONS->Asa_Data_Ptr);
>     if (USER_OPTIONS->Asa_Data_Ptr->returnflg != ERR_NONE) {
>       USER_OPTIONS->Immediate_Exit = TRUE;
>     }
>     cost = USER_OPTIONS->Asa_Data_Ptr->cost_function_risk;
>   } else {
>     strcpy (usr_cst_exit_msg, "asa_usr_cst.c: incorrect lvlCurrent");
>     Exit_USER (usr_cst_exit_msg);
>     return (-3);
>   }
> 
> #if 0                           /* Immediate_Exit */
>   if (USER_OPTIONS->N_Accepted == 1)
>     USER_OPTIONS->Immediate_Exit = TRUE;
> #endif /* 0 Immediate_Exit */
> 
>   return cost;
> #endif /* TRD */
    ------------8<------------ bottom cut <- top ------------->8------------

========================================================================
________________________________________________________________________
 
Lester Ingber <ingber@ingber.com>
Copyright (c) 1993-2012 Lester Ingber.  All Rights Reserved.

$Id: asa_examples.txt,v 10.26 2011/12/18 13:31:51 ingber Exp $

#if FALSE /* ASA_SAVE */
Limit_Acceptances[10000][ASA_TEST:1000]			1000
Limit_Generated[99999]					99999
Limit_Invalid_Generated_States[1000]			1000
Accepted_To_Generated_Ratio[1.0E-6][ASA_TEST:1.0E-4]	1.0E-4

Cost_Precision[1.0E-18]					1.0E-18
Maximum_Cost_Repeat[5]					5
Number_Cost_Samples[5]					5
Temperature_Ratio_Scale[1.0E-5]				1.0E-5
Cost_Parameter_Scale_Ratio[1.0]				1.0
Temperature_Anneal_Scale[100.0]				100.0

Include_Integer_Parameters[FALSE=0]			0
User_Initial_Parameters[FALSE=0]			0
Sequential_Parameters[-1]				-1
Initial_Parameter_Temperature[1.0]			1.0

Acceptance_Frequency_Modulus[100]			100
Generated_Frequency_Modulus[10000]			10000
Reanneal_Cost[1]					1
Reanneal_Parameters[TRUE=1]				1

Delta_X[0.001]						0.001
User_Tangents[FALSE=0]					0
Curvature_0[FALSE=0]					0

___Define_below_if_OPTIONS_FILE_DATA=TRUE

number_parameters=*parameter_dimension			4

Param#:Minimum:Maximum:InitialValue:Integer[1or2]orReal[-1or-2]
0	-10000	10000	999.0			-1
1	-10000	10000	-1007.0			-1
2	-10000	10000	1001.0			-1
3	-10000	10000	-903.0			-1

___Define_below_if_QUENCH_COST_and_OPTIONS_FILE_DATA=TRUE

User_Quench_Cost_Scale[0]=1.0				1.0

___Define_below_if_QUENCH_PARAMETERS_and_QUENCH_COST_and_OPTIONS_FILE_DATA=TRUE

Param#:User_Quench_Param_Scale[.]=1.0
0	1.0
1	1.0
2	1.0
3	1.0

NOTE:  Keep all comment lines above, with no extra in-line "white" spaces.

The OPTIONS_FILE_DATA lines used by ASA_TEST are saved for reference:

number_parameters=*parameter_dimension			4

Param#:Minimum:Maximum:InitialValue:Integer[1or2]orReal[-1or-2]
0	-10000	10000	999.0			-1
1	-10000	10000	-1007.0			-1
2	-10000	10000	1001.0			-1
3	-10000	10000	-903.0			-1

/***********************************************************************
* Adaptive Simulated Annealing (ASA)
* Lester Ingber <ingber@ingber.com>
* Copyright (c) 1987-2016 Lester Ingber.  All Rights Reserved.
* ASA-LICENSE file has the license that must be included with ASA code.
***********************************************************************/

When using this file with ASA_SAVE=TRUE, C code can be added after
the last #endif statement after the  line below, to be recompiled
into the code after the asa_save file is read in.  Be sure to force a
recompile of asa.o and asa_run before restarting runs.  Also be sure you
write the names of these variables as they are used in the asa.c file,
which can differ from their counterparts in asa_usr.c file.  For example,
you might add:

parameter_maximum[2] = 500;
OPTIONS->Limit_Generated = 700;
OPTIONS->User_Quench_Param_Scale[3] = 0.8; /* assumes QUENCH_PARAMETERS=TRUE */

$Id: asa_opt,v 30.21 2016/02/02 15:49:45 ingber Exp ingber $
#endif /* ASA_SAVE */

		ADAPTIVE SIMULATED ANNEALING

/* $Id: asa_test_asa,v 30.21 2016/02/02 15:49:42 ingber Exp ingber $ */

OPTIONS_FILE = 1
OPTIONS_FILE_DATA = 1
RECUR_OPTIONS_FILE = 0
RECUR_OPTIONS_FILE_DATA = 0
COST_FILE = 1
ASA_LIB = 0
HAVE_ANSI = 1
IO_PROTOTYPES = 0
TIME_CALC = 0
TIME_STD = 0
TIME_GETRUSAGE = 1
INT_LONG = 1
INT_ALLOC = 0
SMALL_FLOAT =        1e-18
MIN_DOUBLE =        1e-18
MAX_DOUBLE =        1e+18
EPS_DOUBLE =        1e-18
CHECK_EXPONENT = 0
NO_PARAM_TEMP_TEST = 0
NO_COST_TEMP_TEST = 0
SELF_OPTIMIZE = 0
ASA_TEST = 1
ASA_TEST_POINT = 0
ASA_EXIT_ANYTIME = 0
ASA_TEMPLATE = 0
MY_TEMPLATE = 1
ASA_TEMPLATE_LIB = 0
ASA_TEMPLATE_ASA_OUT_PID = 0
ASA_TEMPLATE_MULTIPLE = 0
ASA_TEMPLATE_SELFOPT = 0
ASA_TEMPLATE_SAMPLE = 0
ASA_TEMPLATE_QUEUE = 0
ASA_TEMPLATE_PARALLEL = 0
ASA_TEMPLATE_SAVE = 0
USER_INITIAL_COST_TEMP = 0
RATIO_TEMPERATURE_SCALES = 0
USER_INITIAL_PARAMETERS_TEMPS = 0
DELTA_PARAMETERS = 0
QUENCH_PARAMETERS = 0
QUENCH_COST = 0
QUENCH_PARAMETERS_SCALE = 1
QUENCH_COST_SCALE = 1
OPTIONAL_DATA_DBL = 0
OPTIONAL_DATA_INT = 0
OPTIONAL_DATA_PTR = 0
USER_COST_SCHEDULE = 0
USER_ACCEPT_ASYMP_EXP = 0
USER_ACCEPT_THRESHOLD = 0
USER_ACCEPTANCE_TEST = 0
USER_GENERATING_FUNCTION = 0
USER_REANNEAL_COST = 0
USER_REANNEAL_PARAMETERS = 0
MAXIMUM_REANNEAL_INDEX = 50000
REANNEAL_SCALE =           10
ASA_SAMPLE = 0
ADAPTIVE_OPTIONS = 0
ASA_QUEUE = 0
ASA_RESOLUTION = 0
ASA_FUZZY = 0
ASA_FUZZY_PRINT = 0
FITLOC = 0
FITLOC_ROUND = 1
FITLOC_PRINT = 1
MULTI_MIN = 0
ASA_PARALLEL = 0
FDLIBM_POW = 0
FDLIBM_LOG = 0
FDLIBM_EXP = 0

ASA_PRINT = 1
USER_OUT = asa_usr_out
ASA_OUT = asa_out
USER_ASA_OUT = 0
USER_ASA_USR_OUT = 0
ASA_PRINT_INTERMED = 1
ASA_PRINT_MORE = 0
INCL_STDOUT = 1
G_FIELD = 12
G_PRECISION = 7
ASA_SAVE = 0
ASA_SAVE_OPT = 0
ASA_SAVE_BACKUP = 0
ASA_PIPE = 0
ASA_PIPE_FILE = 0
SYSTEM_CALL = 1

OPTIONS->Limit_Acceptances = 1000
OPTIONS->Limit_Generated = 99999
OPTIONS->Limit_Invalid_Generated_States = 1000
OPTIONS->Accepted_To_Generated_Ratio =       0.0001

OPTIONS->Cost_Precision =        1e-18
OPTIONS->Maximum_Cost_Repeat = 5
OPTIONS->Number_Cost_Samples = 5
OPTIONS->Temperature_Ratio_Scale =        1e-05
OPTIONS->Cost_Parameter_Scale_Ratio =            1
OPTIONS->Temperature_Anneal_Scale =          100
OPTIONS->Include_Integer_Parameters = 0
OPTIONS->User_Initial_Parameters = 0
OPTIONS->Sequential_Parameters = -1
OPTIONS->Initial_Parameter_Temperature =            1
OPTIONS->Acceptance_Frequency_Modulus = 100
OPTIONS->Generated_Frequency_Modulus = 10000
OPTIONS->Reanneal_Cost = 1
OPTIONS->Reanneal_Parameters = 1

OPTIONS->Delta_X =        0.001
OPTIONS->User_Tangents = 0
OPTIONS->Curvature_0 = 0
OPTIONS->Asa_Recursive_Level = 0


Initial Random Seed = 40679

*number_parameters = 4

index_v parameter_minimum parameter_maximum parameter_value parameter_type 
 0        -10000       		 10000        	 999          -1     
 1        -10000       		 10000        	 -1007        -1     
 2        -10000       		 10000        	 1001         -1     
 3        -10000       		 10000        	 -903         -1     


temperature_scale =     3.640707
temperature_scale_parameters[0] =     3.640707
*temperature_scale_cost =     3.640707



*index_cost_acceptances = 0, *current_cost_temperature = 2.312645e+10
*accepted_to_generated_ratio =            1, *number_invalid... = 0
*number_generated = 0, *number_accepted = 0
best...->cost = 9.192184e+10, last...->cost = 9.192184e+10
index_v  best...->parameter current_parameter_temp	tangent
0	   -6249.891		           1	           0
1	   -9463.506		           1	           0
2	    1691.675		           1	           0
3	    4791.876		           1	           0


best...->cost=3.655368e+08  *number_accepted=1  *number_generated=1
best...->cost=7.216186e+07  *number_accepted=2  *number_generated=2
best...->cost=1.96043e+07   *number_accepted=17  *number_generated=66
best...->cost=1.739556e+07  *number_accepted=18  *number_generated=70
best...->cost=5739862       *number_accepted=20  *number_generated=90
best...->cost=3434188       *number_accepted=27  *number_generated=139
best...->cost=3330096       *number_accepted=67  *number_generated=435
best...->cost=3081946       *number_accepted=69  *number_generated=447
best...->cost=3000401       *number_accepted=71  *number_generated=451
best...->cost=2620080       *number_accepted=72  *number_generated=456
best...->cost=2600579       *number_accepted=73  *number_generated=457
best...->cost=1276282       *number_accepted=75  *number_generated=460
best...->cost=490562.4      *number_accepted=76  *number_generated=467
best...->cost=342557.5      *number_accepted=97  *number_generated=605

*index_cost_acceptances = 0, *current_cost_temperature =     238043.4
*accepted_to_generated_ratio =    0.3076923, *number_invalid... = 0
*number_generated = 617, *number_accepted = 100
best...->cost =     342557.5, last...->cost =     489330.5
index_v  best...->parameter current_parameter_temp	tangent
0	    257.5975		1.317427e-08	    219487.6
1	   -7.210583		1.317427e-08	          -0
2	   -465.4351		1.317427e-08	    -3965767
3	    -2.80828		1.317427e-08	          -0


best...->cost=318920        *number_accepted=102  *number_generated=625
best...->cost=220552.4      *number_accepted=103  *number_generated=626
best...->cost=204836.2      *number_accepted=104  *number_generated=642
best...->cost=164974.2      *number_accepted=105  *number_generated=643
best...->cost=89474.68      *number_accepted=107  *number_generated=655
best...->cost=79407.25      *number_accepted=108  *number_generated=657
best...->cost=58531.5       *number_accepted=110  *number_generated=669
best...->cost=38314.18      *number_accepted=111  *number_generated=680
best...->cost=38116.78      *number_accepted=112  *number_generated=683
best...->cost=28012.03      *number_accepted=113  *number_generated=691
best...->cost=27993.48      *number_accepted=114  *number_generated=710
best...->cost=20817.32      *number_accepted=116  *number_generated=732
best...->cost=19103.68      *number_accepted=117  *number_generated=739
best...->cost=17011.49      *number_accepted=118  *number_generated=743
best...->cost=16978.45      *number_accepted=120  *number_generated=809
best...->cost=16051.19      *number_accepted=121  *number_generated=815
best...->cost=16033.21      *number_accepted=122  *number_generated=820
best...->cost=4006.537      *number_accepted=123  *number_generated=836
best...->cost=936.7495      *number_accepted=124  *number_generated=837
best...->cost=883.2116      *number_accepted=126  *number_generated=944
best...->cost=158.5911      *number_accepted=128  *number_generated=1021
best...->cost=94.74807      *number_accepted=129  *number_generated=1022
best...->cost=67.33532      *number_accepted=155  *number_generated=1379
best...->cost=43.84657      *number_accepted=157  *number_generated=1387
best...->cost=10.54677      *number_accepted=159  *number_generated=1410
best...->cost=9.476625      *number_accepted=160  *number_generated=1420
best...->cost=9.125625      *number_accepted=162  *number_generated=1428
best...->cost=6.744557      *number_accepted=174  *number_generated=1610
best...->cost=5.46699       *number_accepted=175  *number_generated=1612
best...->cost=5.431994      *number_accepted=176  *number_generated=1618
best...->cost=5.367428      *number_accepted=177  *number_generated=1619
best...->cost=3.910875      *number_accepted=178  *number_generated=1629

*index_cost_acceptances = 0, *current_cost_temperature =     5.036739
*accepted_to_generated_ratio =    0.1105769, *number_invalid... = 0
*number_generated = 1836, *number_accepted = 200
best...->cost =     3.910875, last...->cost =     8.313647
index_v  best...->parameter current_parameter_temp	tangent
0	   -1.244277		1.316151e-10	          -0
1	    0.230903		4.467369e-11	           0
2	 -0.02794935		4.496469e-11	          -0
3	  -0.2073798		4.467369e-11	          -0


best...->cost=2.278302      *number_accepted=209  *number_generated=1981
best...->cost=1.237445      *number_accepted=210  *number_generated=1983
best...->cost=1.235457      *number_accepted=211  *number_generated=1991
best...->cost=1.220446      *number_accepted=212  *number_generated=2013
best...->cost=0.928125      *number_accepted=213  *number_generated=2036
best...->cost=0.1507781     *number_accepted=214  *number_generated=2088
best...->cost=0.1141284     *number_accepted=216  *number_generated=2115
best...->cost=0.1139879     *number_accepted=217  *number_generated=2148
best...->cost=0.113153      *number_accepted=219  *number_generated=2170
best...->cost=0.079125      *number_accepted=220  *number_generated=2174
best...->cost=0.052125      *number_accepted=271  *number_generated=2922
best...->cost=0.037125      *number_accepted=281  *number_generated=3142
best...->cost=0.03375       *number_accepted=293  *number_generated=3259

*index_cost_acceptances = 7, *current_cost_temperature = 8.557339e-05
*accepted_to_generated_ratio =          0.1, *number_invalid... = 0
*number_generated = 3338, *number_accepted = 300
best...->cost =      0.03375, last...->cost =      0.03375
index_v  best...->parameter current_parameter_temp	tangent
0	  0.04507687		1.870781e-12	           0
1	  0.04469288		9.588269e-13	           0
2	   0.1773544		9.628105e-13	           0
3	  0.01514442		9.588269e-13	           0


best...->cost=0             *number_accepted=335  *number_generated=3680

*index_cost_acceptances = 0, *current_cost_temperature = 2.850392e-07
*accepted_to_generated_ratio =    0.1130137, *number_invalid... = 0
*number_generated = 4263, *number_accepted = 400
best...->cost =            0, last...->cost =            0
index_v  best...->parameter current_parameter_temp	tangent
0	  0.01467097		2.907767e-13	           0
1	  0.02876664		1.674497e-13	           0
2	  0.02477989		1.680285e-13	           0
3	 -0.03838191		1.674497e-13	          -0



*index_cost_acceptances = 1, *current_cost_temperature =  2.62338e-20
*accepted_to_generated_ratio =    0.1118531, *number_invalid... = 0
*number_generated = 4278, *number_accepted = 401
best...->cost =            0, last...->cost =            0
index_v  best...->parameter current_parameter_temp	tangent
0	  0.01467097		2.824166e-13	           0
1	  0.02876664		 1.62897e-13	           0
2	  0.02477989		1.634586e-13	           0
3	 -0.03838191		 1.62897e-13	          -0

curvature[0][0] =            0

curvature[1][0] =            0 	 = curvature[0][1]
curvature[1][1] =            0

curvature[2][0] =            0 	 = curvature[0][2]
curvature[2][1] =            0 	 = curvature[1][2]
curvature[2][2] =            0

curvature[3][0] =           -0 	 = curvature[0][3]
curvature[3][1] =           -0 	 = curvature[1][3]
curvature[3][2] =           -0 	 = curvature[2][3]
curvature[3][3] =            0



 C_TEMP_TOO_SMALL exit_status = 2
*current_cost_temperature too small =  2.62338e-20
 Locate_Cost = 5, calculating curvatures while exiting asa ()
final_cost = best_generated_state->cost = 0           
*number_accepted at best_generated_state->cost = 335
*number_generated at best_generated_state->cost = 3680



/* $Id: asa_test_usr,v 30.21 2016/02/02 15:49:42 ingber Exp ingber $ */

CC = gcc
	-g
	-Wall
	-ffloat-store
	-DASA_TEST=TRUE

exit code = 2
final cost value =            0
parameter	value
0		  0.01467097
1		  0.02876664
2		  0.02477989
3		 -0.03838191
/***********************************************************************
* Adaptive Simulated Annealing (ASA)
* Lester Ingber <ingber@ingber.com>
* Copyright (c) 1987-2016 Lester Ingber.  All Rights Reserved.
* ASA-LICENSE file has the license that must be included with ASA code.
***********************************************************************/

#define USER_ID "/* $Id: asa_usr.c,v 30.21 2016/02/02 15:49:43 ingber Exp ingber $ */"

#include "asa_usr.h"
#if MY_TEMPLATE                 /* MY_TEMPLATE_includes */
  /* add your own include files as required */
#endif

#if ASA_LIB
static LONG_INT *asa_rand_seed;
#endif

#if ASA_SAVE
static double random_array[SHUFFLE];
#endif

#if ASA_FUZZY
static double **FuzzyParameters;
static double *FuzzyValues, *FuzzyMinima, *auxV;
static double ValMinLoc;
#endif

#if SELF_OPTIMIZE
static LONG_INT funevals = 0;
#else

char user_exit_msg[160];        /* temp storage for exit messages */
FILE *ptr_out;

/***********************************************************************
* main
*	This is a sample calling program to optimize using ASA
***********************************************************************/
#if HAVE_ANSI

#if ASA_LIB
int
asa_main (
#if ASA_TEMPLATE_LIB
           double *main_cost_value,
           double *main_cost_parameters, int *main_exit_code
#endif                          /* ASA_TEMPLATE_LIB */
#if ASA_TEMPLATE
#if OPTIONAL_DATA_PTR
           /* insert "," if previous parameters */
           OPTIONAL_PTR_TYPE * OptionalPointer
#endif                          /* OPTIONAL_DATA_PTR */
#endif                          /* ASA_TEMPLATE */
  )
#else /* ASA_LIB */
int
main (int argc, char **argv)
#endif                          /* ASA_LIB */
#else /* HAVE_ANSI */

#if ASA_LIB
int
asa_main (
#if ASA_TEMPLATE_LIB
           main_cost_value, main_cost_parameters, main_exit_code
#endif                          /* ASA_TEMPLATE_LIB */
#if ASA_TEMPLATE
           /* insert "," if previous parameters */
           OptionalPointer
#endif                          /* ASA_TEMPLATE */
  )
#if ASA_TEMPLATE_LIB
     double *main_cost_value;
     double *main_cost_parameters;
     int *main_exit_code;
#endif /* ASA_TEMPLATE_LIB */
#if ASA_TEMPLATE
     OPTIONAL_PTR_TYPE *OptionalPointer;
#endif /* ASA_TEMPLATE */
#else /* ASA_LIB */
int
main (argc, argv)
     int argc;
     char **argv;
#endif /* ASA_LIB */

#endif /* HAVE_ANSI */
{
  int *exit_code;
  ALLOC_INT n_param;
#if ASA_LIB
#else
  int compile_cnt;
#endif
#if ASA_TEMPLATE_SAMPLE
  FILE *ptr_asa;
#endif
#if ASA_TEMPLATE_ASA_OUT_PID
  char pid_file[18];
  int pid_int;
#endif
#if MULTI_MIN
  int multi_index;
#endif

  /* pointer to array storage for asa arguments */
  double *parameter_lower_bound, *parameter_upper_bound, *cost_parameters,
    *cost_tangents, *cost_curvature;
  double cost_value;

  int initialize_parameters_value;
  static int number_asa_usr_open = 0;

  /* the number of parameters to optimize */
  ALLOC_INT *parameter_dimension;

  /* pointer to array storage for parameter type flags */
  int *parameter_int_real;

  /* valid flag for cost function */
  int *cost_flag;

  /* seed for random number generator */
  LONG_INT *rand_seed;

  USER_DEFINES *USER_OPTIONS;

#if OPTIONS_FILE
  int fscanf_ret;
  FILE *ptr_options;
  char read_option[80];
  char read_if[4], read_FALSE[6], read_comm1[3], read_ASA_SAVE[9],
    read_comm2[3];
  int read_int;
#if INT_LONG
  LONG_INT read_long;
#endif
  double read_double;
#endif /* OPTIONS_FILE */
#if MY_TEMPLATE                 /* MY_TEMPLATE_main_decl */
  /* add some declarations if required */
#endif

  fscanf_ret = 0;               /* stop compiler warning */
  if (fscanf_ret) {
    ;
  }
#if ASA_TEMPLATE_MULTIPLE
  int n_asa, n_trajectory;
  ALLOC_INT index;
#if HAVE_ANSI
  char asa_file[8] = "asa_x_y";
#else
  char asa_file[8];
#endif /* HAVE_ANSI */
#endif /* ASA_TEMPLATE_MULTIPLE */

#if ASA_TEMPLATE_MULTIPLE
#if HAVE_ANSI
#else
  asa_file[0] = asa_file[2] = 'a';
  asa_file[1] = 's';
  asa_file[3] = asa_file[5] = '_';
  asa_file[4] = 'x';
  asa_file[6] = 'y';
  asa_file[7] = '\0';
#endif /* HAVE_ANSI */
#endif /* ASA_TEMPLATE_MULTIPLE */

  if ((USER_OPTIONS =
       (USER_DEFINES *) calloc (1, sizeof (USER_DEFINES))) == NULL) {
    strcpy (user_exit_msg, "main()/asa_main(): USER_DEFINES");
    Exit_USER (user_exit_msg);
    return (-2);
  }
#if OPTIONAL_DATA_PTR
#if ASA_TEMPLATE
  /* see note at "Instead of freeing Asa_Data_Ptr" */
  /* USER_OPTIONS->Asa_Data_Dim_Ptr = 1; */
  /* USER_OPTIONS->Asa_Data_Ptr = OptionalPointer; */
  USER_OPTIONS->Asa_Data_Dim_Ptr = 256;
  if ((USER_OPTIONS->Asa_Data_Ptr =
       (OPTIONAL_PTR_TYPE *) calloc (USER_OPTIONS->Asa_Data_Dim_Ptr,
                                     sizeof (OPTIONAL_PTR_TYPE))) == NULL) {
    strcpy (user_exit_msg, "main()/asa_main(): USER_OPTIONS->Asa_Data_Ptr");
    Exit_USER (user_exit_msg);
    return (-2);
  }
#endif /* ASA_TEMPLATE */
#endif /* OPTIONAL_DATA_PTR */

#if ASA_TEMPLATE_ASA_OUT_PID
  pid_file[0] = 'a';
  pid_file[1] = 's';
  pid_file[2] = 'a';
  pid_file[3] = '_';
  pid_file[4] = 'u';
  pid_file[5] = 's';
  pid_file[6] = 'r';
  pid_file[7] = '_';
  pid_file[8] = 'o';
  pid_file[9] = 'u';
  pid_file[10] = 't';
  pid_file[11] = '_';
  pid_file[17] = '\0';

  pid_int = getpid ();
  if (pid_int < 0) {
    pid_int = -pid_int;
  }

  if (pid_int > 99999) {
    pid_file[11] = '1';
    pid_int = pid_int % 100000;
  }

  if (pid_int < 10 && pid_int > 0) {
    pid_file[12] = '0';
    pid_file[13] = '0';
    pid_file[14] = '0';
    pid_file[15] = '0';
    pid_file[16] = '0' + pid_int;
  } else if (pid_int >= 10 && pid_int < 100) {
    pid_file[12] = '0';
    pid_file[13] = '0';
    pid_file[14] = '0';
    pid_file[15] = '0' + (int) (pid_int / 10);
    pid_file[16] = '0' + (pid_int % 10);
  } else if (pid_int >= 100 && pid_int < 1000) {
    pid_file[12] = '0';
    pid_file[13] = '0';
    pid_file[14] = '0' + (int) (pid_int / 100);
    pid_file[15] = '0' + (int) ((pid_int % 100) / 10);
    pid_file[16] = '0' + ((pid_int % 100) % 10);
  } else if (pid_int >= 1000 && pid_int < 10000) {
    pid_file[12] = '0';
    pid_file[13] = '0' + (int) (pid_int / 1000);
    pid_file[14] = '0' + (int) ((pid_int % 1000) / 100);
    pid_file[15] = '0' + (int) (((pid_int % 1000) % 100) / 10);
    pid_file[16] = '0' + (((pid_int % 1000) % 100) % 10);
  } else if (pid_int >= 10000 && pid_int <= 99999) {
    pid_file[12] = '0' + (int) (pid_int / 10000);
    pid_file[13] = '0' + (int) ((pid_int % 10000) / 1000);
    pid_file[14] = '0' + (int) (((pid_int % 10000) % 1000) / 100);
    pid_file[15] = '0' + (int) (((pid_int % 10000) % 1000) % 100 / 10);
    pid_file[16] = '0' + ((((pid_int % 10000) % 1000) % 100) % 10);
  } else {
    pid_file[11] = '0';
    pid_file[12] = '0';
    pid_file[13] = '0';
    pid_file[14] = '0';
    pid_file[15] = '0';
    pid_file[16] = '0';
  }
  ptr_out = fopen (pid_file, "w");
#else /* ASA_TEMPLATE_ASA_OUT_PID */

  ++number_asa_usr_open;
  /* open the output file */
  /* set "w" to "a" to save data from multiple runs */
#if ASA_SAVE
  if (!strcmp (USER_OUT, "STDOUT")) {
#if INCL_STDOUT
    ptr_out = stdout;
#endif /* INCL_STDOUT */
  } else {
    ptr_out = fopen (USER_OUT, "a");
  }
#else /* ASA_SAVE */
  if (!strcmp (USER_OUT, "STDOUT")) {
#if INCL_STDOUT
    ptr_out = stdout;
#endif /* INCL_STDOUT */
  } else {
#if USER_ASA_USR_OUT
    ;
#else
    ptr_out = fopen (USER_OUT, "w");
#if ASA_TEMPLATE
    /* if multiple calls are to be saved */
    ptr_out = fopen (USER_OUT, "a");
#endif /* ASA_TEMPLATE */
#endif /* USER_ASA_USR_OUT */
  }
#endif /* ASA_SAVE */
#if INCL_STDOUT
  /* use this instead if you want output to stdout */
#endif /* INCL_STDOUT */
#if FALSE
#if INCL_STDOUT
  ptr_out = stdout;
#endif /* INCL_STDOUT */
#endif

#if USER_ASA_USR_OUT
  if ((USER_OPTIONS->Asa_Usr_Out_File =
       (char *) calloc (80, sizeof (char))) == NULL) {
    strcpy (user_exit_msg,
            "main()/asa_main(): USER_OPTIONS->Asa_Usr_Out_File");
    Exit_USER (user_exit_msg);
    return (-2);
  }
#if ASA_TEMPLATE
  sprintf (USER_OPTIONS->Asa_Usr_Out_File, "%s", "asa_usr_out_my");

  /* OR create memory for file asa_usr_out_my */
  /* which must be "free(asa_usr_out_my);" after use */
  strcpy (USER_OPTIONS->Asa_Usr_Out_File, asa_usr_out_my);

  ptr_out = fopen (USER_OPTIONS->Asa_Usr_Out_File, "w");
#endif /* ASA_TEMPLATE */
#endif /* USER_ASA_USR_OUT */

#endif /* ASA_TEMPLATE_ASA_OUT_PID */
  fprintf (ptr_out, "%s\n\n", USER_ID);
  if (number_asa_usr_open > 1) {
    fprintf (ptr_out, "\n\n\t\t number_asa_usr_open = %d\n",
             number_asa_usr_open);
    fflush (ptr_out);
  }
#if ASA_LIB
#else
  /* print out compile options set by user in Makefile */
  if (argc > 1) {
    fprintf (ptr_out, "CC = %s\n", argv[1]);
    for (compile_cnt = 2; compile_cnt < argc; ++compile_cnt) {
      fprintf (ptr_out, "\t%s\n", argv[compile_cnt]);
    }
    fprintf (ptr_out, "\n");
  }
#endif
#if TIME_CALC
  /* print starting time */
  print_time ("start", ptr_out);
#endif
  fflush (ptr_out);

  if ((rand_seed = (ALLOC_INT *) calloc (1, sizeof (ALLOC_INT))) == NULL) {
    strcpy (user_exit_msg, "main()/asa_main(): rand_seed");
    Exit_USER (user_exit_msg);
    free (USER_OPTIONS);
    return (-2);
  }
#if ASA_LIB
  *rand_seed = (asa_rand_seed ? *asa_rand_seed : (LONG_INT) 696969);
#else
  *rand_seed = 696969;
#endif

  /* initialize random number generator with first call */
  resettable_randflt (rand_seed, 1);

  /* Initialize the users parameters, allocating space, etc.
     Note that the default is to have asa generate the initial
     cost_parameters that satisfy the user's constraints. */

  if ((parameter_dimension =
       (ALLOC_INT *) calloc (1, sizeof (ALLOC_INT))) == NULL) {
    strcpy (user_exit_msg, "main()/asa_main(): parameter_dimension");
    Exit_USER (user_exit_msg);
    free (USER_OPTIONS);
    return (-2);
  }
  if ((exit_code = (int *) calloc (1, sizeof (int))) == NULL) {
    strcpy (user_exit_msg, "main()/asa_main(): exit_code");
    Exit_USER (user_exit_msg);
    free (parameter_dimension);
    free (USER_OPTIONS);
    return (-2);
  }
  if ((cost_flag = (int *) calloc (1, sizeof (int))) == NULL) {
    strcpy (user_exit_msg, "main()/asa_main(): cost_flag");
    Exit_USER (user_exit_msg);
    free (parameter_dimension);
    free (exit_code);
    free (USER_OPTIONS);
    return (-2);
  }
#if OPTIONS_FILE
  /* Test to see if asa_opt is in correct directory.
     This is useful for some PC and Mac compilers. */
  if ((ptr_options = fopen ("asa_opt", "r")) == NULL) {
    fprintf (ptr_out, "\n\n*** fopen asa_opt failed *** \n\n");
    fflush (ptr_out);
#if INCL_STDOUT
    printf ("\n\n*** EXIT fopen asa_opt failed *** \n\n");
#endif /* INCL_STDOUT */
    free (parameter_dimension);
    free (exit_code);
    free (cost_flag);
    free (USER_OPTIONS);
    return (-6);
  }

  fscanf_ret = fscanf (ptr_options, "%s%s%s%s%s",
                       read_if, read_FALSE, read_comm1, read_ASA_SAVE,
                       read_comm2);
  if (strcmp (read_if, "#if") || strcmp (read_FALSE, "FALSE")
      || strcmp (read_comm1, "/*") || strcmp (read_ASA_SAVE, "ASA_SAVE")
      || strcmp (read_comm2, "*/")) {
    fprintf (ptr_out, "\n\n*** not asa_opt for this version *** \n\n");
    fflush (ptr_out);
#if INCL_STDOUT
    printf ("\n\n*** EXIT not asa_opt for this version *** \n\n");
#endif /* INCL_STDOUT */
    free (parameter_dimension);
    free (exit_code);
    free (cost_flag);
    free (USER_OPTIONS);
    fclose (ptr_options);
    return (-6);
  }
#if INT_LONG
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%ld", &read_long);
  USER_OPTIONS->Limit_Acceptances = read_long;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%ld", &read_long);
  USER_OPTIONS->Limit_Generated = read_long;
#else
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Limit_Acceptances = read_int;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Limit_Generated = read_int;
#endif
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Limit_Invalid_Generated_States = read_int;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%lf", &read_double);
  USER_OPTIONS->Accepted_To_Generated_Ratio = read_double;

  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%lf", &read_double);
  USER_OPTIONS->Cost_Precision = read_double;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Maximum_Cost_Repeat = read_int;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Number_Cost_Samples = read_int;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%lf", &read_double);
  USER_OPTIONS->Temperature_Ratio_Scale = read_double;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%lf", &read_double);
  USER_OPTIONS->Cost_Parameter_Scale_Ratio = read_double;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%lf", &read_double);
  USER_OPTIONS->Temperature_Anneal_Scale = read_double;

  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Include_Integer_Parameters = read_int;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->User_Initial_Parameters = read_int;
#if INT_ALLOC
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Sequential_Parameters = read_int;
#else
#if INT_LONG
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%ld", &read_long);
  USER_OPTIONS->Sequential_Parameters = read_long;
#else
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Sequential_Parameters = read_int;
#endif
#endif
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%lf", &read_double);
  USER_OPTIONS->Initial_Parameter_Temperature = read_double;

  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Acceptance_Frequency_Modulus = read_int;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Generated_Frequency_Modulus = read_int;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Reanneal_Cost = read_int;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Reanneal_Parameters = read_int;

  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%lf", &read_double);
  USER_OPTIONS->Delta_X = read_double;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->User_Tangents = read_int;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Curvature_0 = read_int;

#else /* OPTIONS_FILE */
  /* USER_OPTIONS->Limit_Acceptances = 10000; */
  USER_OPTIONS->Limit_Acceptances = 1000;
  USER_OPTIONS->Limit_Generated = 99999;
  USER_OPTIONS->Limit_Invalid_Generated_States = 1000;
  /* USER_OPTIONS->Accepted_To_Generated_Ratio = 1.0E-6; */
  USER_OPTIONS->Accepted_To_Generated_Ratio = 1.0E-4;

  USER_OPTIONS->Cost_Precision = 1.0E-18;
  USER_OPTIONS->Maximum_Cost_Repeat = 5;
  USER_OPTIONS->Number_Cost_Samples = 5;
  USER_OPTIONS->Temperature_Ratio_Scale = 1.0E-5;
  USER_OPTIONS->Cost_Parameter_Scale_Ratio = 1.0;
  USER_OPTIONS->Temperature_Anneal_Scale = 100.0;

  USER_OPTIONS->Include_Integer_Parameters = FALSE;
  USER_OPTIONS->User_Initial_Parameters = FALSE;
  USER_OPTIONS->Sequential_Parameters = -1;
  USER_OPTIONS->Initial_Parameter_Temperature = 1.0;

  USER_OPTIONS->Acceptance_Frequency_Modulus = 100;
  USER_OPTIONS->Generated_Frequency_Modulus = 10000;
  USER_OPTIONS->Reanneal_Cost = 1;
  USER_OPTIONS->Reanneal_Parameters = TRUE;

  USER_OPTIONS->Delta_X = 0.001;
  USER_OPTIONS->User_Tangents = FALSE;
  USER_OPTIONS->Curvature_0 = FALSE;

#endif /* OPTIONS_FILE */

  /* ALLOCATE STORAGE */

#if ASA_SAVE
  /* Such data could be saved in a user_save file, but for
     convenience here everything is saved in asa_save. */
  USER_OPTIONS->Random_Array_Dim = SHUFFLE;
  USER_OPTIONS->Random_Array = random_array;
#endif /* ASA_SAVE */

#if USER_ASA_OUT
  if ((USER_OPTIONS->Asa_Out_File =
       (char *) calloc (80, sizeof (char))) == NULL) {
    strcpy (user_exit_msg, "main()/asa_main(): USER_OPTIONS->Asa_Out_File");
    Exit_USER (user_exit_msg);
    return (-2);
  }
#if ASA_TEMPLATE
  sprintf (USER_OPTIONS->Asa_Out_File, "%s", "asa_out_my");

  /* OR create memory for file asa_out_my */
  /* which must be "free(asa_out_my);" after use */
  strcpy (USER_OPTIONS->Asa_Out_File, asa_out_my);

  ptr_out = fopen (USER_OPTIONS->Asa_Out_File, "w");
#endif /* ASA_TEMPLATE */
#endif /* USER_ASA_OUT */

  /* the number of parameters for the cost function */
#if OPTIONS_FILE_DATA
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%s", read_option);

#if INT_ALLOC
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  *parameter_dimension = read_int;
#else
#if INT_LONG
  fscanf_ret = fscanf (ptr_options, "%ld", &read_long);
  *parameter_dimension = read_long;
#else
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  *parameter_dimension = read_int;
#endif
#endif

#else /* OPTIONS_FILE_DATA */
#if ASA_TEST
  *parameter_dimension = 4;
#endif /* ASA_TEST */
#endif /* OPTIONS_FILE_DATA */
#if MY_TEMPLATE                 /* MY_TEMPLATE_dim */
  /* If not using OPTIONS_FILE_DATA or data read from asa_opt,
     insert the number of parameters for the cost_function */
#endif /* MY_TEMPLATE dim */

#if ASA_TEMPLATE_SAMPLE
  *parameter_dimension = 2;
  USER_OPTIONS->Limit_Acceptances = 2000;
  USER_OPTIONS->User_Tangents = TRUE;
  USER_OPTIONS->Limit_Weights = 1.0E-7;
#endif
#if ASA_TEMPLATE_PARALLEL
  USER_OPTIONS->Gener_Block = 100;
  USER_OPTIONS->Gener_Block_Max = 512;
  USER_OPTIONS->Gener_Mov_Avr = 3;
#ifdef _OPENMP
  USER_OPTIONS->Gener_Block_Max =
    MIN (USER_OPTIONS->Gener_Block_Max, (LONG_INT) omp_get_max_threads ());
  USER_OPTIONS->Gener_Block =
    MIN (USER_OPTIONS->Gener_Block_Max, USER_OPTIONS->Gener_Block);
#endif /* _OPENMP */
#endif

  /* allocate parameter minimum space */
  if ((parameter_lower_bound =
       (double *) calloc (*parameter_dimension, sizeof (double))) == NULL) {
    strcpy (user_exit_msg, "main()/asa_main(): parameter_lower_bound");
    Exit_USER (user_exit_msg);
    free (exit_code);
    free (cost_flag);
    free (parameter_dimension);
    free (USER_OPTIONS);
    fclose (ptr_options);
    return (-2);
  }
  /* allocate parameter maximum space */
  if ((parameter_upper_bound =
       (double *) calloc (*parameter_dimension, sizeof (double))) == NULL) {
    strcpy (user_exit_msg, "main()/asa_main(): parameter_upper_bound");
    Exit_USER (user_exit_msg);
    free (exit_code);
    free (parameter_lower_bound);
    free (parameter_dimension);
    free (cost_flag);
    free (USER_OPTIONS);
    fclose (ptr_options);
    return (-2);
  }
  /* allocate parameter initial values; the parameter final values
     will be stored here later */
  if ((cost_parameters =
       (double *) calloc (*parameter_dimension, sizeof (double))) == NULL) {
    strcpy (user_exit_msg, "main()/asa_main(): cost_parameters");
    Exit_USER (user_exit_msg);
    free (exit_code);
    free (parameter_lower_bound);
    free (parameter_upper_bound);
    free (parameter_dimension);
    free (cost_parameters);
    free (cost_flag);
    free (USER_OPTIONS);
    fclose (ptr_options);
    return (-2);
  }
  /* allocate the parameter types, real or integer */
  if ((parameter_int_real =
       (int *) calloc (*parameter_dimension, sizeof (int))) == NULL) {
    strcpy (user_exit_msg, "main()/asa_main(): parameter_int_real");
    Exit_USER (user_exit_msg);
    free (exit_code);
    free (parameter_lower_bound);
    free (parameter_upper_bound);
    free (parameter_dimension);
    free (cost_parameters);
    free (cost_flag);
    free (USER_OPTIONS);
    fclose (ptr_options);
    return (-2);
  }
  /* allocate space for parameter cost_tangents -
     used for reannealing */
  if ((cost_tangents =
       (double *) calloc (*parameter_dimension, sizeof (double))) == NULL) {
    strcpy (user_exit_msg, "main()/asa_main(): cost_tangents");
    Exit_USER (user_exit_msg);
    free (exit_code);
    free (parameter_lower_bound);
    free (parameter_upper_bound);
    free (parameter_dimension);
    free (cost_parameters);
    free (cost_tangents);
    free (parameter_int_real);
    free (cost_flag);
    free (USER_OPTIONS);
    fclose (ptr_options);
    return (-2);
  }

  if ((USER_OPTIONS->Curvature_0 == FALSE)
      || (USER_OPTIONS->Curvature_0 == -1)) {
    /* allocate space for parameter cost_curvatures/covariance */
    if ((cost_curvature =
         (double *) calloc ((*parameter_dimension) *
                            (*parameter_dimension),
                            sizeof (double))) == NULL) {
      strcpy (user_exit_msg, "main()/asa_main(): cost_curvature");
      Exit_USER (user_exit_msg);
      free (exit_code);
      free (parameter_lower_bound);
      free (parameter_upper_bound);
      free (cost_parameters);
      free (cost_tangents);
      free (parameter_dimension);
      free (parameter_int_real);
      free (cost_flag);
      fclose (ptr_options);
      return (-2);
    }
  } else {
    cost_curvature = (double *) NULL;
  }

#if USER_COST_SCHEDULE
  USER_OPTIONS->Cost_Schedule = user_cost_schedule;
#endif
#if USER_ACCEPTANCE_TEST
  USER_OPTIONS->Acceptance_Test = user_acceptance_test;
#endif
#if USER_ACCEPT_ASYMP_EXP
  USER_OPTIONS->Asymp_Exp_Param = 1.0;
#endif
#if USER_GENERATING_FUNCTION
  USER_OPTIONS->Generating_Distrib = user_generating_distrib;
#endif
#if USER_REANNEAL_COST
  USER_OPTIONS->Reanneal_Cost_Function = user_reanneal_cost;
#endif
#if USER_REANNEAL_PARAMETERS
  USER_OPTIONS->Reanneal_Params_Function = user_reanneal_params;
#endif

#if MY_TEMPLATE                 /* MY_TEMPLATE_pre_initialize */
  /* last changes before entering initialize_parameters() */
#endif

  initialize_parameters_value = initialize_parameters (cost_parameters,
                                                       parameter_lower_bound,
                                                       parameter_upper_bound,
                                                       cost_tangents,
                                                       cost_curvature,
                                                       parameter_dimension,
                                                       parameter_int_real,
#if OPTIONS_FILE_DATA
                                                       ptr_options,
#endif
                                                       USER_OPTIONS);
#if OPTIONS_FILE
  fclose (ptr_options);
#endif
  if (initialize_parameters_value == -2) {
    free (exit_code);
    free (parameter_lower_bound);
    free (parameter_upper_bound);
    free (cost_parameters);
    free (cost_tangents);
    free (parameter_dimension);
    free (parameter_int_real);
    free (cost_flag);
    free (USER_OPTIONS);
    free (cost_curvature);
    return (initialize_parameters_value);
  }

  /* optimize the cost_function, returning the results in
     cost_value and cost_parameters */
#if ASA_TEMPLATE_MULTIPLE
  /* multiple asa() quenched calls + multiple asa_out files
     (To get longer quenched runs, decrease SMALL_FLOAT.) */
  for (n_asa = 1; n_asa <= *parameter_dimension; n_asa++) {
    asa_file[4] = 'A' + n_asa - 1;
    USER_OPTIONS->User_Quench_Cost_Scale[0] = (double) n_asa;
    for (index = 0; index < *parameter_dimension; ++index)
      USER_OPTIONS->User_Quench_Param_Scale[index] = (double) n_asa;
    for (n_trajectory = 0; n_trajectory < 3; ++n_trajectory) {
      asa_file[6] = 'a' + n_trajectory;
      strcpy (USER_OPTIONS->Asa_Out_File, asa_file);
#endif

#if ASA_TEMPLATE_ASA_OUT_PID
      pid_file[0] = 'a';
      pid_file[1] = 's';
      pid_file[2] = 'a';
      pid_file[3] = '_';
      pid_file[4] = 'o';
      pid_file[5] = 'u';
      pid_file[6] = 't';
      pid_file[7] = '_';

      pid_int = getpid ();
      if (pid_int < 0) {
        pid_file[7] = '0';
        pid_int = -pid_int;
      }

      strcpy (USER_OPTIONS->Asa_Out_File, pid_file);
#endif
#if ASA_FUZZY
      InitFuzzyASA (USER_OPTIONS, *parameter_dimension);
#endif /* ASA_FUZZY */
      cost_value =
        asa (USER_COST_FUNCTION,
             randflt,
             rand_seed,
             cost_parameters,
             parameter_lower_bound,
             parameter_upper_bound,
             cost_tangents,
             cost_curvature,
             parameter_dimension,
             parameter_int_real, cost_flag, exit_code, USER_OPTIONS);
      if (*exit_code == -1) {
#if INCL_STDOUT
        printf ("\n\n*** error in calloc in ASA ***\n\n");
#endif /* INCL_STDOUT */
        fprintf (ptr_out, "\n\n*** error in calloc in ASA ***\n\n");
        fflush (ptr_out);
        return (-1);
      }
#if ASA_FUZZY
      if (USER_OPTIONS->Locate_Cost == 12) {
        USER_OPTIONS->Locate_Cost = 0;
      }
      CloseFuzzyASA (USER_OPTIONS);
#endif /* ASA_FUZZY */

#if MULTI_MIN
      fprintf (ptr_out, "Multi_Specify = %d\n", USER_OPTIONS->Multi_Specify);
#if INT_LONG
      fprintf (ptr_out, "N_Accepted = %ld\n", USER_OPTIONS->N_Accepted);
#else
      fprintf (ptr_out, "N_Accepted = %d\n", USER_OPTIONS->N_Accepted);
#endif
#if ASA_RESOLUTION
      for (n_param = 0; n_param < *parameter_dimension; ++n_param) {
        fprintf (ptr_out,
#if INT_ALLOC
                 "Coarse_Resolution[%d] = %12.7g\n",
#else
#if INT_LONG
                 "Coarse_Resolution[%ld] = %12.7g\n",
#else
                 "Coarse_Resolution[%d] = %12.7g\n",
#endif
#endif
                 n_param, USER_OPTIONS->Coarse_Resolution[n_param]);
      }
#else /* ASA_RESOLUTION */
      for (n_param = 0; n_param < *parameter_dimension; ++n_param) {
        fprintf (ptr_out,
#if INT_ALLOC
                 "Multi_Grid[%d] = %12.7g\n",
#else
#if INT_LONG
                 "Multi_Grid[%ld] = %12.7g\n",
#else
                 "Multi_Grid[%d] = %12.7g\n",
#endif
#endif
                 n_param, USER_OPTIONS->Multi_Grid[n_param]);
      }
#endif /* ASA_RESOLUTION */
      fprintf (ptr_out, "\n");
      for (multi_index = 0; multi_index < USER_OPTIONS->Multi_Number;
           ++multi_index) {
        fprintf (ptr_out, "\n");
        fprintf (ptr_out, "Multi_Cost[%d] = %12.7g\n",
                 multi_index, USER_OPTIONS->Multi_Cost[multi_index]);
        for (n_param = 0; n_param < *parameter_dimension; ++n_param) {
          fprintf (ptr_out,
#if INT_ALLOC
                   "Multi_Params[%d][%d] = %12.7g\n",
#else
#if INT_LONG
                   "Multi_Params[%d][%ld] = %12.7g\n",
#else
                   "Multi_Params[%d][%d] = %12.7g\n",
#endif
#endif
                   multi_index, n_param,
                   USER_OPTIONS->Multi_Params[multi_index][n_param]);
        }
      }
      fprintf (ptr_out, "\n");
      fflush (ptr_out);

      cost_value = USER_OPTIONS->Multi_Cost[0];
      for (n_param = 0; n_param < *parameter_dimension; ++n_param) {
        cost_parameters[n_param] = USER_OPTIONS->Multi_Params[0][n_param];
      }
#endif /* MULTI_MIN */

#if FITLOC
      /* Fit_Local, Iter_Max and Penalty may be set adaptively */
      USER_OPTIONS->Penalty = 1000;
      USER_OPTIONS->Fit_Local = 1;
      USER_OPTIONS->Iter_Max = 500;
      if (USER_OPTIONS->Fit_Local >= 1) {
        cost_value = fitloc (USER_COST_FUNCTION,
                             cost_parameters,
                             parameter_lower_bound,
                             parameter_upper_bound,
                             cost_tangents,
                             cost_curvature,
                             parameter_dimension,
                             parameter_int_real,
                             cost_flag, exit_code, USER_OPTIONS, ptr_out);
      }
#endif /* FITLOC */

#if ASA_TEMPLATE                /* extra USER_COST_FUNCTION run */
      /* If your USER_COST_FUNCTION modifies your other programs, and final
       * calls to asa() and/or fitloc() make additional modifications,
       * you might run a last call to USER_COST_FUNCTION(). */
      cost_value = USER_COST_FUNCTION (cost_parameters,
                                       parameter_lower_bound,
                                       parameter_upper_bound,
                                       cost_tangents,
                                       cost_curvature,
                                       parameter_dimension,
                                       parameter_int_real,
                                       cost_flag, exit_code, USER_OPTIONS);
#endif /* extra USER_COST_FUNCTION run */

#if MY_TEMPLATE                 /* MY_TEMPLATE_post_asa */
#endif
#if ASA_TEMPLATE_LIB
      *main_cost_value = cost_value;
      for (n_param = 0; n_param < *parameter_dimension; ++n_param) {
        main_cost_parameters[n_param] = cost_parameters[n_param];
      }
      *main_exit_code = *exit_code;
#endif

      fprintf (ptr_out, "exit code = %d\n", *exit_code);
      fprintf (ptr_out, "final cost value = %12.7g\n", cost_value);
      fprintf (ptr_out, "parameter\tvalue\n");
      for (n_param = 0; n_param < *parameter_dimension; ++n_param) {
        fprintf (ptr_out,
#if INT_ALLOC
                 "%d\t\t%12.7g\n",
#else
#if INT_LONG
                 "%ld\t\t%12.7g\n",
#else
                 "%d\t\t%12.7g\n",
#endif
#endif
                 n_param, cost_parameters[n_param]);
      }

#if TIME_CALC
      /* print ending time */
      print_time ("end", ptr_out);
#endif
#if ASA_TEMPLATE_MULTIPLE
    }
  }
#endif

#if ASA_TEMPLATE_SAMPLE
  ptr_asa = fopen ("asa_out", "r");
  sample (ptr_out, ptr_asa);
#endif

  /* close all files */
  fclose (ptr_out);
#if OPTIONAL_DATA_DBL
  free (USER_OPTIONS->Asa_Data_Dbl);
#endif
#if OPTIONAL_DATA_INT
  free (USER_OPTIONS->Asa_Data_Int);
#endif
#if OPTIONAL_DATA_PTR
#if MY_TEMPLATE
  /* Instead of freeing Asa_Data_Ptr, if memory has been allocated
   * outside ASA, e.g., by the use of ASA_LIB, use the following: */
  /* USER_OPTIONS->Asa_Data_Ptr = NULL; */
#endif /* MY_TEMPLATE */
  free (USER_OPTIONS->Asa_Data_Ptr);
#endif
#if USER_ASA_OUT
#if TEMPLATE
  /* if necessary */
  free (asa_out_my);
#endif
  free (USER_OPTIONS->Asa_Out_File);
#endif
#if USER_ASA_USR_OUT
#if ASA_TEMPLATE
  /* if necessary */
  free (asa_usr_out_my);
#endif
  free (USER_OPTIONS->Asa_Usr_Out_File);
#endif
#if ASA_SAMPLE
  free (USER_OPTIONS->Bias_Generated);
#endif
#if ASA_QUEUE
#if ASA_RESOLUTION
#else
  free (USER_OPTIONS->Queue_Resolution);
#endif
#endif
#if ASA_RESOLUTION
  free (USER_OPTIONS->Coarse_Resolution);
#endif
#if USER_INITIAL_PARAMETERS_TEMPS
  free (USER_OPTIONS->User_Parameter_Temperature);
#endif
#if USER_INITIAL_COST_TEMP
  free (USER_OPTIONS->User_Cost_Temperature);
#endif
#if DELTA_PARAMETERS
  free (USER_OPTIONS->User_Delta_Parameter);
#endif
#if QUENCH_PARAMETERS
  free (USER_OPTIONS->User_Quench_Param_Scale);
#if ASA_FUZZY
  free (ASA_FUZZY_Init_User_Quench_Param_Scale);
#endif /* ASA_FUZZY */
#endif
#if QUENCH_COST
  free (USER_OPTIONS->User_Quench_Cost_Scale);
#if ASA_FUZZY
  free (ASA_FUZZY_Init_User_Quench_Cost_Scale);
#endif /* ASA_FUZZY */
#endif
#if RATIO_TEMPERATURE_SCALES
  free (USER_OPTIONS->User_Temperature_Ratio);
#endif
#if MULTI_MIN
  free (USER_OPTIONS->Multi_Cost);
  free (USER_OPTIONS->Multi_Grid);
  for (multi_index = 0; multi_index < USER_OPTIONS->Multi_Number;
       ++multi_index) {
    free (USER_OPTIONS->Multi_Params[multi_index]);
  }
  free (USER_OPTIONS->Multi_Params);
#endif /* MULTI_MIN */
  free (USER_OPTIONS);
  free (parameter_dimension);
  free (exit_code);
  free (cost_flag);
  free (parameter_lower_bound);
  free (parameter_upper_bound);
  free (cost_parameters);
  free (parameter_int_real);
  free (cost_tangents);
  free (rand_seed);
  free (cost_curvature);

  return (0);
}
#endif /* SELF_OPTIMIZE */

/***********************************************************************
* initialize_parameters - sample parameter initialization function
*	This depends on the users cost function to optimize (minimum).
*	The routine allocates storage needed for asa. The user should
*	define the number of parameters and their ranges,
*	and make sure the initial parameters are within
*	the minimum and maximum ranges. The array
*	parameter_int_real should be REAL_TYPE (-1) for real parameters,
*	and INTEGER_TYPE (1) for integer values
***********************************************************************/
#if HAVE_ANSI
int
initialize_parameters (double *cost_parameters,
                       double *parameter_lower_bound,
                       double *parameter_upper_bound,
                       double *cost_tangents,
                       double *cost_curvature,
                       ALLOC_INT * parameter_dimension,
                       int *parameter_int_real,
#if OPTIONS_FILE_DATA
                       FILE * ptr_options,
#endif
                       USER_DEFINES * USER_OPTIONS)
#else
int
initialize_parameters (cost_parameters,
                       parameter_lower_bound,
                       parameter_upper_bound,
                       cost_tangents,
                       cost_curvature,
                       parameter_dimension, parameter_int_real,
#if OPTIONS_FILE_DATA
                       ptr_options,
#endif
                       USER_OPTIONS)
     double *cost_parameters;
     double *parameter_lower_bound;
     double *parameter_upper_bound;
     double *cost_tangents;
     double *cost_curvature;
     ALLOC_INT *parameter_dimension;
     int *parameter_int_real;
#if OPTIONS_FILE_DATA
     FILE *ptr_options;
#endif
     USER_DEFINES *USER_OPTIONS;
#endif
{
  ALLOC_INT index;
#if OPTIONS_FILE_DATA
  int fscanf_ret;
  char read_option[80];
  ALLOC_INT read_index;
#endif
#if MULTI_MIN
  int multi_index;
#endif
#if MY_TEMPLATE                 /* MY_TEMPLATE_init_decl */
  /* add some declarations if required */
#endif

  index = 0;
#if OPTIONS_FILE_DATA
  fscanf_ret = 0;               /* stop compiler warning */
  if (fscanf_ret) {
    ;
  }

  fscanf_ret = fscanf (ptr_options, "%s", read_option);

  for (index = 0; index < *parameter_dimension; ++index) {
#if MY_TEMPLATE                 /* MY_TEMPLATE_read_opt */
    /* put in some code as required to alter lines read from asa_opt */
#endif
#if INT_ALLOC
    fscanf_ret = fscanf (ptr_options, "%d", &read_index);
#else
#if INT_LONG
    fscanf_ret = fscanf (ptr_options, "%ld", &read_index);
#else
    fscanf_ret = fscanf (ptr_options, "%d", &read_index);
#endif
#endif
    fscanf_ret = fscanf (ptr_options, "%lf%lf%lf%d",
                         &(parameter_lower_bound[read_index]),
                         &(parameter_upper_bound[read_index]),
                         &(cost_parameters[read_index]),
                         &(parameter_int_real[read_index]));
  }
#else /* OPTIONS_FILE_DATA */
#if ASA_TEST
  /* store the parameter ranges */
  for (index = 0; index < *parameter_dimension; ++index)
    parameter_lower_bound[index] = -10000.0;
  for (index = 0; index < *parameter_dimension; ++index)
    parameter_upper_bound[index] = 10000.0;

  /* store the initial parameter types */
  for (index = 0; index < *parameter_dimension; ++index)
    parameter_int_real[index] = REAL_TYPE;

  /* store the initial parameter values */
  for (index = 0; index < *parameter_dimension / 4.0; ++index) {
    cost_parameters[4 * (index + 1) - 4] = 999.0;
    cost_parameters[4 * (index + 1) - 3] = -1007.0;
    cost_parameters[4 * (index + 1) - 2] = 1001.0;
    cost_parameters[4 * (index + 1) - 1] = -903.0;
  }
#endif /* ASA_TEST */
#endif /* OPTIONS_FILE_DATA */
#if ASA_TEMPLATE_SAMPLE
  for (index = 0; index < *parameter_dimension; ++index)
    parameter_lower_bound[index] = 0;
  for (index = 0; index < *parameter_dimension; ++index)
    parameter_upper_bound[index] = 2.0;
  for (index = 0; index < *parameter_dimension; ++index)
    parameter_int_real[index] = REAL_TYPE;
  for (index = 0; index < *parameter_dimension; ++index)
    cost_parameters[index] = 0.5;
#endif

#if USER_INITIAL_PARAMETERS_TEMPS
  if ((USER_OPTIONS->User_Parameter_Temperature =
       (double *) calloc (*parameter_dimension, sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "initialize_parameters(): USER_OPTIONS->User_Parameter_Temperature");
    Exit_USER (user_exit_msg);
    return (-2);
  }
#if ASA_TEMPLATE
  for (index = 0; index < *parameter_dimension; ++index)
    USER_OPTIONS->User_Parameter_Temperature[index] = 1.0;
#endif
#endif /* USER_INITIAL_PARAMETERS_TEMPS */
#if USER_INITIAL_COST_TEMP
  if ((USER_OPTIONS->User_Cost_Temperature =
       (double *) calloc (1, sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "initialize_parameters(): USER_OPTIONS->User_Cost_Temperature");
    Exit_USER (user_exit_msg);
    return (-2);
  }
#if ASA_TEMPLATE
  USER_OPTIONS->User_Cost_Temperature[0] = 5.936648E+09;
#endif
#endif /* USER_INITIAL_COST_TEMP */
#if DELTA_PARAMETERS
  if ((USER_OPTIONS->User_Delta_Parameter =
       (double *) calloc (*parameter_dimension, sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "initialize_parameters(): USER_OPTIONS->User_Delta_Parameter");
    Exit_USER (user_exit_msg);
    return (-2);
  }
#if ASA_TEMPLATE
  for (index = 0; index < *parameter_dimension; ++index)
    USER_OPTIONS->User_Delta_Parameter[index] = 0.001;
#endif
#endif /* DELTA_PARAMETERS */
#if QUENCH_PARAMETERS
  if ((USER_OPTIONS->User_Quench_Param_Scale =
       (double *) calloc (*parameter_dimension, sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "initialize_parameters(): USER_OPTIONS->User_Quench_Param_Scale");
    Exit_USER (user_exit_msg);
    return (-2);
  }
#if ASA_FUZZY
  if ((ASA_FUZZY_Init_User_Quench_Param_Scale =
       (double *) calloc (*parameter_dimension, sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "initialize_parameters(): ASA_FUZZY_Init_User_Quench_Param_Scale");
    Exit_USER (user_exit_msg);
    return (-2);
  }
#endif /* ASA_FUZZY */
#if ASA_TEMPLATE
  for (index = 0; index < *parameter_dimension; ++index)
    USER_OPTIONS->User_Quench_Param_Scale[index] = 1.0;
#endif
#if ASA_TEMPLATE_MULTIPLE
  for (index = 0; index < *parameter_dimension; ++index)
    USER_OPTIONS->User_Quench_Param_Scale[index] = 1.0;
#endif
#if ASA_TEMPLATE_SAVE
  for (index = 0; index < *parameter_dimension; ++index)
    USER_OPTIONS->User_Quench_Param_Scale[index] = 1.0;
#endif
#endif /* QUENCH_PARAMETERS */
#if QUENCH_COST
  if ((USER_OPTIONS->User_Quench_Cost_Scale =
       (double *) calloc (1, sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "initialize_parameters(): USER_OPTIONS->User_Quench_Cost_Scale");
    Exit_USER (user_exit_msg);
    return (-2);
  }
#if ASA_FUZZY
  if ((ASA_FUZZY_Init_User_Quench_Cost_Scale =
       (double *) calloc (1, sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "initialize_parameters(): ASA_FUZZY_Init_User_Quench_Cost_Scale");
    Exit_USER (user_exit_msg);
    return (-2);
  }
#endif /* ASA_FUZZY */
#if ASA_TEMPLATE
  USER_OPTIONS->User_Quench_Cost_Scale[0] = 1.0;
#endif
#if ASA_TEMPLATE_MULTIPLE
  USER_OPTIONS->User_Quench_Cost_Scale[0] = 1.0;
#endif
#if ASA_TEMPLATE_SAVE
  USER_OPTIONS->User_Quench_Cost_Scale[0] = 1.0;
#endif
#endif /* QUENCH_COST */

  /* use asa_opt to read in QUENCH USER_OPTIONS */
#if OPTIONS_FILE_DATA
#if QUENCH_COST
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret =
    fscanf (ptr_options, "%lf", &(USER_OPTIONS->User_Quench_Cost_Scale[0]));

#if QUENCH_PARAMETERS
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  for (index = 0; index < *parameter_dimension; ++index) {
#if INT_ALLOC
    fscanf_ret = fscanf (ptr_options, "%d", &read_index);
#else
#if INT_LONG
    fscanf_ret = fscanf (ptr_options, "%ld", &read_index);
#else
    fscanf_ret = fscanf (ptr_options, "%d", &read_index);
#endif
#endif
    fscanf_ret = fscanf (ptr_options, "%lf",
                         &(USER_OPTIONS->User_Quench_Param_Scale
                           [read_index]));
  }
#endif /* QUENCH_PARAMETERS */
#endif /* QUENCH_COST */
#endif /* OPTIONS_FILE_DATA */
#if ASA_FUZZY
  /* can also simply set
   * ASA_FUZZY_Init_User_Quench_Cost_Scale[0] = 1.0;
   * ASA_FUZZY_Init_User_Quench_Param_Scale[index] = 1.0;
   */

  ASA_FUZZY_Init_User_Quench_Cost_Scale[0] =
    USER_OPTIONS->User_Quench_Cost_Scale[0];
  for (index = 0; index < *parameter_dimension; ++index)
    ASA_FUZZY_Init_User_Quench_Param_Scale[index] =
      USER_OPTIONS->User_Quench_Param_Scale[index];
#endif /* ASA_FUZZY */

#if RATIO_TEMPERATURE_SCALES
  if ((USER_OPTIONS->User_Temperature_Ratio =
       (double *) calloc (*parameter_dimension, sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "initialize_parameters(): USER_OPTIONS->User_Temperature_Ratio");
    Exit_USER (user_exit_msg);
    return (-2);
  }
#if ASA_TEMPLATE
  for (index = 0; index < *parameter_dimension; ++index)
    USER_OPTIONS->User_Temperature_Ratio[index] = 1.0;
#endif
#endif /* RATIO_TEMPERATURE_SCALES */
  /* Defines the limit of collection of sampled data by asa */
#if ASA_SAMPLE
  /* create memory for Bias_Generated[] */
  if ((USER_OPTIONS->Bias_Generated =
       (double *) calloc (*parameter_dimension, sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "initialize_parameters(): USER_OPTIONS->Bias_Generated");
    Exit_USER (user_exit_msg);
    return (-2);
  }
#endif

#if ASA_RESOLUTION
  if ((USER_OPTIONS->Coarse_Resolution =
       (double *) calloc (*parameter_dimension, sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "initialize_parameters(): USER_OPTIONS->Coarse_Resolution");
    Exit_USER (user_exit_msg);
    return (-2);
  }
#if ASA_TEMPLATE
  for (index = 0; index < *parameter_dimension; ++index)
    USER_OPTIONS->Coarse_Resolution[index] = 1.0;
#endif
#endif /* ASA_RESOLUTION */
#if ASA_QUEUE
#if ASA_RESOLUTION
  USER_OPTIONS->Queue_Resolution = USER_OPTIONS->Coarse_Resolution;
#else /* ASA_RESOLUTION */
  if ((USER_OPTIONS->Queue_Resolution =
       (double *) calloc (*parameter_dimension, sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "initialize_parameters(): USER_OPTIONS->Queue_Resolution");
    Exit_USER (user_exit_msg);
    return (-2);
  }
#if ASA_TEMPLATE_QUEUE
  for (index = 0; index < *parameter_dimension; ++index)
    USER_OPTIONS->Queue_Resolution[index] = 0.001;
#endif
#endif /* ASA_RESOLUTION */
#if ASA_TEMPLATE_QUEUE
  USER_OPTIONS->Queue_Size = 100;
#endif
#endif /* ASA_QUEUE */
#if MULTI_MIN
#if ASA_TEMPLATE
  USER_OPTIONS->Multi_Number = 2;
#endif
  if ((USER_OPTIONS->Multi_Cost =
       (double *) calloc (USER_OPTIONS->Multi_Number,
                          sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "initialize_parameters(): USER_OPTIONS->Multi_Cost");
    Exit_USER (user_exit_msg);
    return (-2);
  }
  if ((USER_OPTIONS->Multi_Grid =
       (double *) calloc (*parameter_dimension, sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "initialize_parameters(): USER_OPTIONS->Multi_Grid");
    Exit_USER (user_exit_msg);
    return (-2);
  }
  if ((USER_OPTIONS->Multi_Params =
       (double **) calloc (USER_OPTIONS->Multi_Number,
                           sizeof (double *))) == NULL) {
    strcpy (user_exit_msg,
            "initialize_parameters(): USER_OPTIONS->Multi_Params");
    Exit_USER (user_exit_msg);
    return (-2);
  }
  for (multi_index = 0; multi_index < USER_OPTIONS->Multi_Number;
       ++multi_index) {
    if ((USER_OPTIONS->Multi_Params[multi_index] =
         (double *) calloc (*parameter_dimension, sizeof (double))) == NULL) {
      strcpy (user_exit_msg,
              "initialize_parameters(): USER_OPTIONS->Multi_Params[multi_index]");
      Exit_USER (user_exit_msg);
      return (-2);
    }
  }
#if ASA_TEST
  for (index = 0; index < *parameter_dimension; ++index) {
    USER_OPTIONS->Multi_Grid[index] = 0.05;
  }
  USER_OPTIONS->Multi_Specify = 0;
#endif
#if ASA_TEMPLATE
  for (index = 0; index < *parameter_dimension; ++index) {
    USER_OPTIONS->Multi_Grid[index] =
      (parameter_upper_bound[index] - parameter_lower_bound[index]) / 100.0;
  }
  USER_OPTIONS->Multi_Specify = 0;
#endif /* ASA_TEMPLATE */
#endif /* MULTI_MIN */
  USER_OPTIONS->Asa_Recursive_Level = 0;

#if MY_TEMPLATE                 /* MY_TEMPLATE_params */
  /* If not using RECUR_OPTIONS_FILE_DATA or data read from asa_opt,
     store the parameter ranges
     store the parameter types
     store the initial parameter values
     other changes needed for initialization */
#endif /* MY_TEMPLATE params */

  return (0);
}

#if COST_FILE
#else
/***********************************************************************
* double cost_function
*	This is the users cost function to optimize
*	(find the minimum).
*	cost_flag is set to TRUE if the parameter set
*	does not violates any constraints
*       parameter_lower_bound and parameter_upper_bound may be
*       adaptively changed during the search.
***********************************************************************/

#if HAVE_ANSI
double
cost_function (double *x,
               double *parameter_lower_bound,
               double *parameter_upper_bound,
               double *cost_tangents,
               double *cost_curvature,
               ALLOC_INT * parameter_dimension,
               int *parameter_int_real,
               int *cost_flag, int *exit_code, USER_DEFINES * USER_OPTIONS)
#else
double
cost_function (x,
               parameter_lower_bound,
               parameter_upper_bound,
               cost_tangents,
               cost_curvature,
               parameter_dimension,
               parameter_int_real, cost_flag, exit_code, USER_OPTIONS)
     double *x;
     double *parameter_lower_bound;
     double *parameter_upper_bound;
     double *cost_tangents;
     double *cost_curvature;
     ALLOC_INT *parameter_dimension;
     int *parameter_int_real;
     int *cost_flag;
     int *exit_code;
     USER_DEFINES *USER_OPTIONS;
#endif
{

#if ASA_TEST                    /* ASA test problem */
  /* Objective function from
   * %A A. Corana
   * %A M. Marchesi
   * %A C. Martini
   * %A S. Ridella
   * %T Minimizing multimodal functions of continuous variables
   *    with the "simulated annealing" algorithm
   * %J ACM Trans. Mathl. Software
   * %V 13
   * %N 3
   * %P 262-279
   * %D 1987
   *
   * This function, when used with ASA_TEST_POINT set to TRUE, contains
   * 1.0E20 local minima.  When *parameter_dimension is equal to 4, visiting
   * each minimum for a millisecond would take about the present age of the
   * universe to visit all these minima. */

  /* defines for the test problem, which assume *parameter_dimension
     is a multiple of 4.  If this is set to a large number, you
     likely should set Curvature_0 to TRUE. */
  double q_n, d_i, s_i, t_i, z_i, c_r;
  int k_i;
#if ASA_TEST_POINT
  ALLOC_INT k_flag;
#endif
  ALLOC_INT i, j;
#if SELF_OPTIMIZE
#else
  static LONG_INT funevals = 0;
#endif
#if ASA_TEMPLATE_SAVE
  static int read_test = 0;
  FILE *ptr_read_test;
#endif

#if ADAPTIVE_OPTIONS
  adaptive_options (USER_OPTIONS);
#endif

#if MY_TEMPLATE                 /* MY_TEMPLATE_diminishing_ranges */
  /* insert code to automate changing ranges of parameters */
#endif
#if ASA_TEMPLATE                /* example of diminishing ranges */
  if (USER_OPTIONS->Locate_Cost == 12 && *(USER_OPTIONS->Best_Cost) < 1.0) {
    fprintf (ptr_out, "best_cost = %g\n", *(USER_OPTIONS->Best_Cost));
    for (i = 0; i < *parameter_dimension; ++i) {
      parameter_lower_bound[i] = USER_OPTIONS->Best_Parameters[i]
        - 0.5 * fabs (parameter_lower_bound[i]
                      - USER_OPTIONS->Best_Parameters[i]);
      parameter_upper_bound[i] = USER_OPTIONS->Best_Parameters[i]
        + 0.5 * fabs (parameter_upper_bound[i]
                      - USER_OPTIONS->Best_Parameters[i]);
      parameter_lower_bound[i] = MIN (parameter_lower_bound[i],
                                      USER_OPTIONS->Best_Parameters[i] -
                                      0.01);
      parameter_upper_bound[i] =
        MAX (parameter_upper_bound[i],
             USER_OPTIONS->Best_Parameters[i] + 0.01);
    }
  }
#endif /* ASA_TEMPLATE */

  /* a_i = parameter_upper_bound[i] */
  s_i = 0.2;
  t_i = 0.05;
  c_r = 0.15;

#if ASA_TEST_POINT
  k_flag = 0;
  for (i = 0; i < *parameter_dimension; ++i) {
    if (x[i] > 0.0) {
      k_i = (int) (x[i] / s_i + 0.5);
    } else if (x[i] < 0.0) {
      k_i = (int) (x[i] / s_i - 0.5);
    } else {
      k_i = 0;
    }
    if (k_i == 0)
      ++k_flag;
  }
#endif /* ASA_TEST_POINT */

  q_n = 0.0;
  for (i = 0; i < *parameter_dimension; ++i) {
    j = i % 4;
    switch (j) {
    case 0:
      d_i = 1.0;
      break;
    case 1:
      d_i = 1000.0;
      break;
    case 2:
      d_i = 10.0;
      break;
    default:
      d_i = 100.0;
    }
    if (x[i] > 0.0) {
      k_i = (int) (x[i] / s_i + 0.5);
    } else if (x[i] < 0.0) {
      k_i = (int) (x[i] / s_i - 0.5);
    } else {
      k_i = 0;
    }

#if ASA_TEST_POINT
    if (fabs (k_i * s_i - x[i]) < t_i && k_flag != *parameter_dimension)
#else
    if (fabs (k_i * s_i - x[i]) < t_i)
#endif
    {
      if (k_i < 0) {
        z_i = k_i * s_i + t_i;
      } else if (k_i > 0) {
        z_i = k_i * s_i - t_i;
      } else {
        z_i = 0.0;
      }
      q_n += c_r * d_i * z_i * z_i;
    } else {
      q_n += d_i * x[i] * x[i];
    }
  }
  funevals = funevals + 1;

#if ASA_TEMPLATE_SAVE
  /* cause a crash */
  if ((ptr_read_test = fopen ("asa_save", "r")) == NULL) {
    read_test = 1;
  } else {
    fclose (ptr_read_test);
  }
  /* will need a few hundred if testing ASA_PARALLEL to get an asa_save */
  if (funevals == 50 && read_test == 1) {
    fprintf (ptr_out, "\n\n*** intended crash to test ASA_SAVE *** \n\n");
    fflush (ptr_out);
#if INCL_STDOUT
    printf ("\n\n*** intended crash to test ASA_SAVE *** \n\n");
#endif /* INCL_STDOUT */
    exit (2);
  }
#endif

  *cost_flag = TRUE;

#if SELF_OPTIMIZE
#else
#if TIME_CALC
  /* print the time every PRINT_FREQUENCY evaluations */
  if ((PRINT_FREQUENCY > 0) && ((funevals % PRINT_FREQUENCY) == 0)) {
    fprintf (ptr_out, "funevals = %ld  ", funevals);
#if INCL_STDOUT
    print_time ("", ptr_out);
#endif /* INCL_STDOUT */
  }
#endif
#endif

#if ASA_TEMPLATE_SAMPLE
  USER_OPTIONS->Cost_Acceptance_Flag = TRUE;
  if (USER_OPTIONS->User_Acceptance_Flag == FALSE && *cost_flag == TRUE)
    USER_OPTIONS->Acceptance_Test (q_n,
                                   parameter_lower_bound,
                                   parameter_upper_bound,
                                   *parameter_dimension, USER_OPTIONS);
#endif /* ASA_TEMPLATE_SAMPLE */

#if ASA_FUZZY
  if (*cost_flag == TRUE
      && (USER_OPTIONS->Locate_Cost == 2 || USER_OPTIONS->Locate_Cost == 3
          || USER_OPTIONS->Locate_Cost == 4)) {
    FuzzyControl (USER_OPTIONS, x, q_n, *parameter_dimension);
  }
#endif /* ASA_FUZZY */

  return (q_n);
#endif /* ASA_TEST */
#if ASA_TEMPLATE_SAMPLE

  int n;
  double cost;

  if (*cost_flag == FALSE) {
    for (n = 0; n < *parameter_dimension; ++n)
      cost_tangents[n] = 2.0 * x[n];
  }

  cost = 0.0;
  for (n = 0; n < *parameter_dimension; ++n) {
    cost += (x[n] * x[n]);
  }

  *cost_flag = TRUE;

  USER_OPTIONS->Cost_Acceptance_Flag = TRUE;
  if (USER_OPTIONS->User_Acceptance_Flag == FALSE && *cost_flag == TRUE)
    USER_OPTIONS->Acceptance_Test (cost,
                                   parameter_lower_bound,
                                   parameter_upper_bound,
                                   *parameter_dimension, USER_OPTIONS);

  return (cost);
#endif /* ASA_TEMPLATE_SAMPLE */
#if MY_TEMPLATE                 /* MY_TEMPLATE_cost */
  /* Use the parameter values x[] and define your cost_function.
     The {} brackets around this function are already in place. */
#endif /* MY_TEMPLATE cost */
}
#endif /* COST_FILE */

  /* Here is a good random number generator */

#define MULT ((LONG_INT) 25173)
#define MOD ((LONG_INT) 65536)
#define INCR ((LONG_INT) 13849)
#define FMOD ((double) 65536.0)

#if ASA_LIB
/***********************************************************************
* LONG_INT asa_seed - returns initial random seed
***********************************************************************/

#if HAVE_ANSI
LONG_INT
asa_seed (LONG_INT seed)
#else
LONG_INT
asa_seed (seed)
     LONG_INT seed;
#endif
{
  static LONG_INT rand_seed;

  if (fabs ((double) seed) > 0) {
    asa_rand_seed = &rand_seed;
    rand_seed = seed;
  }

  return (rand_seed);
}
#endif /* ASA_LIB */

/***********************************************************************
* double myrand - returns random number between 0 and 1
*	This routine returns the random number generator between 0 and 1
***********************************************************************/

#if HAVE_ANSI
double
myrand (LONG_INT * rand_seed)
#else
double
myrand (rand_seed)
     LONG_INT *rand_seed;
#endif
  /* returns random number in {0,1} */
{
#if TRUE                        /* (change to FALSE for alternative RNG) */
  *rand_seed = (LONG_INT) ((MULT * (*rand_seed) + INCR) % MOD);
  return ((double) (*rand_seed) / FMOD);
#else
  /* See "Random Number Generators: Good Ones Are Hard To Find,"
     Park & Miller, CACM 31 (10) (October 1988) pp. 1192-1201.
     ***********************************************************
     THIS IMPLEMENTATION REQUIRES AT LEAST 32 BIT INTEGERS
     *********************************************************** */
#define _A_MULTIPLIER  16807L
#define _M_MODULUS     2147483647L      /* (2**31)-1 */
#define _Q_QUOTIENT    127773L  /* 2147483647 / 16807 */
#define _R_REMAINDER   2836L    /* 2147483647 % 16807 */
  long lo;
  long hi;
  long test;

  hi = *rand_seed / _Q_QUOTIENT;
  lo = *rand_seed % _Q_QUOTIENT;
  test = _A_MULTIPLIER * lo - _R_REMAINDER * hi;
  if (test > 0) {
    *rand_seed = test;
  } else {
    *rand_seed = test + _M_MODULUS;
  }
  return ((double) *rand_seed / _M_MODULUS);
#endif /* alternative RNG */
}

/***********************************************************************
* double randflt
***********************************************************************/

#if HAVE_ANSI
double
randflt (LONG_INT * rand_seed)
#else
double
randflt (rand_seed)
     LONG_INT *rand_seed;
#endif
{
  return (resettable_randflt (rand_seed, 0));
}

/***********************************************************************
* double resettable_randflt
***********************************************************************/

#if HAVE_ANSI
double
resettable_randflt (LONG_INT * rand_seed, int reset)
#else
double
resettable_randflt (rand_seed, reset)
     LONG_INT *rand_seed;
     int reset;
#endif
  /* shuffles random numbers in random_array[SHUFFLE] array */
{

  /* This RNG is a modified algorithm of that presented in
   * %A K. Binder
   * %A D. Stauffer
   * %T A simple introduction to Monte Carlo simulations and some
   *    specialized topics
   * %B Applications of the Monte Carlo Method in statistical physics
   * %E K. Binder
   * %I Springer-Verlag
   * %C Berlin
   * %D 1985
   * %P 1-36
   * where it is stated that such algorithms have been found to be
   * quite satisfactory in many statistical physics applications. */

  double rranf;
  unsigned kranf;
  int n;
  static int initial_flag = 0;
  LONG_INT initial_seed;
#if ASA_SAVE
  /* random_array[] local to all of asa_usr.c set at top of file */
#else
  static double random_array[SHUFFLE];  /* random variables */
#endif

  if (*rand_seed < 0)
    *rand_seed = -*rand_seed;

  if ((initial_flag == 0) || reset) {
    initial_seed = *rand_seed;

    for (n = 0; n < SHUFFLE; ++n)
      random_array[n] = myrand (&initial_seed);

    initial_flag = 1;

    for (n = 0; n < 1000; ++n)  /* warm up random generator */
      rranf = randflt (&initial_seed);

    rranf = randflt (rand_seed);

    return (rranf);
  }

  kranf = (unsigned) (myrand (rand_seed) * SHUFFLE) % SHUFFLE;
  rranf = *(random_array + kranf);
  *(random_array + kranf) = myrand (rand_seed);

  return (rranf);
}

#if USER_COST_SCHEDULE
#if HAVE_ANSI
double
user_cost_schedule (double test_temperature, const void *OPTIONS_TMP)
#else
double
user_cost_schedule (test_temperature, OPTIONS_TMP)
     double test_temperature;
     void *OPTIONS_TMP;
#endif /* HAVE_ANSI */
{
  double x;
  USER_DEFINES *USER_OPTIONS;

  USER_OPTIONS = (USER_DEFINES *) OPTIONS_TMP;

  x = 0;                        /* initialize  to prevent warning */
#if ASA_TEMPLATE_SAMPLE
  x = F_POW (test_temperature, 0.15);
#endif
#if ASA_TEMPLATE
  x = test_temperature;
#endif

  return (x);
}
#endif /* USER_COST_SCHEDULE */

#if USER_ACCEPTANCE_TEST
#if HAVE_ANSI
void
user_acceptance_test (double current_cost,
                      double *parameter_lower_bound,
                      double *parameter_upper_bound,
                      ALLOC_INT * parameter_dimension,
                      const void *OPTIONS_TMP)
#else
void
user_acceptance_test (current_cost, parameter_lower_bound,
                      parameter_upper_bound, parameter_dimension, OPTIONS_TMP)
     double current_cost;
     double *parameter_lower_bound;
     double *parameter_upper_bound;
     ALLOC_INT *parameter_dimension;
     void *OPTIONS_TMP;
#endif /* HAVE_ANSI */
{
  double uniform_test, curr_cost_temp;
  USER_DEFINES *USER_OPTIONS;

  USER_OPTIONS = (USER_DEFINES *) OPTIONS_TMP;

#if USER_ACCEPT_ASYMP_EXP
  double x, q, delta_cost;
#endif

#if ASA_TEMPLATE                /* ASA cost index */
  /* Calculate the current ASA cost index.  This could be useful
     to define a new schedule for the cost temperature, beyond
     simple changes that can be made using USER_COST_SCHEDULE. */

  int index;
  double k_temperature, quench, y;
  double xparameter_dimension;

#if QUENCH_COST
  quench = USER_OPTIONS->User_Quench_Cost_Scale[0];
#else
  quench = 1.0;
#endif /* QUENCH_COST */
  xparameter_dimension = (double) *parameter_dimension;
  for (index = 0; index < *parameter_dimension; ++index)
    if (fabs (parameter_upper_bound[index] - parameter_lower_bound[index]) <
        (double) EPS_DOUBLE)
      xparameter_dimension -= 1.0;

  y = -F_LOG (USER_OPTIONS->Cost_Temp_Curr
              / USER_OPTIONS->Cost_Temp_Init) / USER_OPTIONS->Cost_Temp_Scale;

  k_temperature = F_POW (y, xparameter_dimension / quench);
#endif /* ASA cost index */

  uniform_test = randflt (USER_OPTIONS->Random_Seed);
  curr_cost_temp = USER_OPTIONS->Cost_Temp_Curr;

#if ASA_TEMPLATE
#if USER_COST_SCHEDULE
  curr_cost_temp =
    (USER_OPTIONS->Cost_Schedule (USER_OPTIONS->Cost_Temp_Curr,
                                  USER_OPTIONS) + (double) EPS_DOUBLE);
#else
  curr_cost_temp = USER_OPTIONS->Cost_Temp_Curr;
#endif
#endif /* ASA_TEMPLATE */

  /* You must add in your own test here.  If USER_ACCEPT_ASYMP_EXP
     also is TRUE here, then you can use the default
     Asymp_Exp_Param=1 to replicate the code in asa.c. */

#if USER_ACCEPT_ASYMP_EXP
#if USER_COST_SCHEDULE
  curr_cost_temp =
    (USER_OPTIONS->Cost_Schedule (USER_OPTIONS->Cost_Temp_Curr,
                                  USER_OPTIONS) + (double) EPS_DOUBLE);
#endif

  delta_cost = (current_cost - *(USER_OPTIONS->Last_Cost))
    / (curr_cost_temp + (double) EPS_DOUBLE);

  /* The following asymptotic approximation to the exponential
   * function, "Tsallis statistics," was proposed in
   * %A T.J.P. Penna
   * %T Traveling salesman problem and Tsallis statistics
   * %J Phys. Rev. E
   * %V 50
   * %N 6
   * %P R1-R3
   * %D 1994
   * While the use of the TSP for a test case is of dubious value (since
   * there are many special algorithms for this problem), the use of this
   * function is another example of how to control the rate of annealing
   * of the acceptance criteria.  E.g., if you require a more moderate
   * acceptance test, then negative q may be helpful. */

  q = USER_OPTIONS->Asymp_Exp_Param;
  if (fabs (1.0 - q) < (double) EPS_DOUBLE)
    x = MIN (1.0, (F_EXP (-delta_cost)));       /* Boltzmann test */
  else if ((1.0 - (1.0 - q) * delta_cost) < (double) EPS_DOUBLE)
    x = MIN (1.0, (F_EXP (-delta_cost)));       /* Boltzmann test */
  else
    x = MIN (1.0, F_POW ((1.0 - (1.0 - q) * delta_cost), (1.0 / (1.0 - q))));

  USER_OPTIONS->Prob_Bias = x;
  if (x >= uniform_test)
    USER_OPTIONS->User_Acceptance_Flag = TRUE;
  else
    USER_OPTIONS->User_Acceptance_Flag = FALSE;

#endif /* USER_ACCEPT_ASYMP_EXP */
}
#endif /* USER_ACCEPTANCE_TEST */

#if USER_GENERATING_FUNCTION
#if HAVE_ANSI
double
user_generating_distrib (LONG_INT * seed,
                         ALLOC_INT * parameter_dimension,
                         ALLOC_INT index_v,
                         double temperature_v,
                         double init_param_temp_v,
                         double temp_scale_params_v,
                         double parameter_v,
                         double parameter_range_v,
                         double *last_saved_parameter,
                         const void *OPTIONS_TMP)
#else
double
user_generating_distrib (seed,
                         parameter_dimension,
                         index_v,
                         temperature_v,
                         init_param_temp_v,
                         temp_scale_params_v,
                         parameter_v,
                         parameter_range_v, last_saved_parameter, OPTIONS_TMP)
     LONG_INT *seed;
     ALLOC_INT *parameter_dimension;
     ALLOC_INT index_v;
     double temperature_v;
     double init_param_temp_v;
     double temp_scale_params_v;
     double parameter_v;
     double parameter_range_v;
     double *last_saved_parameter;
     void *OPTIONS_TMP;
#endif
{
  double x;
  USER_DEFINES *USER_OPTIONS;

  USER_OPTIONS = (USER_DEFINES *) OPTIONS_TMP;

  x = 0;                        /* initialize to prevent warning */
#if ASA_TEMPLATE
  double y, z;

  /* This is the ASA distribution.  A slower temperature schedule can be
     obtained here, e.g., temperature_v = pow(temperature_v, 0.5); */

  x = randflt (seed);
  y = x < 0.5 ? -1.0 : 1.0;
  z = y * temperature_v * (F_POW ((1.0 + 1.0 / temperature_v),
                                  fabs (2.0 * x - 1.0)) - 1.0);

  x = parameter_v + z * parameter_range_v;

#endif /* ASA_TEMPLATE */
  return (x);                   /* example return */
}
#endif /* USER_GENERATING_FUNCTION */

#if USER_REANNEAL_COST
#if HAVE_ANSI
int
user_reanneal_cost (double *cost_best,
                    double *cost_last,
                    double *initial_cost_temperature,
                    double *current_cost_temperature, const void *OPTIONS_TMP)
#else
int
user_reanneal_cost (cost_best,
                    cost_last,
                    initial_cost_temperature,
                    current_cost_temperature, OPTIONS_TMP)
     double *cost_best;
     double *cost_last;
     double *initial_cost_temperature;
     double *current_cost_temperature;
     void *OPTIONS_TMP;
#endif /* HAVE_ANSI */
{
  int cost_test;
  USER_DEFINES *USER_OPTIONS;

  USER_OPTIONS = (USER_DEFINES *) OPTIONS_TMP;

  cost_test = 0;                /* initialize to prevent warning */
#if ASA_TEMPLATE
  double tmp_dbl;

  static int first_time = 1;
  static double save_last[3];
  double average_cost_last;

  if (first_time == 1) {
    first_time = 0;
    save_last[0] = save_last[1] = save_last[2] = *cost_last;
  }

  save_last[2] = save_last[1];
  save_last[1] = save_last[0];
  save_last[0] = *cost_last;
  average_cost_last =
    fabs ((save_last[0] + save_last[1] + save_last[2]) / 3.0);

  tmp_dbl = MAX (fabs (*cost_best), average_cost_last);
  tmp_dbl = MAX ((double) EPS_DOUBLE, tmp_dbl);
  *initial_cost_temperature = MIN (*initial_cost_temperature, tmp_dbl);

  /* This test can be useful if your cost function goes from a positive
     to a negative value, and you do not want to get get stuck in a local
     minima around zero due to the default in reanneal().  Pick any
     number instead of 0.0001 */
  tmp_dbl = MIN (fabs (*cost_last), fabs (*cost_best));
  if (tmp_dbl < 0.0001)
    cost_test = FALSE;
  else
    cost_test = TRUE;

  /* Alternative ASA_TEMPLATE */
  tmp_dbl = MAX (fabs (*cost_last), fabs (*cost_best));
  tmp_dbl = MAX ((double) EPS_DOUBLE, tmp_dbl);
  *initial_cost_temperature = MIN (*initial_cost_temperature, tmp_dbl);

  *current_cost_temperature =
    MAX (fabs (*cost_last - *cost_best), *current_cost_temperature);
  *current_cost_temperature =
    MAX ((double) EPS_DOUBLE, *current_cost_temperature);
  *current_cost_temperature =
    MIN (*current_cost_temperature, *initial_cost_temperature);

  cost_test = TRUE;
#endif /* ASA_TEMPLATE */

  return (cost_test);           /* example return */
}
#endif /* USER_REANNEAL_COST */

#if USER_REANNEAL_PARAMETERS
#if HAVE_ANSI
double
user_reanneal_params (double current_temp,
                      double tangent,
                      double max_tangent, const void *OPTIONS_TMP)
#else
double
user_reanneal_params (current_temp, tangent, max_tangent, OPTIONS_TMP)
     double current_temp;
     double tangent;
     double max_tangent;
     void *OPTIONS_TMP;
#endif /* HAVE_ANSI */
{
  double x;
  USER_DEFINES *USER_OPTIONS;

  USER_OPTIONS = (USER_DEFINES *) OPTIONS_TMP;

  x = 0;                        /* initialize to prevent warning */
#if ASA_TEMPLATE

  x = current_temp * (max_tangent / tangent);

#endif
  return (x);                   /* example return */
}
#endif /* USER_REANNEAL_PARAMETERS */

#if SELF_OPTIMIZE

/***********************************************************************
* main
*	This is a sample calling program to self-optimize ASA
***********************************************************************/
#if HAVE_ANSI

#if ASA_LIB
int
asa_main (
#if ASA_TEMPLATE_LIB
           double *main_recur_cost_value,
           double *main_recur_cost_parameters, int *main_recur_exit_code
#endif
  )
#else /* ASA_LIB */
int
main (int argc, char **argv)
#endif                          /* ASA_LIB */
#else /* HAVE_ANSI */

#if ASA_LIB
int
asa_main (
#if ASA_TEMPLATE_LIB
           main_recur_cost_value,
           main_recur_cost_parameters, main_recur_exit_code
#endif
  )
#if ASA_TEMPLATE_LIB
     double *main_recur_cost_value;
     double *main_recur_cost_parameters;
     int *main_recur_exit_code;
#endif

#else /* ASA_LIB */
int
main (argc, argv)
     int argc;
     char **argv;
#endif /* ASA_LIB */

#endif /* HAVE_ANSI */
{
  /* seed for random number generator */
  LONG_INT *recur_rand_seed;
  char user_exit_msg[160];
  FILE *ptr_out;

#if RECUR_OPTIONS_FILE
  int fscanf_ret;
  FILE *recur_ptr_options;
  char read_option[80];
  char read_if[4], read_FALSE[6], read_comm1[3], read_ASA_SAVE[9],
    read_comm2[3];
  int read_int;
#if INT_LONG
  LONG_INT read_long;
#endif
  double read_double;
#endif /* RECUR_OPTIONS_FILE */

  int *recur_exit_code;
#if ASA_LIB
#else
  int compile_cnt;
#endif
#if MULTI_MIN
  int multi_index;
  ALLOC_INT n_param;
#endif

  double *recur_parameter_lower_bound, *recur_parameter_upper_bound;
  double *recur_cost_parameters, *recur_cost_tangents, *recur_cost_curvature;
  double recur_cost_value;

  ALLOC_INT *recur_parameter_dimension;
  int *recur_parameter_int_real;
  int *recur_cost_flag;
  int recur_initialize_params_value;
  ALLOC_INT recur_v;
#if MY_TEMPLATE                 /* MY_TEMPLATE_recur_main_decl */
  /* add some declarations if required */
#endif

  USER_DEFINES *RECUR_USER_OPTIONS;

  if ((recur_parameter_dimension =
       (ALLOC_INT *) calloc (1, sizeof (ALLOC_INT))) == NULL) {
    strcpy (user_exit_msg, "main()/asa_main(): recur_parameter_dimension");
    Exit_USER (user_exit_msg);
    return (-2);
  }
  if ((recur_exit_code = (int *) calloc (1, sizeof (int))) == NULL) {
    strcpy (user_exit_msg, "main()/asa_main(): recur_exit_code");
    Exit_USER (user_exit_msg);
    free (recur_parameter_dimension);
    return (-2);
  }
  if ((recur_cost_flag = (int *) calloc (1, sizeof (int))) == NULL) {
    strcpy (user_exit_msg, "main()/asa_main(): recur_cost_flag");
    Exit_USER (user_exit_msg);
    free (recur_exit_code);
    free (recur_parameter_dimension);
    return (-2);
  }

  if ((RECUR_USER_OPTIONS =
       (USER_DEFINES *) calloc (1, sizeof (USER_DEFINES))) == NULL) {
    strcpy (user_exit_msg, "main()/asa_main(): RECUR_USER_OPTIONS");
    Exit_USER (user_exit_msg);
    free (recur_cost_flag);
    free (recur_exit_code);
    free (recur_parameter_dimension);
    return (-2);
  }
#if RECUR_OPTIONS_FILE
  recur_ptr_options = fopen ("asa_opt_recur", "r");

  fscanf_ret = fscanf (recur_ptr_options, "%s%s%s%s%s",
                       read_if, read_FALSE, read_comm1, read_ASA_SAVE,
                       read_comm2);
  if (strcmp (read_if, "#if") || strcmp (read_FALSE, "FALSE")
      || strcmp (read_comm1, "/*") || strcmp (read_ASA_SAVE, "ASA_SAVE")
      || strcmp (read_comm2, "*/")) {
#if INCL_STDOUT
    printf ("\n\n*** EXIT not asa_opt_recur for this version *** \n\n");
#endif /* INCL_STDOUT */
    free (RECUR_USER_OPTIONS);
    free (recur_cost_flag);
    free (recur_exit_code);
    free (recur_parameter_dimension);
#if RECUR_OPTIONS_FILE
    fclose (recur_ptr_options);
#endif
    return (-6);
  }
#if INT_LONG
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%ld", &read_long);
  RECUR_USER_OPTIONS->Limit_Acceptances = read_long;
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%ld", &read_long);
  RECUR_USER_OPTIONS->Limit_Generated = read_long;
#else
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%d", &read_int);
  RECUR_USER_OPTIONS->Limit_Acceptances = read_int;
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%d", &read_int);
  RECUR_USER_OPTIONS->Limit_Generated = read_int;
#endif
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%d", &read_int);
  RECUR_USER_OPTIONS->Limit_Invalid_Generated_States = read_int;
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%lf", &read_double);
  RECUR_USER_OPTIONS->Accepted_To_Generated_Ratio = read_double;

  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%lf", &read_double);
  RECUR_USER_OPTIONS->Cost_Precision = read_double;
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%d", &read_int);
  RECUR_USER_OPTIONS->Maximum_Cost_Repeat = read_int;
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%d", &read_int);
  RECUR_USER_OPTIONS->Number_Cost_Samples = read_int;
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%lf", &read_double);
  RECUR_USER_OPTIONS->Temperature_Ratio_Scale = read_double;
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%lf", &read_double);
  RECUR_USER_OPTIONS->Cost_Parameter_Scale_Ratio = read_double;
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%lf", &read_double);
  RECUR_USER_OPTIONS->Temperature_Anneal_Scale = read_double;

  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%d", &read_int);
  RECUR_USER_OPTIONS->Include_Integer_Parameters = read_int;
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%d", &read_int);
  RECUR_USER_OPTIONS->User_Initial_Parameters = read_int;
#if INT_ALLOC
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%d", &read_int);
  RECUR_USER_OPTIONS->Sequential_Parameters = read_int;
#else
#if INT_LONG
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%ld", &read_long);
  RECUR_USER_OPTIONS->Sequential_Parameters = read_long;
#else
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%d", &read_int);
  RECUR_USER_OPTIONS->Sequential_Parameters = read_int;
#endif
#endif
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%lf", &read_double);
  RECUR_USER_OPTIONS->Initial_Parameter_Temperature = read_double;

  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%d", &read_int);
  RECUR_USER_OPTIONS->Acceptance_Frequency_Modulus = read_int;
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%d", &read_int);
  RECUR_USER_OPTIONS->Generated_Frequency_Modulus = read_int;
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%d", &read_int);
  RECUR_USER_OPTIONS->Reanneal_Cost = read_int;
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%d", &read_int);
  RECUR_USER_OPTIONS->Reanneal_Parameters = read_int;

  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%lf", &read_double);
  RECUR_USER_OPTIONS->Delta_X = read_double;
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%d", &read_int);
  RECUR_USER_OPTIONS->User_Tangents = read_int;
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%d", &read_int);
  RECUR_USER_OPTIONS->Curvature_0 = read_int;

#else /* RECUR_OPTIONS_FILE */
  RECUR_USER_OPTIONS->Limit_Acceptances = 100;
  RECUR_USER_OPTIONS->Limit_Generated = 1000;
  RECUR_USER_OPTIONS->Limit_Invalid_Generated_States = 1000;
  RECUR_USER_OPTIONS->Accepted_To_Generated_Ratio = 1.0E-4;

  RECUR_USER_OPTIONS->Cost_Precision = 1.0E-18;
  RECUR_USER_OPTIONS->Maximum_Cost_Repeat = 2;
  RECUR_USER_OPTIONS->Number_Cost_Samples = 2;
  RECUR_USER_OPTIONS->Temperature_Ratio_Scale = 1.0E-5;
  RECUR_USER_OPTIONS->Cost_Parameter_Scale_Ratio = 1.0;
  RECUR_USER_OPTIONS->Temperature_Anneal_Scale = 100.0;

  RECUR_USER_OPTIONS->Include_Integer_Parameters = FALSE;
  RECUR_USER_OPTIONS->User_Initial_Parameters = TRUE;
  RECUR_USER_OPTIONS->Sequential_Parameters = -1;
  RECUR_USER_OPTIONS->Initial_Parameter_Temperature = 1.0;

  RECUR_USER_OPTIONS->Acceptance_Frequency_Modulus = 15;
  RECUR_USER_OPTIONS->Generated_Frequency_Modulus = 10000;
  RECUR_USER_OPTIONS->Reanneal_Cost = FALSE;
  RECUR_USER_OPTIONS->Reanneal_Parameters = FALSE;

  RECUR_USER_OPTIONS->Delta_X = 1.0E-6;
  RECUR_USER_OPTIONS->User_Tangents = FALSE;
  RECUR_USER_OPTIONS->Curvature_0 = TRUE;

#endif /* RECUR_OPTIONS_FILE */

  /* the number of parameters for the recur_cost_function */
#if RECUR_OPTIONS_FILE_DATA
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);

#if INT_ALLOC
  fscanf_ret = fscanf (recur_ptr_options, "%d", &read_int);
  *recur_parameter_dimension = read_int;
#else
#if INT_LONG
  fscanf_ret = fscanf (recur_ptr_options, "%ld", &read_long);
  *recur_parameter_dimension = read_long;
#else
  fscanf_ret = fscanf (recur_ptr_options, "%d", &read_int);
  *recur_parameter_dimension = read_int;
#endif
#endif

#else /* RECUR_OPTIONS_FILE_DATA */
#if ASA_TEMPLATE_SELFOPT
  *recur_parameter_dimension = 2;
#endif
#if MY_TEMPLATE                 /* MY_TEMPLATE_recur_dim */
  /* If not using RECUR_OPTIONS_FILE_DATA or data read from recur_asa_opt,
     insert the number of parameters for the recur_cost_function */
#endif /* MY_TEMPLATE recur_dim */
#endif /* RECUR_OPTIONS_FILE_DATA */
  if ((recur_parameter_lower_bound =
       (double *) calloc (*recur_parameter_dimension,
                          sizeof (double))) == NULL) {
    strcpy (user_exit_msg, "main()/asa_main(): recur_parameter_lower_bound");
    Exit_USER (user_exit_msg);
    free (recur_cost_flag);
    free (recur_exit_code);
    free (recur_parameter_dimension);
    free (RECUR_USER_OPTIONS);
#if RECUR_OPTIONS_FILE
    fclose (recur_ptr_options);
#endif
    return (-2);
  }
  if ((recur_parameter_upper_bound =
       (double *) calloc (*recur_parameter_dimension,
                          sizeof (double))) == NULL) {
    strcpy (user_exit_msg, "main()/asa_main(): recur_parameter_upper_bound");
    Exit_USER (user_exit_msg);
    free (recur_cost_flag);
    free (recur_exit_code);
    free (recur_parameter_dimension);
    free (RECUR_USER_OPTIONS);
    free (recur_parameter_lower_bound);
#if RECUR_OPTIONS_FILE
    fclose (recur_ptr_options);
#endif
    return (-2);
  }

  if ((recur_cost_parameters =
       (double *) calloc (*recur_parameter_dimension,
                          sizeof (double))) == NULL) {
    strcpy (user_exit_msg, "main()/asa_main(): recur_cost_parameters");
    Exit_USER (user_exit_msg);
    free (recur_cost_flag);
    free (recur_exit_code);
    free (recur_parameter_dimension);
    free (RECUR_USER_OPTIONS);
    free (recur_parameter_lower_bound);
    free (recur_parameter_upper_bound);
#if RECUR_OPTIONS_FILE
    fclose (recur_ptr_options);
#endif
    return (-2);
  }

  if ((recur_parameter_int_real =
       (int *) calloc (*recur_parameter_dimension, sizeof (int))) == NULL) {
    strcpy (user_exit_msg, "main()/asa_main(): recur_parameter_int_real");
    Exit_USER (user_exit_msg);
    free (recur_cost_flag);
    free (recur_exit_code);
    free (recur_parameter_dimension);
    free (RECUR_USER_OPTIONS);
    free (recur_parameter_lower_bound);
    free (recur_parameter_upper_bound);
    free (recur_cost_parameters);
#if RECUR_OPTIONS_FILE
    fclose (recur_ptr_options);
#endif
    return (-2);
  }

  if ((recur_cost_tangents =
       (double *) calloc (*recur_parameter_dimension,
                          sizeof (double))) == NULL) {
    strcpy (user_exit_msg, "main()/asa_main(): recur_cost_tangents");
    Exit_USER (user_exit_msg);
    free (recur_cost_flag);
    free (recur_exit_code);
    free (recur_parameter_dimension);
    free (RECUR_USER_OPTIONS);
    free (recur_parameter_lower_bound);
    free (recur_parameter_upper_bound);
    free (recur_cost_parameters);
    free (recur_parameter_int_real);
#if RECUR_OPTIONS_FILE
    fclose (recur_ptr_options);
#endif
    return (-2);
  }

  if (RECUR_USER_OPTIONS->Curvature_0 == FALSE
      || RECUR_USER_OPTIONS->Curvature_0 == -1) {

    if ((recur_cost_curvature =
         (double *) calloc ((*recur_parameter_dimension)
                            * (*recur_parameter_dimension),
                            sizeof (double))) == NULL) {
      strcpy (user_exit_msg, "main()/asa_main(): recur_cost_curvature");
      Exit_USER (user_exit_msg);
      free (recur_cost_flag);
      free (recur_exit_code);
      free (recur_parameter_dimension);
      free (RECUR_USER_OPTIONS);
      free (recur_parameter_lower_bound);
      free (recur_parameter_upper_bound);
      free (recur_cost_parameters);
      free (recur_parameter_int_real);
      free (recur_cost_tangents);
#if RECUR_OPTIONS_FILE
      fclose (recur_ptr_options);
#endif
      return (-2);
    }
  } else {
    recur_cost_curvature = (double *) NULL;
  }

#if ASA_TEMPLATE_SELFOPT
  /* Set memory to that required for use. */
  RECUR_USER_OPTIONS->Asa_Data_Dim_Dbl = 1;
  if ((RECUR_USER_OPTIONS->Asa_Data_Dbl =
       (double *) calloc (RECUR_USER_OPTIONS->Asa_Data_Dim_Dbl,
                          sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "main()/asa_main(): RECUR_USER_OPTIONS->Asa_Data_Dbl");
    Exit_USER (user_exit_msg);
    free (recur_cost_flag);
    free (recur_exit_code);
    free (recur_parameter_dimension);
    free (RECUR_USER_OPTIONS);
    free (recur_parameter_lower_bound);
    free (recur_parameter_upper_bound);
    free (recur_cost_parameters);
    free (recur_parameter_int_real);
    free (recur_cost_tangents);
    free (recur_cost_curvature);
#if RECUR_OPTIONS_FILE
    fclose (recur_ptr_options);
#endif
    return (-2);
  }
  /* Use Asa_Data[0] as flag, e.g., if used with SELF_OPTIMIZE. */
  RECUR_USER_OPTIONS->Asa_Data_Dbl[0] = 0;
#endif /* ASA_TEMPLATE_SELFOPT */

#if OPTIONAL_DATA_PTR
#if ASA_TEMPLATE
  /* see note at "Instead of freeing Asa_Data_Ptr" */
  USER_OPTIONS->Asa_Data_Ptr = OptionalPointer;
  RECUR_USER_OPTIONS->Asa_Data_Dim_Ptr = 1;
  if ((RECUR_USER_OPTIONS->Asa_Data_Ptr =
       (OPTIONAL_PTR_TYPE *) calloc (RECUR_USER_OPTIONS->Asa_Data_Dim_Ptr,
                                     sizeof (OPTIONAL_PTR_TYPE))) == NULL) {
    strcpy (user_exit_msg,
            "main()/asa_main(): RECUR_USER_OPTIONS->Asa_Data_Ptr");
    Exit_USER (user_exit_msg);
    free (recur_cost_flag);
    free (recur_exit_code);
    free (recur_parameter_dimension);
    free (RECUR_USER_OPTIONS);
    free (recur_parameter_lower_bound);
    free (recur_parameter_upper_bound);
    free (recur_cost_parameters);
    free (recur_parameter_int_real);
    free (recur_cost_tangents);
    free (recur_cost_curvature);
#if RECUR_OPTIONS_FILE
    fclose (recur_ptr_options);
#endif
    return (-2);
  }
#endif /* ASA_TEMPLATE */
#endif /* OPTIONAL_DATA_PTR */

#if ASA_SAVE
  /* Such data could be saved in a user_save file, but for
     convenience here everything is saved in asa_save. */
  RECUR_USER_OPTIONS->Random_Array_Dim = SHUFFLE;
  RECUR_USER_OPTIONS->Random_Array = random_array;
#endif /* ASA_SAVE */

  /* open the output file */
#if ASA_SAVE
  if (!strcmp (USER_OUT, "STDOUT")) {
#if INCL_STDOUT
    ptr_out = stdout;
#endif /* INCL_STDOUT */
  } else {
    ptr_out = fopen (USER_OUT, "a");
  }
#else
  if (!strcmp (USER_OUT, "STDOUT")) {
#if INCL_STDOUT
    ptr_out = stdout;
#endif /* INCL_STDOUT */
  } else {
    ptr_out = fopen (USER_OUT, "w");
  }
#endif
  fprintf (ptr_out, "%s\n\n", USER_ID);

#if ASA_LIB
#else
  /* print out compile options set by user in Makefile */
  if (argc > 1) {
    fprintf (ptr_out, "CC = %s\n", argv[1]);
    for (compile_cnt = 2; compile_cnt < argc; ++compile_cnt) {
      fprintf (ptr_out, "\t%s\n", argv[compile_cnt]);
    }
    fprintf (ptr_out, "\n");
  }
#endif
#if TIME_CALC
  /* print starting time */
  print_time ("start", ptr_out);
#endif
  fflush (ptr_out);

  if ((recur_rand_seed =
       (ALLOC_INT *) calloc (1, sizeof (ALLOC_INT))) == NULL) {
    strcpy (user_exit_msg, "main()/asa_main(): recur_rand_seed");
    Exit_USER (user_exit_msg);
    free (recur_cost_flag);
    free (recur_exit_code);
    free (recur_parameter_dimension);
    free (RECUR_USER_OPTIONS);
    free (recur_parameter_lower_bound);
    free (recur_parameter_upper_bound);
    free (recur_cost_parameters);
    free (recur_parameter_int_real);
    free (recur_cost_tangents);
    free (recur_cost_curvature);
#if RECUR_OPTIONS_FILE
    fclose (recur_ptr_options);
#endif
    return (-2);
  }

  /* first value of *recur_rand_seed */
#if ASA_LIB
  *recur_rand_seed = (asa_rand_seed ? *asa_rand_seed : (LONG_INT) 696969);
#else
  *recur_rand_seed = 696969;
#endif

  randflt (recur_rand_seed);

#if USER_COST_SCHEDULE
  RECUR_USER_OPTIONS->Cost_Schedule = recur_user_cost_schedule;
#endif
#if USER_ACCEPTANCE_TEST
  RECUR_USER_OPTIONS->Acceptance_Test = recur_user_acceptance_test;
#endif
#if USER_ACCEPT_ASYMP_EXP
  RECUR_USER_OPTIONS->Asymp_Exp_Param = 1.0;
#endif
#if USER_GENERATING_FUNCTION
  RECUR_USER_OPTIONS->Generating_Distrib = recur_user_generating_distrib;
#endif
#if USER_REANNEAL_COST
  RECUR_USER_OPTIONS->Reanneal_Cost_Function = recur_user_reanneal_cost;
#endif
#if USER_REANNEAL_PARAMETERS
  RECUR_USER_OPTIONS->Reanneal_Params_Function = recur_user_reanneal_params;
#endif

#if MY_TEMPLATE                 /* MY_TEMPLATE_recur_pre_initialize */
  /* last changes before entering recur_initialize_parameters() */
#endif

  /* initialize the users parameters, allocating space, etc.
     Note that the default is to have asa generate the initial
     recur_cost_parameters that satisfy the user's constraints. */

  recur_initialize_params_value =
    recur_initialize_parameters (recur_cost_parameters,
                                 recur_parameter_lower_bound,
                                 recur_parameter_upper_bound,
                                 recur_cost_tangents,
                                 recur_cost_curvature,
                                 recur_parameter_dimension,
                                 recur_parameter_int_real,
#if RECUR_OPTIONS_FILE_DATA
                                 recur_ptr_options,
#endif
                                 RECUR_USER_OPTIONS);
#if RECUR_OPTIONS_FILE
  fclose (recur_ptr_options);
#endif
  if (recur_initialize_params_value == -2) {
    free (recur_cost_flag);
    free (recur_exit_code);
    free (recur_parameter_dimension);
    free (RECUR_USER_OPTIONS);
    free (recur_parameter_lower_bound);
    free (recur_parameter_upper_bound);
    free (recur_cost_parameters);
    free (recur_parameter_int_real);
    free (recur_cost_tangents);
    free (recur_cost_curvature);
    return (recur_initialize_params_value);
  }
#if USER_ASA_USR_OUT
  if ((RECUR_USER_OPTIONS->Asa_Usr_Out_File =
       (char *) calloc (80, sizeof (char))) == NULL) {
    strcpy (user_exit_msg,
            "main()/asa_main(): RECUR_USER_OPTIONS->Asa_Usr_Out_File");
  }
#endif
#if USER_ASA_OUT
  if ((RECUR_USER_OPTIONS->Asa_Out_File =
       (char *) calloc (80, sizeof (char))) == NULL) {
    strcpy (user_exit_msg,
            "main()/asa_main(): RECUR_USER_OPTIONS->Asa_Out_File");
    Exit_USER (user_exit_msg);
    free (recur_cost_flag);
    free (recur_exit_code);
    free (recur_parameter_dimension);
    free (RECUR_USER_OPTIONS);
    free (recur_parameter_lower_bound);
    free (recur_parameter_upper_bound);
    free (recur_cost_parameters);
    free (recur_parameter_int_real);
    free (recur_cost_tangents);
    free (recur_cost_curvature);
    return (-2);
  }
#if ASA_TEMPLATE_SELFOPT
  strcpy (RECUR_USER_OPTIONS->Asa_Out_File, "asa_sfop");
#endif
#endif

#if ASA_FUZZY
  /* can use in inner optimization shell */
  InitFuzzyASA (USER_OPTIONS, *recur_parameter_dimension);
#endif /* ASA_FUZZY */

  recur_cost_value = asa (RECUR_USER_COST_FUNCTION,
                          randflt,
                          recur_rand_seed,
                          recur_cost_parameters,
                          recur_parameter_lower_bound,
                          recur_parameter_upper_bound,
                          recur_cost_tangents,
                          recur_cost_curvature,
                          recur_parameter_dimension,
                          recur_parameter_int_real,
                          recur_cost_flag,
                          recur_exit_code, RECUR_USER_OPTIONS);
  if (*recur_exit_code == -1) {
#if INCL_STDOUT
    printf ("\n\n*** error in calloc in ASA ***\n\n");
#endif /* INCL_STDOUT */
    fprintf (ptr_out, "\n\n*** error in calloc in ASA ***\n\n");
    fflush (ptr_out);
    return (-1);
  }
#if ASA_FUZZY
  if (USER_OPTIONS->Locate_Cost == 12) {
    USER_OPTIONS->Locate_Cost = 0;
  }
  CloseFuzzyASA (RECUR_USER_OPTIONS);
#endif /* ASA_FUZZY */
#if MULTI_MIN
  fprintf (ptr_out, "Multi_Specify = %d\n",
           RECUR_USER_OPTIONS->Multi_Specify);
  for (n_param = 0; n_param < *recur_parameter_dimension; ++n_param) {
    fprintf (ptr_out,
#if INT_ALLOC
             "Multi_Grid[%d] = %12.7g\n",
#else
#if INT_LONG
             "Multi_Grid[%ld] = %12.7g\n",
#else
             "Multi_Grid[%d] = %12.7g\n",
#endif
#endif
             n_param, RECUR_USER_OPTIONS->Multi_Grid[n_param]);
  }
  fprintf (ptr_out, "\n");
  for (multi_index = 0; multi_index < RECUR_USER_OPTIONS->Multi_Number;
       ++multi_index) {
    fprintf (ptr_out, "\n");
    fprintf (ptr_out, "Multi_Cost[%d] = %12.7g\n",
             multi_index, RECUR_USER_OPTIONS->Multi_Cost[multi_index]);
    for (n_param = 0; n_param < *recur_parameter_dimension; ++n_param) {
      fprintf (ptr_out,
#if INT_ALLOC
               "Multi_Params[%d][%d] = %12.7g\n",
#else
#if INT_LONG
               "Multi_Params[%d][%ld] = %12.7g\n",
#else
               "Multi_Params[%d][%d] = %12.7g\n",
#endif
#endif
               multi_index, n_param,
               RECUR_USER_OPTIONS->Multi_Params[multi_index][n_param]);
    }
  }
  fprintf (ptr_out, "\n");
  fflush (ptr_out);
#endif /* MULTI_MIN */

#if FITLOC
  /* Fit_Local and Penalty may be set adaptively */
  RECUR_USER_OPTIONS->Penalty = 1000;
  RECUR_USER_OPTIONS->Fit_Local = 1;
  RECUR_USER_OPTIONS->Iter_Max = 500;
  if (RECUR_USER_OPTIONS->Fit_Local >= 1) {
    recur_cost_value = fitloc (RECUR_USER_COST_FUNCTION,
                               recur_cost_parameters,
                               recur_parameter_lower_bound,
                               recur_parameter_upper_bound,
                               recur_cost_tangents,
                               recur_cost_curvature,
                               recur_parameter_dimension,
                               recur_parameter_int_real,
                               recur_cost_flag,
                               recur_exit_code, RECUR_USER_OPTIONS, ptr_out);
  }
#endif /* FITLOC */

  fprintf (ptr_out, "\n\n recur_cost_value = %12.7g\n", recur_cost_value);
#if MY_TEMPLATE                 /* MY_TEMPLATE_recur_post_recur_asa */
#endif
#if ASA_TEMPLATE_LIB
  *main_recur_cost_value = recur_cost_value;
  for (recur_v = 0; recur_v < *recur_parameter_dimension; ++recur_v) {
    main_recur_cost_parameters[recur_v] = recur_cost_parameters[recur_v];
  }
  *main_recur_exit_code = *recur_exit_code;
#endif

  for (recur_v = 0; recur_v < *recur_parameter_dimension; ++recur_v)
#if INT_ALLOC
    fprintf (ptr_out, "recur_cost_parameters[%d] = %12.7g\n",
#else
#if INT_LONG
    fprintf (ptr_out, "recur_cost_parameters[%ld] = %12.7g\n",
#else
    fprintf (ptr_out, "recur_cost_parameters[%d] = %12.7g\n",
#endif
#endif
             recur_v, recur_cost_parameters[recur_v]);

  fprintf (ptr_out, "\n\n");

#if TIME_CALC
  /* print ending time */
  print_time ("end", ptr_out);
#endif

  /* close all files */
  fclose (ptr_out);

#if OPTIONAL_DATA_DBL
  free (RECUR_USER_OPTIONS->Asa_Data_Dbl);
#endif
#if OPTIONAL_DATA_INT
  free (RECUR_USER_OPTIONS->Asa_Data_Int);
#endif
#if OPTIONAL_DATA_PTR
  free (RECUR_USER_OPTIONS->Asa_Data_Ptr);
#endif
#if USER_ASA_OUT
#if TEMPLATE
  /* if necessary */
  free (recur_asa_out_my);
#endif
  free (RECUR_USER_OPTIONS->Asa_Out_File);
#endif
#if USER_ASA_USR_OUT
#if ASA_TEMPLATE
  /* if necessary */
  free (recur_asa_usr_out_my);
#endif
  free (RECUR_USER_OPTIONS->Asa_Usr_Out_File);
#endif
#if ASA_QUEUE
#if ASA_RESOLUTION
#else
  free (RECUR_USER_OPTIONS->Queue_Resolution);
#endif
#endif
#if ASA_RESOLUTION
  free (RECUR_USER_OPTIONS->Coarse_Resolution);
#endif
  if (RECUR_USER_OPTIONS->Curvature_0 == FALSE
      || RECUR_USER_OPTIONS->Curvature_0 == -1)
    free (recur_cost_curvature);
#if USER_INITIAL_PARAMETERS_TEMPS
  free (RECUR_USER_OPTIONS->User_Parameter_Temperature);
#endif
#if USER_INITIAL_COST_TEMP
  free (RECUR_USER_OPTIONS->User_Cost_Temperature);
#endif
#if DELTA_PARAMETERS
  free (RECUR_USER_OPTIONS->User_Delta_Parameter);
#endif
#if QUENCH_PARAMETERS
  free (RECUR_USER_OPTIONS->User_Quench_Param_Scale);
#endif
#if QUENCH_COST
  free (RECUR_USER_OPTIONS->User_Quench_Cost_Scale);
#endif
#if RATIO_TEMPERATURE_SCALES
  free (RECUR_USER_OPTIONS->User_Temperature_Ratio);
#endif
#if MULTI_MIN
  free (RECUR_USER_OPTIONS->Multi_Cost);
  free (RECUR_USER_OPTIONS->Multi_Grid);
  for (multi_index = 0; multi_index < RECUR_USER_OPTIONS->Multi_Number;
       ++multi_index) {
    free (RECUR_USER_OPTIONS->Multi_Params[multi_index]);
  }
  free (RECUR_USER_OPTIONS->Multi_Params);
#endif /* MULTI_MIN */
  free (RECUR_USER_OPTIONS);
  free (recur_parameter_dimension);
  free (recur_exit_code);
  free (recur_cost_flag);
  free (recur_parameter_lower_bound);
  free (recur_parameter_upper_bound);
  free (recur_cost_parameters);
  free (recur_parameter_int_real);
  free (recur_cost_tangents);
  free (recur_rand_seed);

  return (0);
  /* NOTREACHED */
}

/***********************************************************************
* recur_initialize_parameters
*	This depends on the users cost function to optimize (minimum).
*	The routine allocates storage needed for asa. The user should
*	define the number of parameters and their ranges,
*	and make sure the initial parameters are within
*	the minimum and maximum ranges. The array
*	recur_parameter_int_real should be REAL_TYPE (-1)
*       for real parameters,
***********************************************************************/
#if HAVE_ANSI
int
recur_initialize_parameters (double *recur_cost_parameters,
                             double *recur_parameter_lower_bound,
                             double *recur_parameter_upper_bound,
                             double *recur_cost_tangents,
                             double *recur_cost_curvature,
                             ALLOC_INT * recur_parameter_dimension,
                             int *recur_parameter_int_real,
#if RECUR_OPTIONS_FILE_DATA
                             FILE * recur_ptr_options,
#endif
                             USER_DEFINES * RECUR_USER_OPTIONS)
#else
int
recur_initialize_parameters (recur_cost_parameters,
                             recur_parameter_lower_bound,
                             recur_parameter_upper_bound,
                             recur_cost_tangents,
                             recur_cost_curvature,
                             recur_parameter_dimension,
                             recur_parameter_int_real,
#if RECUR_OPTIONS_FILE_DATA
                             recur_ptr_options,
#endif
                             RECUR_USER_OPTIONS)
     double *recur_parameter_lower_bound;
     double *recur_parameter_upper_bound;
     double *recur_cost_parameters;
     double *recur_cost_tangents;
     double *recur_cost_curvature;
     ALLOC_INT *recur_parameter_dimension;
     int *recur_parameter_int_real;
#if RECUR_OPTIONS_FILE_DATA
     FILE *recur_ptr_options;
#endif
     USER_DEFINES *RECUR_USER_OPTIONS;
#endif
{
  int fscanf_ret;
  ALLOC_INT index;
#if RECUR_OPTIONS_FILE_DATA
  char read_option[80];
  ALLOC_INT read_index;
#endif
#if MY_TEMPLATE                 /* MY_TEMPLATE_recur_init_decl */
  /* add some declarations if required */
#endif
#if MULTI_MIN
  int multi_index;
#endif

  index = 0;                    /* initialize to prevent warning */
  fscanf_ret = 0;

#if RECUR_OPTIONS_FILE_DATA
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);

  for (index = 0; index < *recur_parameter_dimension; ++index) {
#if MY_TEMPLATE                 /* MY_TEMPLATE_recur_read_opt */
    /* put in some code as required to alter lines read from recur_asa_opt */
#endif
#if INT_ALLOC
    fscanf_ret = fscanf (recur_ptr_options, "%d", &read_index);
#else
#if INT_LONG
    fscanf_ret = fscanf (recur_ptr_options, "%ld", &read_index);
#else
    fscanf_ret = fscanf (recur_ptr_options, "%d", &read_index);
#endif
#endif
    fscanf_ret = fscanf (recur_ptr_options, "%lf%lf%lf%d",
                         &(recur_parameter_lower_bound[read_index]),
                         &(recur_parameter_upper_bound[read_index]),
                         &(recur_cost_parameters[read_index]),
                         &(recur_parameter_int_real[read_index]));
  }
#else /* RECUR_OPTIONS_FILE_DATA */
#if ASA_TEMPLATE_SELFOPT
  /*  NOTE:
     USER_OPTIONS->Temperature_Ratio_Scale = x[0];
     USER_OPTIONS->Cost_Parameter_Scale_Ratio = x[1];
   */

  /* store the initial parameter values */
  recur_cost_parameters[0] = 1.0E-5;
  recur_cost_parameters[1] = 1.0;

  recur_parameter_lower_bound[0] = 1.0E-6;
  recur_parameter_upper_bound[0] = 1.0E-4;

  recur_parameter_lower_bound[1] = 0.5;
  recur_parameter_upper_bound[1] = 3.0;

  /* store the initial parameter types */
  for (index = 0; index < *recur_parameter_dimension; ++index)
    recur_parameter_int_real[index] = REAL_TYPE;
#endif
#endif /* RECUR_OPTIONS_FILE_DATA */

#if USER_INITIAL_PARAMETERS_TEMPS
  if ((RECUR_USER_OPTIONS->User_Parameter_Temperature =
       (double *) calloc (*recur_parameter_dimension,
                          sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "recur_initialize_parameters(): RECUR_USER_OPTIONS->User_Parameter_Temperature");
    Exit_USER (user_exit_msg);
    return (-2);
  }
  for (index = 0; index < *recur_parameter_dimension; ++index)
    RECUR_USER_OPTIONS->User_Parameter_Temperature[index] = 1.0;
#endif /* USER_INITIAL_PARAMETERS_TEMPS */
#if USER_INITIAL_COST_TEMP
  if ((RECUR_USER_OPTIONS->User_Cost_Temperature =
       (double *) calloc (1, sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "recur_initialize_parameters(): RECUR_USER_OPTIONS->User_Cost_Temperature");
    Exit_USER (user_exit_msg);
    return (-2);
  }
  RECUR_USER_OPTIONS->User_Cost_Temperature[0] = 5.936648E+09;
#endif /* USER_INITIAL_COST_TEMP */
#if DELTA_PARAMETERS
  if ((RECUR_USER_OPTIONS->User_Delta_Parameter =
       (double *) calloc (*recur_parameter_dimension,
                          sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "recur_initialize_parameters(): RECUR_USER_OPTIONS->User_Delta_Parameter");
    Exit_USER (user_exit_msg);
    return (-2);
  }
  for (index = 0; index < *recur_parameter_dimension; ++index)
    RECUR_USER_OPTIONS->User_Delta_Parameter[index] = 0.001;
#endif /* DELTA_PARAMETERS */
#if QUENCH_PARAMETERS
  if ((RECUR_USER_OPTIONS->User_Quench_Param_Scale =
       (double *) calloc (*recur_parameter_dimension,
                          sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "recur_initialize_parameters(): RECUR_USER_OPTIONS->User_Quench_Param_Scale");
    Exit_USER (user_exit_msg);
    return (-2);
  }
#if ASA_TEMPLATE
  for (index = 0; index < *recur_parameter_dimension; ++index)
    RECUR_USER_OPTIONS->User_Quench_Param_Scale[index] = 1.0;
#endif
#endif /* QUENCH_PARAMETERS */
#if QUENCH_COST
  if ((RECUR_USER_OPTIONS->User_Quench_Cost_Scale =
       (double *) calloc (1, sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "recur_initialize_parameters(): RECUR_USER_OPTIONS->User_Quench_Cost_Scale");
    Exit_USER (user_exit_msg);
    return (-2);
  }
#if ASA_TEMPLATE
  RECUR_USER_OPTIONS->User_Quench_Cost_Scale[0] = 1.0;
#endif
#endif /* QUENCH_COST */

  /* use asa_opt_recur to read in QUENCH RECUR_USER_OPTIONS */
#if RECUR_OPTIONS_FILE_DATA
#if QUENCH_COST
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%lf",
                       &(RECUR_USER_OPTIONS->User_Quench_Cost_Scale[0]));

#if QUENCH_PARAMETERS
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  fscanf_ret = fscanf (recur_ptr_options, "%s", read_option);
  for (index = 0; index < *recur_parameter_dimension; ++index) {
#if INT_ALLOC
    fscanf_ret = fscanf (recur_ptr_options, "%d", &read_index);
#else
#if INT_LONG
    fscanf_ret = fscanf (recur_ptr_options, "%ld", &read_index);
#else
    fscanf_ret = fscanf (recur_ptr_options, "%d", &read_index);
#endif
#endif
    fscanf_ret = fscanf (recur_ptr_options, "%lf",
                         &(RECUR_USER_OPTIONS->User_Quench_Param_Scale
                           [read_index]));
  }
#endif /* QUENCH_PARAMETERS */
#endif /* QUENCH_COST */
#endif /* RECUR_OPTIONS_FILE_DATA */
#if RATIO_TEMPERATURE_SCALES
  if ((RECUR_USER_OPTIONS->User_Temperature_Ratio =
       (double *) calloc (*recur_parameter_dimension,
                          sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "recur_initialize_parameters(): RECUR_USER_OPTIONS->User_Temperature_Ratio");
    Exit_USER (user_exit_msg);
    return (-2);
  }
#if ASA_TEMPLATE
  for (index = 0; index < *recur_parameter_dimension; ++index)
    RECUR_USER_OPTIONS->User_Temperature_Ratio[index] = 1.0;
#endif
#endif /* RATIO_TEMPERATURE_SCALES */
  /* Defines the limit of collection of sampled data by asa */

#if ASA_TEMPLATE
#if ASA_PARALLEL
  RECUR_USER_OPTIONS->Gener_Block = 1;
  RECUR_USER_OPTIONS->Gener_Block_Max = 1;
  RECUR_USER_OPTIONS->Gener_Mov_Avr = 1;
#endif
#endif
#if ASA_RESOLUTION
  if ((RECUR_USER_OPTIONS->Coarse_Resolution =
       (double *) calloc (*recur_parameter_dimension,
                          sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "recur_initialize_parameters(): RECUR_USER_OPTIONS->Coarse_Resolution");
    Exit_USER (user_exit_msg);
    return (-2);
  }
#endif
#if MULTI_MIN
#if ASA_TEMPLATE
  RECUR_USER_OPTIONS->Multi_Number = 2;
#endif
  if ((RECUR_USER_OPTIONS->Multi_Cost =
       (double *) calloc (RECUR_USER_OPTIONS->Multi_Number,
                          sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "initialize_parameters(): RECUR_USER_OPTIONS->Multi_Cost");
    Exit_USER (user_exit_msg);
    return (-2);
  }
  if ((RECUR_USER_OPTIONS->Multi_Grid =
       (double *) calloc (*recur_parameter_dimension,
                          sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "recur_initialize_parameters(): RECUR_USER_OPTIONS->Multi_Grid");
    Exit_USER (user_exit_msg);
    return (-2);
  }
  if ((RECUR_USER_OPTIONS->Multi_Params =
       (double **) calloc (RECUR_USER_OPTIONS->Multi_Number,
                           sizeof (double *))) == NULL) {
    strcpy (user_exit_msg,
            "initialize_parameters(): RECUR_USER_OPTIONS->Multi_Params");
    Exit_USER (user_exit_msg);
    return (-2);
  }
  for (multi_index = 0; multi_index < RECUR_USER_OPTIONS->Multi_Number;
       ++multi_index) {
    if ((RECUR_USER_OPTIONS->Multi_Params[multi_index] =
         (double *) calloc (*recur_parameter_dimension,
                            sizeof (double))) == NULL) {
      strcpy (user_exit_msg,
              "recur_initialize_parameters(): RECUR_USER_OPTIONS->Multi_Params[multi_index]");
      Exit_USER (user_exit_msg);
      return (-2);
    }
  }
#if ASA_TEST
  for (index = 0; index < *recur_parameter_dimension; ++index) {
    RECUR_USER_OPTIONS->Multi_Grid[index] = 0.05;
  }
  RECUR_USER_OPTIONS->Multi_Specify = 0;
#endif
#if ASA_TEMPLATE
  for (index = 0; index < *recur_parameter_dimension; ++index) {
    RECUR_USER_OPTIONS->Multi_Grid[index] =
      (recur_parameter_upper_bound[index] -
       recur_parameter_lower_bound[index]) / 100.0;
  }
  RECUR_USER_OPTIONS->Multi_Specify = 0;
#endif /* ASA_TEMPLATE */
#endif /* MULTI_MIN */
#if ASA_TEMPLATE_QUEUE
  RECUR_USER_OPTIONS->Queue_Size = 0;
#endif
#if ASA_QUEUE
#if ASA_RESOLUTION
  RECUR_USER_OPTIONS->Queue_Resolution =
    RECUR_USER_OPTIONS->Coarse_Resolution;
#else /* ASA_RESOLUTION */
  if ((RECUR_USER_OPTIONS->Queue_Resolution =
       (double *) calloc (*recur_parameter_dimension,
                          sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "recur_initialize_parameters(): RECUR_USER_OPTIONS->Queue_Resolution");
    Exit_USER (user_exit_msg);
    return (-2);
  }
#endif /* ASA_RESOLUTION */
#if ASA_TEMPLATE_QUEUE
  RECUR_USER_OPTIONS->Queue_Size = 0;
#endif
#endif /* ASA_QUEUE */
#if MY_TEMPLATE                 /* MY_TEMPLATE_recur_params */
  /* If not using RECUR_OPTIONS_FILE_DATA or data read from recur_asa_opt,
     store the recur_parameter ranges
     store the recur_parameter types
     store the initial recur_parameter values
     other changes needed for initialization */
#endif /* MY_TEMPLATE recur_params */
  RECUR_USER_OPTIONS->Asa_Recursive_Level = 1;

  return (0);
}

/***********************************************************************
* double recur_cost_function
*	This is the users cost function to optimize
*	(find the minimum).
*	cost_flag is set to TRUE if the parameter set
*	does not violates any constraints
*       recur_parameter_lower_bound and recur_parameter_upper_bound
*       may be adaptively changed during the search.
***********************************************************************/
#if HAVE_ANSI
double
recur_cost_function (double *x,
                     double *recur_parameter_lower_bound,
                     double *recur_parameter_upper_bound,
                     double *recur_cost_tangents,
                     double *recur_cost_curvature,
                     ALLOC_INT * recur_parameter_dimension,
                     int *recur_parameter_int_real,
                     int *recur_cost_flag,
                     int *recur_exit_code, USER_DEFINES * RECUR_USER_OPTIONS)
#else
double
recur_cost_function (x,
                     recur_parameter_lower_bound,
                     recur_parameter_upper_bound,
                     recur_cost_tangents,
                     recur_cost_curvature,
                     recur_parameter_dimension,
                     recur_parameter_int_real,
                     recur_cost_flag, recur_exit_code, RECUR_USER_OPTIONS)
     double *x;
     double *recur_parameter_lower_bound;
     double *recur_parameter_upper_bound;
     double *recur_cost_tangents;
     double *recur_cost_curvature;
     ALLOC_INT *recur_parameter_dimension;
     int *recur_parameter_int_real;
     int *recur_cost_flag;
     int *recur_exit_code;
     USER_DEFINES *RECUR_USER_OPTIONS;
#endif
{
  int fscanf_ret;
  double cost_value;
  static LONG_INT recur_funevals = 0;
  int *exit_code;
  char user_exit_msg[160];
#if OPTIONAL_DATA_PTR
  int data_ptr_flg;
#endif
#if OPTIONS_FILE
  FILE *ptr_options;
  char read_option[80];
  char read_if[4], read_FALSE[6], read_comm1[3], read_ASA_SAVE[9],
    read_comm2[3];
  int read_int;
#if INT_LONG
  LONG_INT read_long;
#endif
  double read_double;
#endif
#if MY_TEMPLATE                 /* MY_TEMPLATE_recur_cost_decl */
  /* add some declarations if required */
#endif

  double *parameter_lower_bound, *parameter_upper_bound;
  double *cost_parameters;
  double *cost_tangents, *cost_curvature;
  ALLOC_INT *parameter_dimension;
  int *parameter_int_real;
  int *cost_flag;
  static LONG_INT *rand_seed;
  static int initial_flag = 0;
#if MULTI_MIN
  int multi_index;
#endif

  USER_DEFINES *USER_OPTIONS;

  recur_funevals = recur_funevals + 1;

  if ((rand_seed = (ALLOC_INT *) calloc (1, sizeof (ALLOC_INT))) == NULL) {
    strcpy (user_exit_msg, "recur_cost_function(): rand_seed");
    Exit_USER (user_exit_msg);
    return (-2);
  }

  if ((USER_OPTIONS =
       (USER_DEFINES *) calloc (1, sizeof (USER_DEFINES))) == NULL) {
    strcpy (user_exit_msg, "recur_cost_function(): USER_OPTIONS");
    Exit_USER (user_exit_msg);
    return (-2);
  }
#if OPTIONS_FILE
  /* Test to see if asa_opt is in correct directory.
     This is useful for some PC and Mac compilers. */
  if ((ptr_options = fopen ("asa_opt", "r")) == NULL) {
#if INCL_STDOUT
    printf ("\n\n*** EXIT fopen asa_opt failed *** \n\n");
#endif /* INCL_STDOUT */
    free (USER_OPTIONS);
    return (6);
  }

  fscanf_ret = fscanf (ptr_options, "%s%s%s%s%s",
                       read_if, read_FALSE, read_comm1, read_ASA_SAVE,
                       read_comm2);
  if (strcmp (read_if, "#if") || strcmp (read_FALSE, "FALSE")
      || strcmp (read_comm1, "/*") || strcmp (read_ASA_SAVE, "ASA_SAVE")
      || strcmp (read_comm2, "*/")) {
#if INCL_STDOUT
    printf ("\n\n*** EXIT not asa_opt for this version *** \n\n");
#endif /* INCL_STDOUT */
    fclose (ptr_options);
    free (USER_OPTIONS);
    return (-6);
  }
#if INT_LONG
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%ld", &read_long);
  USER_OPTIONS->Limit_Acceptances = read_long;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%ld", &read_long);
  USER_OPTIONS->Limit_Generated = read_long;
#else
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Limit_Acceptances = read_int;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Limit_Generated = read_int;
#endif
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Limit_Invalid_Generated_States = read_int;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%lf", &read_double);
  USER_OPTIONS->Accepted_To_Generated_Ratio = read_double;

  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%lf", &read_double);
  USER_OPTIONS->Cost_Precision = read_double;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Maximum_Cost_Repeat = read_int;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Number_Cost_Samples = read_int;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%lf", &read_double);
  USER_OPTIONS->Temperature_Ratio_Scale = read_double;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%lf", &read_double);
  USER_OPTIONS->Cost_Parameter_Scale_Ratio = read_double;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%lf", &read_double);
  USER_OPTIONS->Temperature_Anneal_Scale = read_double;

  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Include_Integer_Parameters = read_int;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->User_Initial_Parameters = read_int;
#if INT_ALLOC
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Sequential_Parameters = read_int;
#else
#if INT_LONG
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%ld", &read_long);
  USER_OPTIONS->Sequential_Parameters = read_long;
#else
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Sequential_Parameters = read_int;
#endif
#endif
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%lf", &read_double);
  USER_OPTIONS->Initial_Parameter_Temperature = read_double;

  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Acceptance_Frequency_Modulus = read_int;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Generated_Frequency_Modulus = read_int;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Reanneal_Cost = read_int;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Reanneal_Parameters = read_int;

  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%lf", &read_double);
  USER_OPTIONS->Delta_X = read_double;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->User_Tangents = read_int;
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  USER_OPTIONS->Curvature_0 = read_int;
#else /* OPTIONS_FILE */
  /* USER_OPTIONS->Limit_Acceptances = 10000; */
  USER_OPTIONS->Limit_Acceptances = 1000;
  USER_OPTIONS->Limit_Generated = 99999;
  USER_OPTIONS->Limit_Invalid_Generated_States = 1000;
  USER_OPTIONS->Accepted_To_Generated_Ratio = 1.0E-6;

  USER_OPTIONS->Cost_Precision = 1.0E-18;
  USER_OPTIONS->Maximum_Cost_Repeat = 2;
  USER_OPTIONS->Number_Cost_Samples = 2;

  /* These variables are set below in x[.] */
  /* USER_OPTIONS->Temperature_Ratio_Scale = 1.0E-5; */
  /* USER_OPTIONS->Cost_Parameter_Scale_Ratio = 1.0; */

  USER_OPTIONS->Temperature_Anneal_Scale = 100.;

  USER_OPTIONS->Include_Integer_Parameters = FALSE;
  USER_OPTIONS->User_Initial_Parameters = FALSE;
  USER_OPTIONS->Sequential_Parameters = -1;
  USER_OPTIONS->Initial_Parameter_Temperature = 1.0;

  USER_OPTIONS->Acceptance_Frequency_Modulus = 100;
  USER_OPTIONS->Generated_Frequency_Modulus = 10000;
  USER_OPTIONS->Reanneal_Cost = 1;
  USER_OPTIONS->Reanneal_Parameters = TRUE;

  USER_OPTIONS->Delta_X = 0.001;
  USER_OPTIONS->User_Tangents = FALSE;
  USER_OPTIONS->Curvature_0 = TRUE;
#endif /* OPTIONS_FILE */

  USER_OPTIONS->Temperature_Ratio_Scale = x[0];
  USER_OPTIONS->Cost_Parameter_Scale_Ratio = x[1];

  if (initial_flag == 0) {
    /* first value of *rand_seed */
#if ASA_LIB
    *rand_seed = (asa_rand_seed ? *asa_rand_seed : (LONG_INT) 696969);
#else
    *rand_seed = 696969;
#endif
  }

  if ((parameter_dimension =
       (ALLOC_INT *) calloc (1, sizeof (ALLOC_INT))) == NULL) {
    strcpy (user_exit_msg, "recur_cost_function(): parameter_dimension");
    Exit_USER (user_exit_msg);
    free (USER_OPTIONS);
    fclose (ptr_options);
    return (-2);
  }
  if ((exit_code = (int *) calloc (1, sizeof (int))) == NULL) {
    strcpy (user_exit_msg, "recur_cost_function(): exit_code");
    Exit_USER (user_exit_msg);
    free (parameter_dimension);
    free (USER_OPTIONS);
    fclose (ptr_options);
    return (-2);
  }
  if ((cost_flag = (int *) calloc (1, sizeof (int))) == NULL) {
    strcpy (user_exit_msg, "recur_cost_function(): cost_flag");
    Exit_USER (user_exit_msg);
    free (exit_code);
    free (parameter_dimension);
    free (USER_OPTIONS);
    fclose (ptr_options);
    return (-2);
  }

  /* the number of parameters for the cost function */
#if OPTIONS_FILE_DATA
  fscanf_ret = fscanf (ptr_options, "%s", read_option);
  fscanf_ret = fscanf (ptr_options, "%s", read_option);

#if INT_ALLOC
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  *parameter_dimension = read_int;
#else
#if INT_LONG
  fscanf_ret = fscanf (ptr_options, "%ld", &read_long);
  *parameter_dimension = read_long;
#else
  fscanf_ret = fscanf (ptr_options, "%d", &read_int);
  *parameter_dimension = read_int;
#endif
#endif

#else /* OPTIONS_FILE_DATA */
#if ASA_TEST
  /* set parameter dimension if SELF_OPTIMIZE=TRUE */
  *parameter_dimension = 4;
#endif /* ASA_TEST */
#endif /* OPTIONS_FILE_DATA */
#if MY_TEMPLATE                 /* MY_TEMPLATE_recur_dim */
  /* If not using OPTIONS_FILE_DATA or data read from asa_opt,
     set parameter dimension if SELF_OPTIMIZE=TRUE */
#endif /* MY_TEMPLATE recur_dim */

  if ((parameter_lower_bound =
       (double *) calloc (*parameter_dimension, sizeof (double))) == NULL) {
    strcpy (user_exit_msg, "recur_cost_function(): parameter_lower_bound");
    Exit_USER (user_exit_msg);
    free (exit_code);
    free (parameter_dimension);
    free (cost_flag);
    free (USER_OPTIONS);
    fclose (ptr_options);
    return (-2);
  }
  if ((parameter_upper_bound =
       (double *) calloc (*parameter_dimension, sizeof (double))) == NULL) {
    strcpy (user_exit_msg, "recur_cost_function(): parameter_upper_bound");
    Exit_USER (user_exit_msg);
    free (exit_code);
    free (parameter_dimension);
    free (cost_flag);
    free (parameter_lower_bound);
    free (USER_OPTIONS);
    fclose (ptr_options);
    return (-2);
  }
  if ((cost_parameters =
       (double *) calloc (*parameter_dimension, sizeof (double))) == NULL) {
    strcpy (user_exit_msg, "recur_cost_function(): cost_parameters");
    Exit_USER (user_exit_msg);
    free (exit_code);
    free (parameter_dimension);
    free (cost_flag);
    free (parameter_lower_bound);
    free (parameter_upper_bound);
    free (USER_OPTIONS);
    fclose (ptr_options);
    return (-2);
  }
  if ((parameter_int_real =
       (int *) calloc (*parameter_dimension, sizeof (int))) == NULL) {
    strcpy (user_exit_msg, "recur_cost_function(): parameter_int_real");
    Exit_USER (user_exit_msg);
    free (exit_code);
    free (parameter_dimension);
    free (cost_flag);
    free (parameter_lower_bound);
    free (parameter_upper_bound);
    free (cost_parameters);
    free (USER_OPTIONS);
    fclose (ptr_options);
    return (-2);
  }
  if ((cost_tangents =
       (double *) calloc (*parameter_dimension, sizeof (double))) == NULL) {
    strcpy (user_exit_msg, "recur_cost_function(): cost_tangents");
    Exit_USER (user_exit_msg);
    free (exit_code);
    free (parameter_dimension);
    free (cost_flag);
    free (parameter_lower_bound);
    free (parameter_upper_bound);
    free (cost_parameters);
    free (parameter_int_real);
    free (USER_OPTIONS);
    fclose (ptr_options);
    return (-2);
  }

  if (USER_OPTIONS->Curvature_0 == FALSE || USER_OPTIONS->Curvature_0 == -1) {
    if ((cost_curvature =
         (double *) calloc ((*parameter_dimension) *
                            (*parameter_dimension),
                            sizeof (double))) == NULL) {
      strcpy (user_exit_msg, "recur_cost_function(): cost_curvature");
      Exit_USER (user_exit_msg);
      free (exit_code);
      free (parameter_dimension);
      free (cost_flag);
      free (parameter_lower_bound);
      free (parameter_upper_bound);
      free (cost_parameters);
      free (parameter_int_real);
      free (cost_tangents);
      free (USER_OPTIONS);
      fclose (ptr_options);
      return (-2);
    }
  } else {
    cost_curvature = (double *) NULL;
  }

#if ASA_TEMPLATE_SELFOPT
  /* Set memory to that required for use. */
  USER_OPTIONS->Asa_Data_Dim_Dbl = 2;
  if ((USER_OPTIONS->Asa_Data_Dbl =
       (double *) calloc (USER_OPTIONS->Asa_Data_Dim_Dbl,
                          sizeof (double))) == NULL) {
    strcpy (user_exit_msg,
            "recur_cost_function(): USER_OPTIONS->Asa_Data_Dbl");
    Exit_USER (user_exit_msg);
    free (exit_code);
    free (parameter_dimension);
    free (cost_flag);
    free (parameter_lower_bound);
    free (parameter_upper_bound);
    free (cost_parameters);
    free (parameter_int_real);
    free (cost_tangents);
    free (cost_curvature);
    free (USER_OPTIONS);
    fclose (ptr_options);
    return (-2);
  }
  /* Use Asa_Data_Dbl[0] as flag, e.g., if used with SELF_OPTIMIZE. */
  USER_OPTIONS->Asa_Data_Dbl[0] = 1.0;
#endif /* ASA_TEMPLATE_SELFOPT */

#if USER_COST_SCHEDULE
  USER_OPTIONS->Cost_Schedule = user_cost_schedule;
#endif
#if USER_ACCEPTANCE_TEST
  USER_OPTIONS->Acceptance_Test = user_acceptance_test;
#endif
#if USER_ACCEPT_ASYMP_EXP
  USER_OPTIONS->Asymp_Exp_Param = 1.0;
#endif
#if USER_GENERATING_FUNCTION
  USER_OPTIONS->Generating_Distrib = user_generating_distrib;
#endif
#if USER_REANNEAL_COST
  USER_OPTIONS->Reanneal_Cost_Function = user_reanneal_cost;
#endif
#if USER_REANNEAL_PARAMETERS
  USER_OPTIONS->Reanneal_Params_Function = user_reanneal_params;
#endif

  initialize_parameters (cost_parameters,
                         parameter_lower_bound,
                         parameter_upper_bound,
                         cost_tangents,
                         cost_curvature,
                         parameter_dimension, parameter_int_real,
#if OPTIONS_FILE_DATA
                         ptr_options,
#endif
                         USER_OPTIONS);
#if OPTIONS_FILE
  fclose (ptr_options);
#endif

#if ASA_SAVE
  USER_OPTIONS->Random_Array_Dim = SHUFFLE;
  USER_OPTIONS->Random_Array = random_array;
#endif /* ASA_SAVE */

  /* It might be a good idea to place a loop around this call,
     and to average over several values of funevals returned by
     trajectories of cost_value. */

  funevals = 0;

#if USER_ASA_USR_OUT
  if ((USER_OPTIONS->Asa_Usr_Out_File =
       (char *) calloc (80, sizeof (char))) == NULL) {
    strcpy (user_exit_msg,
            "recur_cost_function(): USER_OPTIONS->Asa_Usr_Out_File");
  }
#endif
#if USER_ASA_OUT
  if ((USER_OPTIONS->Asa_Out_File =
       (char *) calloc (80, sizeof (char))) == NULL) {
    strcpy (user_exit_msg,
            "recur_cost_function(): USER_OPTIONS->Asa_Out_File");
    Exit_USER (user_exit_msg);
    free (exit_code);
    free (parameter_dimension);
    free (cost_flag);
    free (parameter_lower_bound);
    free (parameter_upper_bound);
    free (cost_parameters);
    free (parameter_int_real);
    free (cost_tangents);
    free (cost_curvature);
    free (USER_OPTIONS);
    fclose (ptr_options);
    return (-2);
  }
#if ASA_TEMPLATE_SELFOPT
  strcpy (USER_OPTIONS->Asa_Out_File, "asa_rcur");
#endif
#endif

#if OPTIONAL_DATA_PTR
  data_ptr_flg = 1;
#if ASA_TEMPLATE
  /* N.b.:  If OPTIONAL_DATA_PTR is being used for RECUR_USER_OPTIONS
   * as well as for USER_OPTIONS, do not create (or free) additional memory
   * in recur_cost_function() for Asa_Data_Dim_Ptr and Asa_Data_Ptr to
   * be passed to the inner cost_function(), but rather link pointers to
   * those in RECUR_USER_OPTIONS.  Typically, define separate structures
   * within the structure defined by Asa_Data_Ptr to access info depending
   * on whether the run in a particular level of cost function in this
   * recursive operation.  In this case, set * #if TRUE to #if FALSE just
   * below.  See the ASA-README for more discussion.
   */

#if TRUE
  USER_OPTIONS->Asa_Data_Dim_Ptr = 1;
  if ((USER_OPTIONS->Asa_Data_Ptr =
       (OPTIONAL_PTR_TYPE *) calloc (USER_OPTIONS->Asa_Data_Dim_Ptr,
                                     sizeof (OPTIONAL_PTR_TYPE))) == NULL) {
    strcpy (user_exit_msg,
            "recur_cost_function(): USER_OPTIONS->Asa_Data_Ptr");
    Exit_USER (user_exit_msg);
    free (exit_code);
    free (parameter_dimension);
    free (cost_flag);
    free (parameter_lower_bound);
    free (parameter_upper_bound);
    free (cost_parameters);
    free (parameter_int_real);
    free (cost_tangents);
    free (cost_curvature);
    free (USER_OPTIONS);
    fclose (ptr_options);
    return (-2);
  }
#else
  USER_OPTIONS->Asa_Data_Dim_Ptr = RECUR_USER_OPTIONS->Asa_Data_Dim_Ptr;
  USER_OPTIONS->Asa_Data_Ptr = RECUR_USER_OPTIONS->Asa_Data_Ptr;
  data_ptr_flg = 0;
#endif
#endif /* ASA_TEMPLATE */
  /* see note at "Instead of freeing Asa_Data_Ptr" */
  /* USER_OPTIONS->Asa_Data_Ptr = OptionalPointer; */
  USER_OPTIONS->Asa_Data_Dim_Ptr = 1;
  if ((USER_OPTIONS->Asa_Data_Ptr =
       (OPTIONAL_PTR_TYPE *) calloc (USER_OPTIONS->Asa_Data_Dim_Ptr,
                                     sizeof (OPTIONAL_PTR_TYPE))) == NULL) {
    strcpy (user_exit_msg,
            "recur_cost_function(): USER_OPTIONS->Asa_Data_Ptr");
    Exit_USER (user_exit_msg);
    free (exit_code);
    free (parameter_dimension);
    free (cost_flag);
    free (parameter_lower_bound);
    free (parameter_upper_bound);
    free (cost_parameters);
    free (parameter_int_real);
    free (cost_tangents);
    free (cost_curvature);
    free (USER_OPTIONS);
    fclose (ptr_options);
    return (-2);
  }
#endif /* OPTIONAL_DATA_PTR */

  cost_value = asa (USER_COST_FUNCTION,
                    randflt,
                    rand_seed,
                    cost_parameters,
                    parameter_lower_bound,
                    parameter_upper_bound,
                    cost_tangents,
                    cost_curvature,
                    parameter_dimension,
                    parameter_int_real, cost_flag, exit_code, USER_OPTIONS);
  if (*exit_code == -1) {
#if INCL_STDOUT
    printf ("\n\n*** error in calloc in ASA ***\n\n");
#endif /* INCL_STDOUT */
    return (-1);
  }
#if MY_TEMPLATE                 /* MY_TEMPLATE_recur_post_asa */
#endif

  if (cost_value > .001) {
    *recur_cost_flag = FALSE;
  } else {
    *recur_cost_flag = TRUE;
  }

#if FALSE                       /* set to 1 to activate FAST EXIT */
  /* Make a quick exit */
  if (recur_funevals >= 10) {
    *recur_cost_flag = FALSE;
    RECUR_USER_OPTIONS->Limit_Invalid_Generated_States = 0;
#if INCL_STDOUT
    printf ("FAST EXIT set at recur_funevals = 10\n\n");
#endif
  }
#endif

#if TIME_CALC
  /* print every RECUR_PRINT_FREQUENCY evaluations */
  if ((RECUR_PRINT_FREQUENCY > 0) &&
      ((recur_funevals % RECUR_PRINT_FREQUENCY) == 0)) {
    USER_OPTIONS->Temperature_Ratio_Scale = x[0];
    USER_OPTIONS->Cost_Parameter_Scale_Ratio = x[1];
#if INCL_STDOUT
    printf ("USER_OPTIONS->Temperature_Ratio_Scale = %12.7g\n",
            USER_OPTIONS->Temperature_Ratio_Scale);
    printf ("USER_OPTIONS->Cost_Parameter_Scale_Ratio = %12.7g\n",
            USER_OPTIONS->Cost_Parameter_Scale_Ratio);
#endif
  }
#endif

#if INCL_STDOUT
  printf ("recur_funevals = %ld, *recur_cost_flag = %d\n",
          recur_funevals, *recur_cost_flag);
#endif
  /* cost function = number generated at best cost */
#if ASA_TEMPLATE_SELFOPT
  funevals = (LONG_INT) (USER_OPTIONS->Asa_Data_Dbl[1]);
#if INCL_STDOUT
  printf ("\tbest_funevals = %ld, cost_value = %12.7g\n\n",
          funevals, cost_value);
#endif
  /* cost function = total number generated during run */
#endif /* ASA_TEMPLATE_SELFOPT */

#if OPTIONAL_DATA_DBL
  free (USER_OPTIONS->Asa_Data_Dbl);
#endif
#if OPTIONAL_DATA_INT
  free (USER_OPTIONS->Asa_Data_Int);
#endif
#if OPTIONAL_DATA_PTR
  if (data_ptr_flg == 1) {
    free (USER_OPTIONS->Asa_Data_Ptr);
  }
#endif
#if USER_ASA_OUT
#if TEMPLATE
  /* if necessary */
  free (asa_out_my);
#endif
  free (USER_OPTIONS->Asa_Out_File);
#endif
#if USER_ASA_USR_OUT
#if ASA_TEMPLATE
  /* if necessary */
  free (asa_usr_out_my);
#endif
  free (USER_OPTIONS->Asa_Usr_Out_File);
#endif
#if ASA_QUEUE
#if ASA_RESOLUTION
#else
  free (USER_OPTIONS->Queue_Resolution);
#endif
#endif
#if ASA_RESOLUTION
  free (USER_OPTIONS->Coarse_Resolution);
#endif
  if (USER_OPTIONS->Curvature_0 == FALSE || USER_OPTIONS->Curvature_0 == -1)
    free (cost_curvature);
#if USER_INITIAL_PARAMETERS_TEMPS
  free (USER_OPTIONS->User_Parameter_Temperature);
#endif
#if USER_INITIAL_COST_TEMP
  free (USER_OPTIONS->User_Cost_Temperature);
#endif
#if DELTA_PARAMETERS
  free (USER_OPTIONS->User_Delta_Parameter);
#endif
#if QUENCH_PARAMETERS
  free (USER_OPTIONS->User_Quench_Param_Scale);
#endif
#if QUENCH_COST
  free (USER_OPTIONS->User_Quench_Cost_Scale);
#endif
#if RATIO_TEMPERATURE_SCALES
  free (USER_OPTIONS->User_Temperature_Ratio);
#endif
#if MULTI_MIN
  free (USER_OPTIONS->Multi_Grid);
  for (multi_index = 0; multi_index < USER_OPTIONS->Multi_Number;
       ++multi_index) {
    free (USER_OPTIONS->Multi_Params[multi_index]);
  }
#endif /* MULTI_MIN */
#if OPTIONAL_DATA_PTR
  if (data_ptr_flg == 0) {
    USER_OPTIONS = NULL;
  }
#endif
  free (USER_OPTIONS);
  free (parameter_dimension);
  free (exit_code);
  free (cost_flag);
  free (parameter_lower_bound);
  free (parameter_upper_bound);
  free (cost_parameters);
  free (parameter_int_real);
  free (cost_tangents);
  free (rand_seed);

  return ((double) funevals);
}

#if USER_COST_SCHEDULE
#if HAVE_ANSI
double
recur_user_cost_schedule (double test_temperature, const void *OPTIONS_TMP)
#else
double
recur_user_cost_schedule (test_temperature, OPTIONS_TMP)
     double test_temperature;
     void *OPTIONS_TMP;
#endif /* HAVE_ANSI */
{
  double x;
  USER_DEFINES *RECUR_USER_OPTIONS;

  RECUR_USER_OPTIONS = (USER_DEFINES *) OPTIONS_TMP;

  x = 0;                        /* initialize  to prevent warning */
#if ASA_TEMPLATE
  x = test_temperature;

#endif

  return (x);
}
#endif /* USER_COST_SCHEDULE */

#if USER_ACCEPTANCE_TEST
#if HAVE_ANSI
void
recur_user_acceptance_test (double current_cost,
                            double *recur_parameter_lower_bound,
                            double *recur_parameter_upper_bound,
                            ALLOC_INT * recur_parameter_dimension,
                            const void *OPTIONS_TMP)
#else
void
recur_user_acceptance_test (current_cost, recur_parameter_lower_bound,
                            recur_parameter_upper_bound,
                            recur_parameter_dimension, OPTIONS_TMP)
     double current_cost;
     double *recur_parameter_lower_bound;
     double *recur_parameter_upper_bound;
     ALLOC_INT *recur_parameter_dimension;
     void *OPTIONS_TMP;
#endif /* HAVE_ANSI */
{
  double uniform_test, curr_cost_temp;
#if USER_ACCEPT_ASYMP_EXP
  double x, q, delta_cost;
#endif
  USER_DEFINES *RECUR_USER_OPTIONS;

  RECUR_USER_OPTIONS = (USER_DEFINES *) OPTIONS_TMP;

#if ASA_TEMPLATE                /* ASA cost index */
  /* Calculate the current ASA cost index.  This could be useful
     to define a new schedule for the cost temperature, beyond
     simple changes that can be made using USER_COST_SCHEDULE. */

  int index;
  double k_temperature, quench, y;
  double xrecur_parameter_dimension;

#if QUENCH_COST
  quench = RECUR_USER_OPTIONS->User_Quench_Cost_Scale[0];
#else
  quench = 1.0;
#endif /* QUENCH_COST */
  xrecur_parameter_dimension = (double) *recur_parameter_dimension;
  for (index = 0; index < *recur_parameter_dimension; ++index)
    if (fabs
        (recur_parameter_upper_bound[index] -
         recur_parameter_lower_bound[index]) < (double) EPS_DOUBLE)
      *xrecur_parameter_dimension -= 1.0;

  y = -F_LOG (RECUR_USER_OPTIONS->Cost_Temp_Curr
              / RECUR_USER_OPTIONS->Cost_Temp_Init)
    / RECUR_USER_OPTIONS->Cost_Temp_Scale;

  k_temperature = F_POW (y, xrecur_parameter_dimension / quench);
#endif /* ASA cost index */

  uniform_test = randflt (RECUR_USER_OPTIONS->Random_Seed);
  curr_cost_temp = RECUR_USER_OPTIONS->Cost_Temp_Curr;

#if ASA_TEMPLATE
#if USER_COST_SCHEDULE
  curr_cost_temp =
    (RECUR_USER_OPTIONS->Cost_Schedule (RECUR_USER_OPTIONS->Cost_Temp_Curr,
                                        RECUR_USER_OPTIONS)
     + (double) EPS_DOUBLE);
#else
  curr_cost_temp = RECUR_USER_OPTIONS->Cost_Temp_Curr;
#endif
#endif /* ASA_TEMPLATE */

#if USER_ACCEPT_ASYMP_EXP
#if USER_COST_SCHEDULE
  curr_cost_temp =
    (RECUR_USER_OPTIONS->Cost_Schedule (RECUR_USER_OPTIONS->Cost_Temp_Curr,
                                        RECUR_USER_OPTIONS)
     + (double) EPS_DOUBLE);
#endif

  delta_cost = (current_cost - *(RECUR_USER_OPTIONS->Last_Cost))
    / (curr_cost_temp + (double) EPS_DOUBLE);

  q = RECUR_USER_OPTIONS->Asymp_Exp_Param;
  if (fabs (1.0 - q) < (double) EPS_DOUBLE)
    x = MIN (1.0, (F_EXP (-delta_cost)));       /* Boltzmann test */
  else if ((1.0 - (1.0 - q) * delta_cost) < (double) EPS_DOUBLE)
    x = MIN (1.0, (F_EXP (-delta_cost)));       /* Boltzmann test */
  else
    x = MIN (1.0, F_POW ((1.0 - (1.0 - q) * delta_cost), (1.0 / (1.0 - q))));

  RECUR_USER_OPTIONS->Prob_Bias = x;
  if (x >= uniform_test)
    RECUR_USER_OPTIONS->User_Acceptance_Flag = TRUE;
  else
    RECUR_USER_OPTIONS->User_Acceptance_Flag = FALSE;

#endif /* USER_ACCEPT_ASYMP_EXP */
}
#endif /* USER_ACCEPTANCE_TEST */

#if USER_GENERATING_FUNCTION
#if HAVE_ANSI
double
recur_user_generating_distrib (LONG_INT * seed,
                               ALLOC_INT * recur_parameter_dimension,
                               ALLOC_INT index_v,
                               double temperature_v,
                               double init_param_temp_v,
                               double temp_scale_params_v,
                               double parameter_v,
                               double parameter_range_v,
                               double *last_saved_parameter,
                               const void *OPTIONS_TMP)
#else
double
recur_user_generating_distrib (seed,
                               recur_parameter_dimension,
                               index_v,
                               temperature_v,
                               init_param_temp_v,
                               temp_scale_params_v,
                               parameter_v,
                               parameter_range_v,
                               last_saved_parameter, OPTIONS_TMP)
     LONG_INT *seed;
     ALLOC_INT *recur_parameter_dimension;
     ALLOC_INT index_v;
     double temperature_v;
     double init_param_temp_v;
     double temp_scale_params_v;
     double parameter_v;
     double parameter_range_v;
     double *last_saved_parameter;
     void *OPTIONS_TMP;
#endif
{
  double x;
  USER_DEFINES *RECUR_USER_OPTIONS;

  RECUR_USER_OPTIONS = (USER_DEFINES *) OPTIONS_TMP;

  x = 0;                        /* initialize  to prevent warning */
#if ASA_TEMPLATE
  double x, y, z;

  /* This is the ASA distribution.  A slower temperature schedule can be
     obtained here, e.g., temperature_v = pow(temperature_v, 0.5); */

  x = randflt (seed);
  y = x < 0.5 ? -1.0 : 1.0;
  z = y * temperature_v * (F_POW ((1.0 + 1.0 / temperature_v),
                                  fabs (2.0 * x - 1.0)) - 1.0);

  x = parameter_v + z * parameter_range_v;
#endif /* ASA_TEMPLATE */

  return (x);
}
#endif /* USER_GENERATING_FUNCTION */

#if USER_REANNEAL_COST
#if HAVE_ANSI
int
recur_user_reanneal_cost (double *cost_best,
                          double *cost_last,
                          double *initial_cost_temperature,
                          double *current_cost_temperature,
                          const void *OPTIONS_TMP)
#else
int
recur_user_reanneal_cost (cost_best,
                          cost_last,
                          initial_cost_temperature,
                          current_cost_temperature, OPTIONS_TMP)
     double *cost_best;
     double *cost_last;
     double *initial_cost_temperature;
     double *current_cost_temperature;
     void *OPTIONS_TMP;
#endif /* HAVE_ANSI */
{
  USER_DEFINES *RECUR_USER_OPTIONS;

  RECUR_USER_OPTIONS = (USER_DEFINES *) OPTIONS_TMP;

#if ASA_TEMPLATE
  double tmp_dbl;

  tmp_dbl = MAX (fabs (*cost_last), fabs (*cost_best));
  tmp_dbl = MAX ((double) EPS_DOUBLE, tmp_dbl);
  *initial_cost_temperature = MIN (*initial_cost_temperature, tmp_dbl);

#endif

  return (TRUE);
}
#endif /* USER_REANNEAL_COST */

#if USER_REANNEAL_PARAMETERS
#if HAVE_ANSI
double
recur_user_reanneal_params (double current_temp,
                            double tangent,
                            double max_tangent, const void *OPTIONS_TMP)
#else
double
recur_user_reanneal_params (current_temp, tangent, max_tangent, OPTIONS_TMP)
     double current_temp;
     double tangent;
     double max_tangent;
     void *OPTIONS_TMP;
#endif /* HAVE_ANSI */
{
  double x;
  USER_DEFINES *RECUR_USER_OPTIONS;

  RECUR_USER_OPTIONS = (USER_DEFINES *) OPTIONS_TMP;

  x = 0;                        /* initialize  to prevent warning */

#if ASA_TEMPLATE
  x = current_temp * (max_tangent / tangent);
#endif

  return (x);
}
#endif /* USER_REANNEAL_PARAMETERS */
#endif /* SELF_OPTIMIZE */

#if FITLOC
#if HAVE_ANSI
double
calcf (double (*user_cost_function)

        
       (double *, double *, double *, double *, double *, ALLOC_INT *, int *,
        int *, int *, USER_DEFINES *), double *xloc,
       double *parameter_lower_bound, double *parameter_upper_bound,
       double *cost_tangents, double *cost_curvature,
       ALLOC_INT * parameter_dimension, int *parameter_int_real,
       int *cost_flag, int *exit_code, USER_DEFINES * OPTIONS, FILE * ptr_out)
#else
double
calcf (user_cost_function,
       xloc,
       parameter_lower_bound,
       parameter_upper_bound,
       cost_tangents,
       cost_curvature,
       parameter_dimension,
       parameter_int_real, cost_flag, exit_code, OPTIONS, ptr_out)
     double (*user_cost_function) ();
     double *x;
     double *parameter_lower_bound;
     double *parameter_upper_bound;
     double *cost_tangents;
     double *cost_curvature;
     ALLOC_INT *parameter_dimension;
     int *parameter_int_real;
     int *cost_flag;
     int *exit_code;
     USER_DEFINES *OPTIONS;
     FILE *ptr_out;
#endif
{
  ALLOC_INT index_v;
#if FITLOC_ROUND
  double x, min_parameter_v, max_parameter_v, parameter_range_v;
#if ASA_RESOLUTION
  double xres, xint, xplus, xminus, dx, dxminus, dxplus;
#endif
#endif
  double floc;

#if FITLOC_ROUND
  /* The following section for adjustments of parameters is taken from
     generate_new_state() in asa.c */
  for (index_v = 0; index_v < *parameter_dimension; ++index_v) {
    if (fabs
        (parameter_lower_bound[index_v] - parameter_upper_bound[index_v]) <
        EPS_DOUBLE)
      continue;

    x = xloc[index_v];

    min_parameter_v = parameter_lower_bound[index_v];
    max_parameter_v = parameter_upper_bound[index_v];
    parameter_range_v = max_parameter_v - min_parameter_v;

    /* Handle discrete parameters. */
#if ASA_RESOLUTION
    xres = OPTIONS->Coarse_Resolution[index_v];
    if (xres > EPS_DOUBLE) {
      min_parameter_v -= (xres / 2.0);
      max_parameter_v += (xres / 2.0);
      parameter_range_v = max_parameter_v - min_parameter_v;
    }
#endif /* ASA_RESOLUTION */
    if (parameter_int_real[index_v] > 0) {
#if ASA_RESOLUTION
      if (xres > EPS_DOUBLE) {
        ;
      } else {
#endif /* ASA_RESOLUTION */
        min_parameter_v -= 0.5;
        max_parameter_v += 0.5;
        parameter_range_v = max_parameter_v - min_parameter_v;
      }
#if ASA_RESOLUTION
    }
#endif
#if ASA_RESOLUTION
    if (xres > EPS_DOUBLE) {
      xint = xres * (double) ((LONG_INT) (x / xres));
      xplus = xint + xres;
      xminus = xint - xres;
      dx = fabs (xint - x);
      dxminus = fabs (xminus - x);
      dxplus = fabs (xplus - x);

      if (dx < dxminus && dx < dxplus)
        x = xint;
      else if (dxminus < dxplus)
        x = xminus;
      else
        x = xplus;
    }
#endif /* ASA_RESOLUTION */

    /* Handle discrete parameters.
       You might have to check rounding on your machine. */
    if (parameter_int_real[index_v] > 0) {
#if ASA_RESOLUTION
      if (xres > EPS_DOUBLE) {
        ;
      } else {
#endif /* ASA_RESOLUTION */
        if (x < min_parameter_v + 0.5)
          x = min_parameter_v + 0.5 + (double) EPS_DOUBLE;
        if (x > max_parameter_v - 0.5)
          x = max_parameter_v - 0.5 + (double) EPS_DOUBLE;

        if (x + 0.5 > 0.0) {
          x = (double) ((LONG_INT) (x + 0.5));
        } else {
          x = (double) ((LONG_INT) (x - 0.5));
        }
        if (x > parameter_upper_bound[index_v])
          x = parameter_upper_bound[index_v];
        if (x < parameter_lower_bound[index_v])
          x = parameter_lower_bound[index_v];
      }
#if ASA_RESOLUTION
    }
    if (xres > EPS_DOUBLE) {
      if (x < min_parameter_v + xres / 2.0)
        x = min_parameter_v + xres / 2.0 + (double) EPS_DOUBLE;
      if (x > max_parameter_v - xres / 2.0)
        x = max_parameter_v - xres / 2.0 + (double) EPS_DOUBLE;

      if (x > parameter_upper_bound[index_v])
        x = parameter_upper_bound[index_v];
      if (x < parameter_lower_bound[index_v])
        x = parameter_lower_bound[index_v];
    }
#endif /* ASA_RESOLUTION */
    if ((x < parameter_lower_bound[index_v])
        || (x > parameter_upper_bound[index_v])) {
      ;
    } else {
      xloc[index_v] = x;
    }
  }
#endif /* FITLOC_ROUND */

  floc = user_cost_function (xloc,
                             parameter_lower_bound,
                             parameter_upper_bound,
                             cost_tangents,
                             cost_curvature,
                             parameter_dimension,
                             parameter_int_real,
                             cost_flag, exit_code, OPTIONS);

  if (*cost_flag == FALSE) {
    floc += OPTIONS->Penalty;
  }

  for (index_v = 0; index_v < *parameter_dimension; ++index_v) {
    if (parameter_upper_bound[index_v] - xloc[index_v] < EPS_DOUBLE)
      floc += OPTIONS->Penalty;
    else if (xloc[index_v] - parameter_lower_bound[index_v] < EPS_DOUBLE)
      floc += OPTIONS->Penalty;
  }

  return (floc);
}

#if HAVE_ANSI
double
fitloc (double (*user_cost_function)

         
        (double *, double *, double *, double *, double *, ALLOC_INT *, int *,
         int *, int *, USER_DEFINES *), double *xloc,
        double *parameter_lower_bound, double *parameter_upper_bound,
        double *cost_tangents, double *cost_curvature,
        ALLOC_INT * parameter_dimension, int *parameter_int_real,
        int *cost_flag, int *exit_code, USER_DEFINES * OPTIONS,
        FILE * ptr_out)
#else
double
fitloc (user_cost_function,
        xloc,
        parameter_lower_bound,
        parameter_upper_bound,
        cost_tangents,
        cost_curvature,
        parameter_dimension,
        parameter_int_real, cost_flag, exit_code, OPTIONS, ptr_out)
     double (*user_cost_function) ();
     double *xloc;
     double *parameter_lower_bound;
     double *parameter_upper_bound;
     double *cost_tangents;
     double *cost_curvature;
     ALLOC_INT *parameter_dimension;
     int *parameter_int_real;
     int *cost_flag;
     int *exit_code;
     USER_DEFINES *OPTIONS;
     FILE *ptr_out;
#endif
{
  double x;
  ALLOC_INT index_v;
#if FITLOC_ROUND
  double min_parameter_v, max_parameter_v, parameter_range_v;
#if ASA_RESOLUTION
  double xres, xint, xminus, xplus, dx, dxminus, dxplus;
#endif
#endif
  double *xsave;
  double tol1, tol2, alpha, beta1, beta2, gamma, delta, floc, fsave, ffinal;
  int no_progress, tot_iters, locflg, bndflg;

#if FITLOC_PRINT
  if (OPTIONS->Fit_Local >= 1) {
    fprintf (ptr_out, "\n\nSTART LOCAL FIT\n");
  } else {
    fprintf (ptr_out, "\n\nSTART LOCAL FIT Independent of ASA\n");
  }
  fflush (ptr_out);
#endif /* FITLOC_PRINT */

  xsave = (double *) calloc (*parameter_dimension, sizeof (double));
  bndflg = 0;

  /* The following simplex parameters may need adjustments for your system. */
  tol1 = EPS_DOUBLE;
  tol2 = EPS_DOUBLE * 100.;
  no_progress = 4;
  alpha = 1.0;
  beta1 = 0.75;
  beta2 = 0.75;
  gamma = 1.25;
  delta = 2.50;
  tot_iters = 0;
  if (tot_iters != 0)
    tot_iters = 0;

  for (index_v = 0; index_v < *parameter_dimension; ++index_v) {
    xsave[index_v] = xloc[index_v];
  }

  fsave = user_cost_function (xloc,
                              parameter_lower_bound,
                              parameter_upper_bound,
                              cost_tangents,
                              cost_curvature,
                              parameter_dimension,
                              parameter_int_real,
                              cost_flag, exit_code, OPTIONS);

  tot_iters = simplex (user_cost_function,
                       xloc,
                       parameter_lower_bound,
                       parameter_upper_bound,
                       cost_tangents,
                       cost_curvature,
                       parameter_dimension,
                       parameter_int_real,
                       cost_flag,
                       exit_code,
                       OPTIONS,
                       ptr_out,
                       tol1,
                       tol2, no_progress, alpha, beta1, beta2, gamma, delta);
  fflush (ptr_out);

  for (index_v = 0; index_v < *parameter_dimension; ++index_v) {
    x = xloc[index_v];
    if ((x < parameter_lower_bound[index_v])
        || (x > parameter_upper_bound[index_v])) {
      bndflg = 1;
    }
  }

  /* The following section for adjustments of parameters is taken from
     generate_new_state() in asa.c */
#if FITLOC_ROUND
  for (index_v = 0; index_v < *parameter_dimension; ++index_v) {
    if (fabs
        (parameter_lower_bound[index_v] - parameter_upper_bound[index_v]) <
        EPS_DOUBLE)
      continue;

    x = xloc[index_v];

    min_parameter_v = parameter_lower_bound[index_v];
    max_parameter_v = parameter_upper_bound[index_v];
    parameter_range_v = max_parameter_v - min_parameter_v;

    /* Handle discrete parameters. */
#if ASA_RESOLUTION
    xres = OPTIONS->Coarse_Resolution[index_v];
    if (xres > EPS_DOUBLE) {
      min_parameter_v -= (xres / 2.0);
      max_parameter_v += (xres / 2.0);
      parameter_range_v = max_parameter_v - min_parameter_v;
    }
#endif /* ASA_RESOLUTION */
    if (parameter_int_real[index_v] > 0) {
#if ASA_RESOLUTION
      if (xres > EPS_DOUBLE) {
        ;
      } else {
#endif /* ASA_RESOLUTION */
        min_parameter_v -= 0.5;
        max_parameter_v += 0.5;
        parameter_range_v = max_parameter_v - min_parameter_v;
      }
#if ASA_RESOLUTION
    }
#endif
#if ASA_RESOLUTION
    if (xres > EPS_DOUBLE) {
      xint = xres * (double) ((LONG_INT) (x / xres));
      xplus = xint + xres;
      xminus = xint - xres;
      dx = fabs (xint - x);
      dxminus = fabs (xminus - x);
      dxplus = fabs (xplus - x);

      if (dx < dxminus && dx < dxplus)
        x = xint;
      else if (dxminus < dxplus)
        x = xminus;
      else
        x = xplus;
    }
#endif /* ASA_RESOLUTION */

    /* Handle discrete parameters.
       You might have to check rounding on your machine. */
    if (parameter_int_real[index_v] > 0) {
#if ASA_RESOLUTION
      if (xres > EPS_DOUBLE) {
        ;
      } else {
#endif /* ASA_RESOLUTION */
        if (x < min_parameter_v + 0.5)
          x = min_parameter_v + 0.5 + (double) EPS_DOUBLE;
        if (x > max_parameter_v - 0.5)
          x = max_parameter_v - 0.5 + (double) EPS_DOUBLE;

        if (x + 0.5 > 0.0) {
          x = (double) ((LONG_INT) (x + 0.5));
        } else {
          x = (double) ((LONG_INT) (x - 0.5));
        }
        if (x > parameter_upper_bound[index_v])
          x = parameter_upper_bound[index_v];
        if (x < parameter_lower_bound[index_v])
          x = parameter_lower_bound[index_v];
      }
#if ASA_RESOLUTION
    }
    if (xres > EPS_DOUBLE) {
      if (x < min_parameter_v + xres / 2.0)
        x = min_parameter_v + xres / 2.0 + (double) EPS_DOUBLE;
      if (x > max_parameter_v - xres / 2.0)
        x = max_parameter_v - xres / 2.0 + (double) EPS_DOUBLE;

      if (x > parameter_upper_bound[index_v])
        x = parameter_upper_bound[index_v];
      if (x < parameter_lower_bound[index_v])
        x = parameter_lower_bound[index_v];
    }
#endif /* ASA_RESOLUTION */
    if ((x < parameter_lower_bound[index_v])
        || (x > parameter_upper_bound[index_v])) {
      bndflg = 1;
#if FITLOC_PRINT
      if (OPTIONS->Fit_Local == 2)
        fprintf (ptr_out, "IGNORE FITLOC: OUT OF BOUNDS xloc[%ld] = %g\n",
                 index_v, xloc[index_v]);
      else
        fprintf (ptr_out, "OUT OF BOUNDS xloc[%ld] = %g\n",
                 index_v, xloc[index_v]);
      fflush (ptr_out);
#else
      ;
#endif /* FITLOC_PRINT */
    } else {
      xloc[index_v] = x;
    }
  }
#endif /* FITLOC_ROUND */

  floc = user_cost_function (xloc,
                             parameter_lower_bound,
                             parameter_upper_bound,
                             cost_tangents,
                             cost_curvature,
                             parameter_dimension,
                             parameter_int_real,
                             cost_flag, exit_code, OPTIONS);

  if (fabs (floc - fsave) < (double) EPS_DOUBLE) {
    locflg = 1;
    ffinal = fsave;
#if FITLOC_PRINT
    fprintf (ptr_out, "\nsame global cost = %g\tlocal cost = %g\n\n",
             fsave, floc);
    fflush (ptr_out);
#endif /* FITLOC_PRINT */
  } else {
    if (floc < fsave) {
      if (OPTIONS->Fit_Local == 2 && bndflg == 1) {
        locflg = 1;
        ffinal = fsave;
      } else {
        locflg = 0;
        ffinal = floc;
      }
    } else {
      locflg = 1;
      ffinal = fsave;
    }
#if FITLOC_PRINT
    fprintf (ptr_out, "\nDIFF global cost = %g\tlocal cost = %g\n\n",
             fsave, floc);
    fflush (ptr_out);
#endif /* FITLOC_PRINT */
  }

  for (index_v = 0; index_v < *parameter_dimension; ++index_v) {
    if (fabs (xloc[index_v] - xsave[index_v]) < (double) EPS_DOUBLE) {
#if FITLOC_PRINT
      fprintf (ptr_out, "same global param[%ld] = %g\tlocal param = %g\n",
               index_v, xsave[index_v], xloc[index_v]);
      fflush (ptr_out);
#else
      ;
#endif /* FITLOC_PRINT */
    } else {
#if FITLOC_PRINT
      fprintf (ptr_out, "DIFF global param[%ld] = %g\tlocal param = %g\n",
               index_v, xsave[index_v], xloc[index_v]);
      fflush (ptr_out);
#else
      ;
#endif /* FITLOC_PRINT */
      if (locflg == 1) {
        xloc[index_v] = xsave[index_v];
      }
    }
  }

#if FITLOC_PRINT
  fprintf (ptr_out, "\n");
  fflush (ptr_out);
#endif /* FITLOC_PRINT */

  free (xsave);

  return (ffinal);
}

/*
   Written by Mark Johnson <mjohnson@netcom.com>, based on 

   %A J.A. Nelder
   %A R. Mead
   %T A simplex method for function minimization
   %J Computer J. (UK)
   %V 7
   %D 1964
   %P 308-313

   with improvements from

   %A G.P. Barabino
   %A G.S. Barabino
   %A B. Bianco
   %A M. Marchesi
   %T A study on the performances of simplex methods for function minimization
   %B Proc. IEEE Int. Conf. Circuits and Computers
   %D 1980
   %P 1150-1153

   adapted for use in ASA by Lester Ingber <ingber@ingber.com>
 */

#if HAVE_ANSI
int
simplex (double (*user_cost_function)

          
         (double *, double *, double *, double *, double *, ALLOC_INT *,
          int *, int *, int *, USER_DEFINES *), double *x,
         double *parameter_lower_bound, double *parameter_upper_bound,
         double *cost_tangents, double *cost_curvature,
         ALLOC_INT * parameter_dimension, int *parameter_int_real,
         int *cost_flag, int *exit_code, USER_DEFINES * OPTIONS,
         FILE * ptr_out, double tol1, double tol2, int no_progress,
         double alpha, double beta1, double beta2, double gamma, double delta)
#else
int
simplex (user_cost_function,
         x,
         parameter_lower_bound,
         parameter_upper_bound,
         cost_tangents,
         cost_curvature,
         parameter_dimension,
         parameter_int_real,
         cost_flag,
         exit_code,
         OPTIONS,
         ptr_out, tol1, tol2, no_progress, alpha, beta1, beta2, gamma, delta)
     double (*user_cost_function) ();
     double *x;
     double *parameter_lower_bound;
     double *parameter_upper_bound;
     double *cost_tangents;
     double *cost_curvature;
     ALLOC_INT *parameter_dimension;
     int *parameter_int_real;
     int *cost_flag;
     int *exit_code;
     USER_DEFINES *OPTIONS;
     FILE *ptr_out;
     double tol1;
     double tol2;
     int no_progress;
     double alpha;
     double beta1;
     double beta2;
     double gamma;
     double delta;
#endif
{
  double fs, fl, fh, fr, fe, fc1, fc2, ftmp, flast;
  double err1;
  double *fvals;
  double **splx;                /* the simplex of points */
  double *x0;                   /* centroid of simplex */
  double *xr;                   /* point for a reflection */
  double *xe;                   /* point for an expansion */
  double *xc1;                  /* point for a minor contraction */
  double *xc2;                  /* point for a major contraction */
  int s, l, h;
  int i, j, iters, futility;
  int lastprint;

  fvals = (double *) calloc (*parameter_dimension + 1, sizeof (double));
  splx = (double **) calloc (*parameter_dimension + 1, sizeof (double *));
  for (i = 0; i <= *parameter_dimension; i++)
    splx[i] = (double *) calloc (*parameter_dimension, sizeof (double));
  x0 = (double *) calloc (*parameter_dimension, sizeof (double));
  xr = (double *) calloc (*parameter_dimension, sizeof (double));
  xe = (double *) calloc (*parameter_dimension, sizeof (double));
  xc1 = (double *) calloc (*parameter_dimension, sizeof (double));
  xc2 = (double *) calloc (*parameter_dimension, sizeof (double));

  /* build the initial simplex */
  for (i = 0; i < *parameter_dimension; i++) {
    splx[0][i] = x[i];
  }
  for (i = 1; i <= *parameter_dimension; i++) {
    for (j = 0; j < *parameter_dimension; j++) {
      if ((j + 1) == i)
        splx[i][j] = (x[j] * 2.25) + tol2;
      else
        splx[i][j] = x[j];
      xr[j] = splx[i][j];
    }
    fvals[i] = calcf (user_cost_function,
                      xr,
                      parameter_lower_bound,
                      parameter_upper_bound,
                      cost_tangents,
                      cost_curvature,
                      parameter_dimension,
                      parameter_int_real,
                      cost_flag, exit_code, OPTIONS, ptr_out);
  }

  /* and of course compute function at starting point */
  fvals[0] = calcf (user_cost_function,
                    x,
                    parameter_lower_bound,
                    parameter_upper_bound,
                    cost_tangents,
                    cost_curvature,
                    parameter_dimension,
                    parameter_int_real,
                    cost_flag, exit_code, OPTIONS, ptr_out);

  /* now find the largest, 2nd largest, smallest f values */
  if (fvals[0] > fvals[1]) {
    h = 0;
    s = 1;
    l = 1;
  } else {
    h = 1;
    s = 0;
    l = 0;
  }
  fh = fvals[h];
  fs = fvals[s];
  fl = fvals[l];
  for (i = 2; i <= *parameter_dimension; i++) {
    if (fvals[i] <= fvals[l]) {
      l = i;
      fl = fvals[i];
    } else {
      if (fvals[i] >= fvals[h]) {
        s = h;
        fs = fh;
        h = i;
        fh = fvals[i];
      } else if (fvals[i] >= fvals[s]) {
        s = i;
        fs = fvals[i];
      }
    }
  }
#if FITLOC_PRINT
  if ((s == h) || (s == l) || (h == l))
    fprintf (ptr_out, "\nPANIC: s,l,h not unique %d %d %d\n", s, h, l);

  fprintf (ptr_out, "INITIAL SIMPLEX:\n");
  for (i = 0; i <= *parameter_dimension; i++) {
    for (j = 0; j < *parameter_dimension; j++) {
      fprintf (ptr_out, "   %11.4g", splx[i][j]);
    }
    fprintf (ptr_out, "      f = %12.5g", fvals[i]);
    if (i == h)
      fprintf (ptr_out, "  HIGHEST");
    if (i == s)
      fprintf (ptr_out, "  SECOND HIGHEST");
    if (i == l)
      fprintf (ptr_out, "  LOWEST");
    fprintf (ptr_out, "\n");
  }
  fflush (ptr_out);
#endif /* FITLOC_PRINT */

/* MAJOR LOOP */

  flast = fl;
  futility = 0;
  lastprint = 0;
  iters = 0;
  err1 = 1.1 + (1.1 * tol1);
  while ((err1 > tol1) && (iters < OPTIONS->Iter_Max) &&
         (futility < (*parameter_dimension * no_progress))) {
    iters++;

    /* now find the largest, 2nd largest, smallest f values */
    if (fvals[0] > fvals[1]) {
      h = 0;
      s = 1;
      l = 1;
    } else {
      h = 1;
      s = 0;
      l = 0;
    }
    fh = fvals[h];
    fs = fvals[s];
    fl = fvals[l];
    for (i = 2; i <= *parameter_dimension; i++) {
      if (fvals[i] <= fvals[l]) {
        l = i;
        fl = fvals[i];
      } else {
        if (fvals[i] >= fvals[h]) {
          s = h;
          fs = fh;
          h = i;
          fh = fvals[i];
        } else if (fvals[i] >= fvals[s]) {
          s = i;
          fs = fvals[i];
        }
      }
    }
#if FITLOC_PRINT
    if ((s == h) || (s == l) || (h == l))
      fprintf (ptr_out, "\nPANIC: s,l,h not unique %d %d %d\n", s, h, l);
    fflush (ptr_out);
#endif

    /* compute the centroid */
    for (j = 0; j < *parameter_dimension; j++) {
      x0[j] = 0.0;
      for (i = 0; i <= *parameter_dimension; i++) {
        if (i != h)
          x0[j] += splx[i][j];
      }
      x0[j] /= ((double) *parameter_dimension);
    }

    if (fl < flast) {
      flast = fl;
      futility = 0;
    } else
      futility += 1;

#if FITLOC_PRINT
    fprintf (ptr_out, "Iteration %3d f(best) = %12.6g halt? = %11.5g\n",
             iters, fl, err1);
    if ((iters - lastprint) >= 100) {
      fprintf (ptr_out, "\n     Best point seen so far:\n");
      for (i = 0; i < *parameter_dimension; i++) {
        fprintf (ptr_out, "     x[%3d] = %15.7g\n", i, splx[l][i]);
      }
      lastprint = iters;
      fprintf (ptr_out, "\n");
    }
    fflush (ptr_out);
#endif /* FITLOC_PRINT */

    /* STEP 1: compute a reflected point xr */
    for (i = 0; i < *parameter_dimension; i++) {
      xr[i] = ((1.0 + alpha) * x0[i]) - (alpha * splx[h][i]);
    }
    fr = calcf (user_cost_function,
                xr,
                parameter_lower_bound,
                parameter_upper_bound,
                cost_tangents,
                cost_curvature,
                parameter_dimension,
                parameter_int_real, cost_flag, exit_code, OPTIONS, ptr_out);

    /* typical: <2nd-biggest , >lowest .  Go again */
    if ((fr < fs) && (fr > fl)) {
      for (i = 0; i < *parameter_dimension; i++) {
        splx[h][i] = xr[i];
      }
      fvals[h] = fr;
      goto MORE_ITERS_asa_usr;
    }

    /* STEP 2: if reflected point is favorable, expand the simplex */
    if (fr < fl) {
      for (i = 0; i < *parameter_dimension; i++) {
        xe[i] = (gamma * xr[i]) + ((1.0 - gamma) * x0[i]);
      }
      fe = calcf (user_cost_function,
                  xe,
                  parameter_lower_bound,
                  parameter_upper_bound,
                  cost_tangents,
                  cost_curvature,
                  parameter_dimension,
                  parameter_int_real, cost_flag, exit_code, OPTIONS, ptr_out);
      if (fe < fr) {            /* win big; expansion point tiny */
        for (i = 0; i < *parameter_dimension; i++) {
          splx[h][i] = xe[i];
        }
        fvals[h] = fh = fe;
      } else
        /* still ok; reflection point a winner */
      {
        for (i = 0; i < *parameter_dimension; i++) {
          splx[h][i] = xr[i];
        }
        fvals[h] = fh = fr;
      }
      goto MORE_ITERS_asa_usr;
    }

    /* STEP 3: if reflected point is unfavorable, contract simplex */
    if (fr > fs) {
      if (fr < fh) {            /* may as well replace highest pt */
        for (i = 0; i < *parameter_dimension; i++) {
          splx[h][i] = xr[i];
        }
        fvals[h] = fh = fr;
      }
      for (i = 0; i < *parameter_dimension; i++) {
        xc1[i] = (beta1 * xr[i]) + ((1.0 - beta1) * x0[i]);
      }
      fc1 = calcf (user_cost_function,
                   xc1,
                   parameter_lower_bound,
                   parameter_upper_bound,
                   cost_tangents,
                   cost_curvature,
                   parameter_dimension,
                   parameter_int_real,
                   cost_flag, exit_code, OPTIONS, ptr_out);
      if (fc1 < fh) {           /* slight contraction worked */
        for (i = 0; i < *parameter_dimension; i++) {
          splx[h][i] = xc1[i];
        }
        fvals[h] = fh = fc1;
        goto MORE_ITERS_asa_usr;
      }
      /* now have to try strong contraction */
      for (i = 0; i < *parameter_dimension; i++) {
        xc2[i] = (beta2 * splx[h][i]) + ((1.0 - beta2) * x0[i]);
      }
      fc2 = calcf (user_cost_function,
                   xc2,
                   parameter_lower_bound,
                   parameter_upper_bound,
                   cost_tangents,
                   cost_curvature,
                   parameter_dimension,
                   parameter_int_real,
                   cost_flag, exit_code, OPTIONS, ptr_out);
      if (fc2 < fh) {           /* strong contraction worked */
        for (i = 0; i < *parameter_dimension; i++) {
          splx[h][i] = xc2[i];
        }
        fvals[h] = fh = fc2;
        goto MORE_ITERS_asa_usr;
      }
    }

    /* STEP 4: nothing worked.  collapse the simplex around xl */
    for (i = 0; i <= *parameter_dimension; i++) {
      if (i != l) {
        for (j = 0; j < *parameter_dimension; j++) {
          splx[i][j] = (splx[i][j] + splx[l][j]) / delta;
          xr[j] = splx[i][j];
        }
        fvals[i] = calcf (user_cost_function,
                          xr,
                          parameter_lower_bound,
                          parameter_upper_bound,
                          cost_tangents,
                          cost_curvature,
                          parameter_dimension,
                          parameter_int_real,
                          cost_flag, exit_code, OPTIONS, ptr_out);
      }
    }

  MORE_ITERS_asa_usr:

    ftmp = 0.00;
    for (i = 0; i <= *parameter_dimension; i++) {
      ftmp += fvals[i];
    }
    ftmp /= ((double) (*parameter_dimension + 1));

    err1 = 0.00;
    for (i = 0; i <= *parameter_dimension; i++) {
      err1 += ((fvals[i] - ftmp) * (fvals[i] - ftmp));
    }
    err1 /= ((double) (*parameter_dimension + 1));
    err1 = sqrt (err1);
  }                             /* end of major while loop */

  /* find the smallest f value */
  l = 0;
  fl = fvals[0];
  for (i = 1; i <= *parameter_dimension; i++) {
    if (fvals[i] < fvals[l])
      l = i;
  }

  /* give it back to the user */
  for (i = 0; i < *parameter_dimension; i++) {
    x[i] = splx[l][i];
  }

  free (fvals);
  for (i = 0; i <= *parameter_dimension; i++)
    free (splx[i]);
  free (splx);
  free (x0);
  free (xr);
  free (xe);
  free (xc1);
  free (xc2);

  return (iters);
}
#else
#endif /* FITLOC */

#if ASA_TEMPLATE_SAMPLE

#if HAVE_ANSI
void
sample (FILE * ptr_out, FILE * ptr_asa)
#else
void
sample (ptr_out, ptr_asa)
     FILE *ptr_out;
     FILE *ptr_asa;
#endif
{
  int fscanf_ret;
  int ind, n_samples, n_accept, index, dim;
  double cost, cost_temp, bias_accept;
  double param, temp, bias_gener, aver_weight, range;
  double sum, norm, answer, prod, binsize;
  char ch[80], sample[8];

  /*
     This is a demonstration of using ASA_SAMPLE to perform the double integral
     of exp(-x^2 - y^2) for x and y between 0 and 2.  The mesh is quite crude.

     The temperature-dependent acceptance and generated biases factor are
     divided out, and the actual cost function weights each point.
   */

  dim = 2;
  norm = sum = 0.;
  n_samples = 0;

  fprintf (ptr_out,
           ":SAMPLE:   n_accept   cost        cost_temp    bias_accept    aver_weight\n");
  fprintf (ptr_out,
           ":SAMPLE:   index      param[]     temp[]       bias_gener[]   range[]\n");
  for (;;) {
    fscanf_ret = fscanf (ptr_asa, "%s", ch);
    if (!strcmp (ch, "exit_status")) {
      break;
    }
    if (strcmp (ch, ":SAMPLE#")) {
      continue;
    }
    ++n_samples;
    fprintf (ptr_out, "%s\n", ch);
    fflush (ptr_out);
    fscanf_ret = fscanf (ptr_asa, "%s%d%lf%lf%lf%lf",
                         sample, &n_accept, &cost, &cost_temp, &bias_accept,
                         &aver_weight);
    if (strcmp (sample, ":SAMPLE+")) {
      fprintf (ptr_out, "%s %11d %12.7g %12.7g %12.7g %12.7g\n",
               sample, n_accept, cost, cost_temp, bias_accept, aver_weight);
    } else {
      fprintf (ptr_out, "%s %10d %12.7g %12.7g %12.7g %12.7g\n",
               sample, n_accept, cost, cost_temp, bias_accept, aver_weight);
    }
    prod = bias_accept;
    binsize = 1.0;
    for (ind = 0; ind < dim; ++ind) {
      fscanf_ret = fscanf (ptr_asa, "%s%d%lf%lf%lf%lf",
                           sample, &index, &param, &temp, &bias_gener,
                           &range);
      fprintf (ptr_out, "%s %11d %12.7g %12.7g %12.7g %12.7g\n", sample,
               index, param, temp, bias_gener, range);
      prod *= bias_gener;
      binsize *= range;
    }
    /* In this example, retrieve integrand from sampling function */
    sum += ((F_EXP (-cost) * binsize) / prod);
    norm += (binsize / prod);
  }
  sum /= norm;

  answer = 1.0;
  for (ind = 0; ind < dim; ++ind) {
    answer *= (0.5 * sqrt (3.14159265) * erf (2.0));
  }

  fprintf (ptr_out, "\n");
  fprintf (ptr_out, "sum = %12.7g, answer = %12.7g\n", sum, answer);
  fprintf (ptr_out, "n_samples = %d, norm = %12.7g\n", n_samples, norm);
  fflush (ptr_out);

}
#endif /* ASA_TEMPLATE_SAMPLE */
#if ASA_TEMPLATE_LIB
int
main ()
{
  double main_cost_value;
  double *main_cost_parameters;
  int main_exit_code;
  LONG_INT number_params;
  ALLOC_INT n_param;
  FILE *ptr_main;

#if INCL_STDOUT
  ptr_main = stdout;
#endif /* INCL_STDOUT */

  /* Note this assumes the *parameter_dimension = 4 */
  number_params = 4;

  if ((main_cost_parameters =
       (double *) calloc (number_params, sizeof (double))) == NULL) {
    strcpy (user_exit_msg, "ASA_TEMPLATE_LIB main(): main_cost_parameters");
    Exit_USER (user_exit_msg);
    return (-2);
  }

  asa_seed (696969);            /* This is the default random seed. */
  asa_main (&main_cost_value, main_cost_parameters, &main_exit_code);

  fprintf (ptr_main, "main_exit_code = %d\n", main_exit_code);
  fprintf (ptr_main, "main_cost_value = %12.7g\n", main_cost_value);
  fprintf (ptr_main, "parameter\tvalue\n");
  for (n_param = 0; n_param < number_params; ++n_param) {
    fprintf (ptr_main,
#if INT_ALLOC
             "%d\t\t%12.7g\n",
#else
#if INT_LONG
             "%ld\t\t%12.7g\n",
#else
             "%d\t\t%12.7g\n",
#endif
#endif
             n_param, main_cost_parameters[n_param]);
  }

  free (main_cost_parameters);

  return (0);
/* NOTREACHED */
}
#endif /* ASA_TEMPLATE_LIB */

#if ADAPTIVE_OPTIONS
/* examples of possible entries in asa_adaptive_options file
User_Quench_Param_Scale,1,0.7
User_Quench_Cost_Scale,0,0.85
Cost_Parameter_Scale_Ratio,1.2
*/
#if HAVE_ANSI
void
adaptive_options (USER_DEFINES * USER_OPTIONS)
#else
void
adaptive_options (USER_OPTIONS)
     USER_DEFINES *USER_OPTIONS;
#endif /* HAVE_ANSI */
{
  int ndum, ndim;
  long int ldum;
  double ddum;
  char cdum[80];
  char line[200];
  char delim[5];
  FILE *ptr_adaptive;

  /* initialize */
  ndim = ndum = 0;
  ldum = 0;
  ddum = 0;
  delim[0] = ',';
  delim[1] = '\n';
  delim[2] = '\0';

  if ((ptr_adaptive = fopen ("asa_adaptive_options", "r")) == NULL) {
    return;
  }

  while (fgets (line, 200, ptr_adaptive) != NULL) {
    strcpy (cdum, strtok (line, delim));

    if (!strcmp (cdum, "Limit_Acceptances")) {
      ldum = (long int) atoi (strtok (NULL, delim));
      USER_OPTIONS->Limit_Acceptances = ldum;
    } else if (!strcmp (cdum, "Limit_Generated")) {
      ldum = (long int) atoi (strtok (NULL, delim));
      USER_OPTIONS->Limit_Generated = ldum;
    } else if (!strcmp (cdum, "Limit_Invalid_Generated_States")) {
      ndum = (int) atoi (strtok (NULL, delim));
      USER_OPTIONS->Limit_Invalid_Generated_States = ndum;
    } else if (!strcmp (cdum, "Accepted_To_Generated_Ratio")) {
      ddum = (double) atof (strtok (NULL, delim));
      USER_OPTIONS->Accepted_To_Generated_Ratio = ddum;
    } else if (!strcmp (cdum, "Cost_Precision")) {
      ddum = (double) atof (strtok (NULL, delim));
      USER_OPTIONS->Cost_Precision = ddum;
    } else if (!strcmp (cdum, "Maximum_Cost_Repeat")) {
      ndum = (int) atoi (strtok (NULL, delim));
      USER_OPTIONS->Maximum_Cost_Repeat = ndum;
    } else if (!strcmp (cdum, "Temperature_Ratio_Scale")) {
      ddum = (double) atof (strtok (NULL, delim));
      USER_OPTIONS->Temperature_Ratio_Scale = ddum;
    } else if (!strcmp (cdum, "Cost_Parameter_Scale_Ratio")) {
      ddum = (double) atof (strtok (NULL, delim));
      USER_OPTIONS->Cost_Parameter_Scale_Ratio = ddum;
    } else if (!strcmp (cdum, "Temperature_Anneal_Scale")) {
      ddum = (double) atof (strtok (NULL, delim));
      USER_OPTIONS->Temperature_Anneal_Scale = ddum;
    }
#if RATIO_TEMPERATURE_SCALES
    else if (!strcmp (cdum, "User_Temperature_Ratio")) {
      ndim = (int) atoi (strtok (NULL, delim));
      ddum = (double) atof (strtok (NULL, delim));
      USER_OPTIONS->User_Temperature_Ratio[ndim] = ddum;
    }
#endif
    else if (!strcmp (cdum, "Acceptance_Frequency_Modulus")) {
      ndum = (int) atoi (strtok (NULL, delim));
      USER_OPTIONS->Acceptance_Frequency_Modulus = ndum;
    } else if (!strcmp (cdum, "Generated_Frequency_Modulus")) {
      ndum = (int) atoi (strtok (NULL, delim));
      USER_OPTIONS->Generated_Frequency_Modulus = ndum;
    }
#if QUENCH_PARAMETERS
    else if (!strcmp (cdum, "User_Quench_Param_Scale")) {
      ndim = (int) atoi (strtok (NULL, delim));
      ddum = (double) atof (strtok (NULL, delim));
      USER_OPTIONS->User_Quench_Param_Scale[ndim] = ddum;
    }
#endif
#if QUENCH_COST
    else if (!strcmp (cdum, "User_Quench_Cost_Scale")) {
      ndim = (int) atoi (strtok (NULL, delim));
      ddum = (double) atof (strtok (NULL, delim));
      USER_OPTIONS->User_Quench_Cost_Scale[ndim] = ddum;
    }
#endif
    else if (!strcmp (cdum, "N_Accepted")) {
      ldum = (long int) atoi (strtok (NULL, delim));
      USER_OPTIONS->N_Accepted = ldum;
    } else if (!strcmp (cdum, "N_Generated")) {
      ldum = (long int) atoi (strtok (NULL, delim));
      USER_OPTIONS->N_Generated = ldum;
    }
  }
  fclose (ptr_adaptive);

  return;
}
#endif /* ADAPTIVE_OPTIONS */

#if ASA_FUZZY

/* This code is taken from
 * https://sites.google.com/site/stochasticglobaloptimization/home/fuzzy-asa
 * courtesy of the developer Hime Junior <hime@engineer.com> */

/* N.b.: Important parameters have been made adaptive within USER_OPTIONS,
 * but there are also eight define parameters below also can be changed */

/*
    As USER_OPTIONS->NoOfSamples regulates the size of arrays storing data about some best values found recently, 
    the user can freely change it. Please, notice that values higher than 100 or lower than 5, for instance, 
    could cause problems to the fuzzy controller's "reasoning".
*/

/* Initialization of fuzzy controller's data structures - should be called just before activations of asa() */
int
InitFuzzyASA (USER_DEFINES * USER_OPTIONS, ALLOC_INT NoOfDimensions)
{

  int index;

#if ASA_TEMPLATE
  USER_OPTIONS->NoOfSamples = 30;
  USER_OPTIONS->ThresholdDeviation = 0.5E-4;
  USER_OPTIONS->Threshold1 = -0.0001;
  USER_OPTIONS->Performance_Target = 0.1;
  USER_OPTIONS->Factor_a = 2;

#endif
  /* defaults */
  USER_OPTIONS->NoOfSamples = 30;
  USER_OPTIONS->ThresholdDeviation = 0.5E-4;
  USER_OPTIONS->Threshold1 = -0.0001;
  USER_OPTIONS->Performance_Target = 0.1;
  USER_OPTIONS->Factor_a = 2;

  ValMinLoc = log (1 / (1 + exp (-USER_OPTIONS->Factor_a)));

  if ((FuzzyValues =
       (double *) calloc (USER_OPTIONS->NoOfSamples + 1,
                          sizeof (double))) == NULL) {
    strcpy (user_exit_msg, "InitFuzzyASA: FuzzyValues");
    Exit_USER (user_exit_msg);
    return (-2);
  }
  if ((FuzzyMinima =
       (double *) calloc (USER_OPTIONS->NoOfSamples + 1,
                          sizeof (double))) == NULL) {
    strcpy (user_exit_msg, "InitFuzzyASA: FuzzyValues");
    Exit_USER (user_exit_msg);
    return (-2);
  }
  if ((auxV =
       (double *) calloc (USER_OPTIONS->NoOfSamples,
                          sizeof (double))) == NULL) {
    strcpy (user_exit_msg, "InitFuzzyASA: auxV");
    Exit_USER (user_exit_msg);
    return (-2);
  }

  if ((FuzzyParameters =
       (double **) calloc (USER_OPTIONS->NoOfSamples,
                           sizeof (double *))) == NULL) {
    strcpy (user_exit_msg, "InitFuzzyASA: *FuzzyParameters");
    Exit_USER (user_exit_msg);
    return (-2);
  }
  for (index = 0; index < USER_OPTIONS->NoOfSamples; ++index)
    if ((FuzzyParameters[index] =
         (double *) calloc (NoOfDimensions, sizeof (double))) == NULL) {
      strcpy (user_exit_msg, "InitFuzzyASA: FuzzyParameters");
      Exit_USER (user_exit_msg);
      return (-2);
    }

  return 0;
}

/* Release of fuzzy controller's data structures obtained previously - should be called just after returning of asa() */
void
CloseFuzzyASA (USER_DEFINES * USER_OPTIONS)
{

  int index;

  for (index = 0; index < USER_OPTIONS->NoOfSamples; ++index) {
    free (FuzzyParameters[index]);
  }
  free (FuzzyParameters);

  free (auxV);
  free (FuzzyMinima);
  free (FuzzyValues);
}

void
MeanAndDeviation (USER_DEFINES * USER_OPTIONS, double *Vector,
                  int NumberOfElements, double *Mean, double *Deviation)
{

  int i;
  double aux;

  *Mean = *Deviation = 0;

  for (i = 0; i < NumberOfElements; i++) {
    aux = Vector[i];
    *Mean += aux;
    *Deviation += aux * aux;
  }

  *Mean /= NumberOfElements;
  *Deviation /= NumberOfElements;
  *Deviation = *Deviation - (*Mean) * (*Mean);
  *Deviation = sqrt (fabs (*Deviation));
}

double
SubEnergy (USER_DEFINES * USER_OPTIONS, double InputValue, double Minimum)
{

  double valuhat, argulog;

  valuhat = InputValue - Minimum;
  argulog = 1 / (1 + exp (-(valuhat + USER_OPTIONS->Factor_a)));

  if (argulog == 0) {
    argulog = 1e-100;
  }

  return log (argulog);
}

double
DeltaFactor (USER_DEFINES * USER_OPTIONS, double MeanSub)
{
#define DELTATPOS       .3
#define DELTATNULO      0
#define DELTATNEG      -.3
#define INTER1          .1

  double MembershipMeanZero = 0;
  double MembershipMeanMedium = 0;
  double ResuCrisp;

/*
 RULE #1 - IF MeanSub is ZERO THEN decreasing rate is POSITIVE
 ( We are distant from present basic local minimum )
*/

  if (MeanSub > USER_OPTIONS->Threshold1) {
    MembershipMeanZero =
      (MeanSub - USER_OPTIONS->Threshold1) / (-USER_OPTIONS->Threshold1);
  }

/*
 RULE #2 - IF MeanSub is ValMinLoc ( FUZZY NUMBER )
                       THEN decreasing rate is POSITIVE
( We are in a region near the present basic local minimum )
*/

  if (MeanSub >= ValMinLoc && MeanSub <= ValMinLoc + INTER1) {
    MembershipMeanMedium = (ValMinLoc + INTER1 - MeanSub) / INTER1;
  }

  ResuCrisp =
    MembershipMeanZero * DELTATPOS + MembershipMeanMedium * DELTATPOS;

  return ResuCrisp;
}

void
AlterQuench (USER_DEFINES * USER_OPTIONS,
             int NoParam, double Mean, double Deviation)
{
#define Mult1 0.5
#define Mult2 0.2
#define Mult3 0.1
#define Mult4 0.15

  int i, j;
  double Delta, Meanaux, Deviationaux;

  Delta = DeltaFactor (USER_OPTIONS, Mean);
  if (USER_OPTIONS->User_Quench_Cost_Scale[0] < 100) {
    USER_OPTIONS->User_Quench_Cost_Scale[0] *= (1 + Mult1 * Delta);

#if ASA_FUZZY_PRINT
    /* give approximate asa_out location when ASA_FUZZY operates */
#if ASA_PARALLEL
#if INT_LONG
    fprintf (ptr_out,
             "ASA_FUZZY Cost Delta: parallel_id: %d N_Generated: %ld N_Accepted: %ld\n",
             USER_OPTIONS->parallel_id, USER_OPTIONS->N_Generated,
             USER_OPTIONS->N_Accepted);
#else
    fprintf (ptr_out,
             "ASA_FUZZY Cost Delta: parallel_id: %d N_Generated: %d N_Accepted: %d\n",
             USER_OPTIONS->parallel_id, USER_OPTIONS->N_Generated,
             USER_OPTIONS->N_Accepted);
#endif /* INT_LONG */
#else /* ASA_PARALLEL */
#if INT_LONG
    fprintf (ptr_out,
             "ASA_FUZZY Cost Delta: N_Generated: %ld N_Accepted: %ld\n",
             USER_OPTIONS->N_Generated, USER_OPTIONS->N_Accepted);
#else
    fprintf (ptr_out,
             "ASA_FUZZY Cost Delta: N_Generated: %d N_Accepted: %d\n",
             USER_OPTIONS->N_Generated, USER_OPTIONS->N_Accepted);
#endif /* INT_LONG */
#endif /* ASA_PARALLEL */
    fflush (ptr_out);
#endif /* ASA_FUZZY_PRINT */

  }

  for (i = 0; i < NoParam; i++) {
    if (USER_OPTIONS->User_Quench_Param_Scale[i] < 100) {
      USER_OPTIONS->User_Quench_Param_Scale[i] *= (1 + Mult2 * Delta);

#if ASA_FUZZY_PRINT
      /* give approximate asa_out location when ASA_FUZZY operates */
#if ASA_PARALLEL
#if INT_LONG
      fprintf (ptr_out,
               "ASA_FUZZY Param Delta: parallel_id: %d N_Generated: %ld N_Accepted: %ld\n",
               USER_OPTIONS->parallel_id, USER_OPTIONS->N_Generated,
               USER_OPTIONS->N_Accepted);
#else
      fprintf (ptr_out,
               "ASA_FUZZY Param Delta: parallel_id: %d N_Generated: %d N_Accepted: %d\n",
               USER_OPTIONS->parallel_id, USER_OPTIONS->N_Generated,
               USER_OPTIONS->N_Accepted);
#endif /* INT_LONG */
#else /* ASA_PARALLEL */
#if INT_LONG
      fprintf (ptr_out,
               "ASA_FUZZY Param Delta: N_Generated: %ld N_Accepted: %ld\n",
               USER_OPTIONS->N_Generated, USER_OPTIONS->N_Accepted);
#else
      fprintf (ptr_out,
               "ASA_FUZZY Param Delta: N_Generated: %d N_Accepted: %d\n",
               USER_OPTIONS->N_Generated, USER_OPTIONS->N_Accepted);
#endif /* INT_LONG */
#endif /* ASA_PARALLEL */
      fflush (ptr_out);
#endif /* ASA_FUZZY_PRINT */

    }
  }

  if (Deviation < USER_OPTIONS->ThresholdDeviation) {
    for (i = 0; i < NoParam; i++) {
      if (USER_OPTIONS->User_Quench_Param_Scale[i] < 100
          && USER_OPTIONS->User_Quench_Param_Scale[i] > Mult3) {
        for (j = 0; j < USER_OPTIONS->NoOfSamples; j++) {
          auxV[j] = FuzzyParameters[j][i];
        }

        MeanAndDeviation (USER_OPTIONS, auxV, USER_OPTIONS->NoOfSamples,
                          &Meanaux, &Deviationaux);
        USER_OPTIONS->User_Quench_Param_Scale[i] /= (1 + Mult4 * Delta *
                                                     exp (-Deviationaux));

#if ASA_FUZZY_PRINT
        /* give approximate asa_out location when ASA_FUZZY operates */
#if ASA_PARALLEL
#if INT_LONG
        fprintf (ptr_out,
                 "ASA_FUZZY Deviation: parallel_id: %d N_Generated: %ld N_Accepted: %ld\n",
                 USER_OPTIONS->parallel_id, USER_OPTIONS->N_Generated,
                 USER_OPTIONS->N_Accepted);
#else
        fprintf (ptr_out,
                 "ASA_FUZZY Deviation: parallel_id: %d N_Generated: %d N_Accepted: %d\n",
                 USER_OPTIONS->parallel_id, USER_OPTIONS->N_Generated,
                 USER_OPTIONS->N_Accepted);
#endif /* INT_LONG */
#else /* ASA_PARALLEL */
#if INT_LONG
        fprintf (ptr_out,
                 "ASA_FUZZY Deviation: N_Generated: %ld N_Accepted: %ld\n",
                 USER_OPTIONS->N_Generated, USER_OPTIONS->N_Accepted);
#else
        fprintf (ptr_out,
                 "ASA_FUZZY Deviation: N_Generated: %d N_Accepted: %d\n",
                 USER_OPTIONS->N_Generated, USER_OPTIONS->N_Accepted);
#endif /* INT_LONG */
#endif /* ASA_PARALLEL */
        fflush (ptr_out);
#endif /* ASA_FUZZY_PRINT */

      }
    }
  }

}

void
FuzzyControl (USER_DEFINES * USER_OPTIONS, double *x, double fvalue,
              ALLOC_INT dimensions)
{
  static double ActualPerformance, Mean, Deviation;
  static int IndVal = 0;
  int i, NoParam;

  IndVal++;
  NoParam = (int) dimensions;

  if (IndVal % (USER_OPTIONS->NoOfSamples + 1)) {
    FuzzyValues[IndVal] = fvalue;
    FuzzyMinima[IndVal] = *USER_OPTIONS->Best_Cost;

    for (i = 0; i < NoParam; i++) {
      FuzzyParameters[IndVal - 1][i] = USER_OPTIONS->Best_Parameters[i];        // Stores better results until now
    }

    return;
  }

  IndVal = 0;

  if (FuzzyMinima[1] != 0) {
    ActualPerformance =
      (FuzzyMinima[1] -
       FuzzyMinima[USER_OPTIONS->NoOfSamples]) / fabs (FuzzyMinima[1]);
  } else {
    return;
  }

  if (ActualPerformance > USER_OPTIONS->Performance_Target) {
    USER_OPTIONS->User_Quench_Cost_Scale[0] =
      ASA_FUZZY_Init_User_Quench_Cost_Scale[0];
    for (i = 0; i < NoParam; i++)
      USER_OPTIONS->User_Quench_Param_Scale[i] =
        ASA_FUZZY_Init_User_Quench_Param_Scale[i];

#if ASA_FUZZY_PRINT
    /* give approximate asa_out location when ASA_FUZZY operates */
#if ASA_PARALLEL
#if INT_LONG
    fprintf (ptr_out,
             "ASA_FUZZY reset: parallel_id: %d N_Generated: %ld N_Accepted: %ld\n",
             USER_OPTIONS->parallel_id, USER_OPTIONS->N_Generated,
             USER_OPTIONS->N_Accepted);
#else
    fprintf (ptr_out,
             "ASA_FUZZY reset: parallel_id: %d N_Generated: %d N_Accepted: %d\n",
             USER_OPTIONS->parallel_id, USER_OPTIONS->N_Generated,
             USER_OPTIONS->N_Accepted);
#endif /* INT_LONG */
#else /* ASA_PARALLEL */
#if INT_LONG
    fprintf (ptr_out, "ASA_FUZZY reset: N_Generated: %ld N_Accepted: %ld\n",
             USER_OPTIONS->N_Generated, USER_OPTIONS->N_Accepted);
#else
    fprintf (ptr_out, "ASA_FUZZY reset: N_Generated: %d N_Accepted: %d\n",
             USER_OPTIONS->N_Generated, USER_OPTIONS->N_Accepted);
#endif /* INT_LONG */
#endif /* ASA_PARALLEL */
    fflush (ptr_out);
#endif /* ASA_FUZZY_PRINT */

    return;
  }

  for (i = 0; i < USER_OPTIONS->NoOfSamples; i++) {
    auxV[i] = SubEnergy (USER_OPTIONS, FuzzyValues[i + 1], FuzzyMinima[i + 1]); // Zero based
  }

  MeanAndDeviation (USER_OPTIONS, auxV, USER_OPTIONS->NoOfSamples, &Mean,
                    &Deviation);
  AlterQuench (USER_OPTIONS, NoParam, Mean, Deviation);

  return;
}
#endif /* ASA_FUZZY */

void
Exit_USER (char *statement)
{
#if INCL_STDOUT
  printf ("\n\n*** EXIT calloc failed *** %s\n\n", statement);
#else
  ;
#endif /* INCL_STDOUT */
}
#ifndef _ASA_USER_H_
#define _ASA_USER_H_
#ifdef __cplusplus
extern "C" {
#endif

/***********************************************************************
* Adaptive Simulated Annealing (ASA)
* Lester Ingber <ingber@ingber.com>
* Copyright (c) 1987-2016 Lester Ingber.  All Rights Reserved.
* ASA-LICENSE file has the license that must be included with ASA code.
***********************************************************************/

  /* $Id: asa_usr.h,v 30.21 2016/02/02 15:49:43 ingber Exp ingber $ */

  /* asa_usr.h for Adaptive Simulated Annealing */

#include "asa_usr_asa.h"

#define SHUFFLE 256             /* size of random array */

#if ASA_TEMPLATE_ASA_OUT_PID
#include <sys/types.h>
#endif

#if TIME_CALC
  /* print the time every PRINT_FREQUENCY function evaluations
     Define PRINT_FREQUENCY to 0 to not print out the time. */
#define PRINT_FREQUENCY ((LONG_INT) 1000)
#endif

#if USER_ACCEPTANCE_TEST
#define MIN(x,y)	((x) < (y) ? (x) : (y))
#endif

  /* system function prototypes */

#if ASA_TEMPLATE_ASA_OUT_PID
  int getpid ();
#endif

#if HAVE_ANSI

/* This block gives trouble under some Ultrix */
#if FALSE
#if OPTIONS_FILE
  int fscanf (FILE * fp, char *string, ...);
#endif
#endif

#if IO_PROTOTYPES
#if OPTIONS_FILE
  int fscanf ();
#endif
#endif

  /* user-defined */
  double USER_COST_FUNCTION (double *cost_parameters,
                             double *parameter_lower_bound,
                             double *parameter_upper_bound,
                             double *cost_tangents,
                             double *cost_curvature,
                             ALLOC_INT * parameter_dimension,
                             int *parameter_int_real,
                             int *cost_flag,
                             int *exit_code, USER_DEFINES * USER_OPTIONS);
#if ASA_LIB
  int asa_main (
#if ASA_TEMPLATE_LIB
                 double *main_cost_value,
                 double *main_cost_parameters, int *main_exit_code
#endif                          /* ASA_TEMPLATE_LIB */
#if ASA_TEMPLATE
#if OPTIONAL_DATA_PTR
                 /* insert "," if previous parameters */
                 OPTIONAL_PTR_TYPE * OptionalPointer
#endif                          /* OPTIONAL_DATA_PTR */
#endif                          /* ASA_TEMPLATE */
    );
#else                           /* ASA_LIB */
  int main (int argc, char **argv);
#endif                          /* ASA_LIB */

#if ASA_TEMPLATE_LIB
  int main ();
#endif

  /* possibly with accompanying data file */
  int initialize_parameters (double *cost_parameters,
                             double *parameter_lower_bound,
                             double *parameter_upper_bound,
                             double *cost_tangents,
                             double *cost_curvature,
                             ALLOC_INT * parameter_dimension,
                             int *parameter_int_real,
#if OPTIONS_FILE_DATA
                             FILE * ptr_options,
#endif
                             USER_DEFINES * USER_OPTIONS);

#if ASA_LIB
  LONG_INT asa_seed (LONG_INT seed);
#endif
  double myrand (LONG_INT * rand_seed);
  double randflt (LONG_INT * rand_seed);
  double resettable_randflt (LONG_INT * rand_seed, int reset);

#if USER_COST_SCHEDULE
  double user_cost_schedule (double test_temperature,
                             const void *OPTIONS_TMP);
#endif

#if USER_ACCEPTANCE_TEST
  void user_acceptance_test (double current_cost,
                             double *parameter_lower_bound,
                             double *parameter_upper_bound,
                             ALLOC_INT * parameter_dimension,
                             const void *OPTIONS_TMP);
#endif

#if USER_GENERATING_FUNCTION
  double user_generating_distrib (LONG_INT * seed,
                                  ALLOC_INT * parameter_dimension,
                                  ALLOC_INT index_v,
                                  double temperature_v,
                                  double init_param_temp_v,
                                  double temp_scale_params_v,
                                  double parameter_v,
                                  double parameter_range_v,
                                  double *last_saved_parameter,
                                  const void *OPTIONS_TMP);

#endif

#if USER_REANNEAL_COST
  int user_reanneal_cost (double *cost_best,
                          double *cost_last,
                          double *initial_cost_temperature,
                          double *current_cost_temperature,
                          const void *OPTIONS_TMP);
#endif

#if USER_REANNEAL_PARAMETERS
  double user_reanneal_params (double current_temp,
                               double tangent,
                               double max_tangent, const void *OPTIONS_TMP);
#endif

#if ASA_TEMPLATE_SAMPLE
  void sample (FILE * ptr_out, FILE * ptr_asa);
#endif

  void Exit_USER (char *statement);

#else                           /* HAVE_ANSI */

#if IO_PROTOTYPES
#if OPTIONS_FILE
  int fscanf ();
#endif
#endif

/* user-defined */
  double USER_COST_FUNCTION ();
#if ASA_LIB
  int asa_main ();
#else                           /* ASA_LIB */
  int main ();
#endif                          /* ASA_LIB */

#if ASA_TEMPLATE_LIB
  int main ();
#endif

  int initialize_parameters (); /* possibly with accompanying
                                   data file */
#if ASA_LIB
  LONG_INT asa_seed ();
#endif
  double myrand ();
  double randflt ();
  double resettable_randflt ();

#if USER_COST_SCHEDULE
  double user_cost_schedule ();
#endif

#if USER_ACCEPTANCE_TEST
  void user_acceptance_test ();
#endif

#if USER_GENERATING_FUNCTION
  double user_generating_distrib ();
#endif

#if USER_REANNEAL_COST
  int user_reanneal_cost ();
#endif

#if USER_REANNEAL_PARAMETERS
  double user_reanneal_params ();
#endif

#if ASA_TEMPLATE_SAMPLE
  void sample ();
#endif

  void Exit_USER ();

#endif                          /* HAVE_ANSI */

#if SELF_OPTIMIZE
#if TIME_CALC
#define RECUR_PRINT_FREQUENCY ((LONG_INT) 1)
#endif

#if HAVE_ANSI                   /* HAVE_ANSI SELF_OPTIMIZE */
  double RECUR_USER_COST_FUNCTION (double *recur_cost_parameters,
                                   double *recur_parameter_lower_bound,
                                   double *recur_parameter_upper_bound,
                                   double *recur_cost_tangents,
                                   double *recur_cost_curvature,
                                   ALLOC_INT * recur_parameter_dimension,
                                   int *recur_parameter_int_real,
                                   int *recur_cost_flag,
                                   int *recur_exit_code,
                                   USER_DEFINES * RECUR_USER_OPTIONS);

  int recur_initialize_parameters (double *recur_cost_parameters,
                                   double *recur_parameter_lower_bound,
                                   double *recur_parameter_upper_bound,
                                   double *recur_cost_tangents,
                                   double *recur_cost_curvature,
                                   ALLOC_INT * recur_parameter_dimension,
                                   int *recur_parameter_int_real,
#if RECUR_OPTIONS_FILE_DATA
                                   FILE * recur_ptr_options,
#endif
                                   USER_DEFINES * RECUR_USER_OPTIONS);

#if USER_COST_SCHEDULE
  double recur_user_cost_schedule (double test_temperature,
                                   const void *OPTIONS_TMP);
#endif

#if USER_ACCEPTANCE_TEST
  void recur_user_acceptance_test (double current_cost,
                                   double *recur_parameter_lower_bound,
                                   double *recur_parameter_upper_bound,
                                   ALLOC_INT * recur_parameter_dimension,
                                   const void *OPTIONS_TMP);
#endif

#if USER_GENERATING_FUNCTION
  double recur_user_generating_distrib (LONG_INT * seed,
                                        ALLOC_INT * recur_parameter_dimension,
                                        ALLOC_INT index_v,
                                        double temperature_v,
                                        double init_param_temp_v,
                                        double temp_scale_params_v,
                                        double parameter_v,
                                        double parameter_range_v,
                                        double *last_saved_parameter,
                                        const void *OPTIONS_TMP);
#endif

#if USER_REANNEAL_COST
  int recur_user_reanneal_cost (double *cost_best,
                                double *cost_last,
                                double *initial_cost_temperature,
                                double *current_cost_temperature,
                                const void *OPTIONS_TMP);
#endif

#if USER_REANNEAL_PARAMETERS
  double recur_user_reanneal_params (double current_temp,
                                     double tangent,
                                     double max_tangent,
                                     const void *OPTIONS_TMP);
#endif

#else                           /* HAVE_ANSI SELF_OPTIMIZE */

  double RECUR_USER_COST_FUNCTION ();
  int recur_initialize_parameters ();

#if USER_COST_SCHEDULE
  double recur_user_cost_schedule ();
#endif

#if USER_ACCEPTANCE_TEST
  void recur_user_acceptance_test ();
#endif

#if USER_GENERATING_FUNCTION
  double recur_user_generating_distrib ();
#endif

#if USER_REANNEAL_COST
  int recur_user_reanneal_cost ();
#endif

#if USER_REANNEAL_PARAMETERS
  double recur_user_reanneal_params ();
#endif

#endif                          /* HAVE_ANSI */
#endif                          /* SELF_OPTIMIZE */

#if ADAPTIVE_OPTIONS
#if HAVE_ANSI
  void adaptive_options (USER_DEFINES * USER_OPTIONS);
#else
  void adaptive_options ();
#endif                          /* HAVE_ANSI */
#endif                          /* ADAPTIVE_OPTIONS */

#if FITLOC
#if HAVE_ANSI
  double
    calcf (double (*user_cost_function)

            
           (double *, double *, double *, double *, double *, ALLOC_INT *,
            int *, int *, int *, USER_DEFINES *), double *cost_parameters,
           double *parameter_lower_bound, double *parameter_upper_bound,
           double *cost_tangents, double *cost_curvature,
           ALLOC_INT * parameter_dimension, int *parameter_int_real,
           int *cost_flag, int *exit_code, USER_DEFINES * USER_OPTIONS,
           FILE * ptr_out);

  double
    fitloc (double (*user_cost_function)

             
            (double *, double *, double *, double *, double *, ALLOC_INT *,
             int *, int *, int *, USER_DEFINES *), double *cost_parameters,
            double *parameter_lower_bound, double *parameter_upper_bound,
            double *cost_tangents, double *cost_curvature,
            ALLOC_INT * parameter_dimension, int *parameter_int_real,
            int *cost_flag, int *exit_code, USER_DEFINES * USER_OPTIONS,
            FILE * ptr_out);

  int
    simplex (double (*user_cost_function)

              
             (double *, double *, double *, double *, double *, ALLOC_INT *,
              int *, int *, int *, USER_DEFINES *), double *cost_parameters,
             double *parameter_lower_bound, double *parameter_upper_bound,
             double *cost_tangents, double *cost_curvature,
             ALLOC_INT * parameter_dimension, int *parameter_int_real,
             int *cost_flag, int *exit_code, USER_DEFINES * USER_OPTIONS,
             FILE * ptr_out, double tol1, double tol2, int no_progress,
             double alpha, double beta1, double beta2, double gamma,
             double delta);
#else                           /* HAVE_ANSI */

  double calcf ();
  double fitloc ();
  int simplex ();

#endif                          /* HAVE_ANSI */
#endif                          /* FITLOC */

#if ASA_FUZZY
  double *ASA_FUZZY_Init_User_Quench_Param_Scale;
  double *ASA_FUZZY_Init_User_Quench_Cost_Scale;

  int InitFuzzyASA (USER_DEFINES * USER_OPTIONS, ALLOC_INT NoOfDimensions);
  void CloseFuzzyASA (USER_DEFINES * USER_OPTIONS);
  void MeanAndDeviation (USER_DEFINES * USER_OPTIONS, double *Vector,
                         int NumberOfElements, double *Mean,
                         double *Deviation);
  double SubEnergy (USER_DEFINES * USER_OPTIONS, double InputValue,
                    double Minimum);
  double DeltaFactor (USER_DEFINES * USER_OPTIONS, double MeanSub);
  void AlterQuench (USER_DEFINES * USER_OPTIONS, int NoParam,
                    double Mean, double Deviation);
  void FuzzyControl (USER_DEFINES * USER_OPTIONS, double *x, double fvalue,
                     ALLOC_INT dimensions);
#endif                          /* ASA_FUZZY */

#ifdef __cplusplus
}
#endif
#endif                          /* _ASA_USER_H_ */
#ifndef _ASA_USER_ASA_H_
#define _ASA_USER_ASA_H_
#ifdef __cplusplus
extern "C" {
#endif

/***********************************************************************
* Adaptive Simulated Annealing (ASA)
* Lester Ingber <ingber@ingber.com>
* Copyright (c) 1987-2016 Lester Ingber.  All Rights Reserved.
* ASA-LICENSE file has the license that must be included with ASA code.
***********************************************************************/

  /* $Id: asa_usr_asa.h,v 30.21 2016/02/02 15:49:45 ingber Exp ingber $ */

  /* asa_usr_asa.h for Adaptive Simulated Annealing */

#include <errno.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>             /* misc defs on most machines */
#include <string.h>

/* required if use machine-defined {DBL_EPSILON DBL_MIN DBL_MAX} */
/* #include <float.h> */

#define	TRUE			1
#define	FALSE			0

#define MIN(x,y)	((x) < (y) ? (x) : (y))
#define MAX(x,y)	((x) > (y) ? (x) : (y))

  /* DEFAULT PARAMETERS SETTINGS */

  /* Pre-Compile Options */

  /* Special ASA_TEMPLATEs */

#ifndef MY_TEMPLATE
#define MY_TEMPLATE TRUE
#endif
#if MY_TEMPLATE                 /* MY_TEMPLATE_asa_user */
  /* you can add your own set of #define here */
#endif                          /* MY_TEMPLATE */

#ifndef ASA_TEMPLATE_LIB
#define ASA_TEMPLATE_LIB FALSE
#endif
#if ASA_TEMPLATE_LIB
#define ASA_LIB TRUE
#define ASA_TEST TRUE
#endif

#ifndef ASA_TEMPLATE_ASA_OUT_PID
#define ASA_TEMPLATE_ASA_OUT_PID FALSE
#endif
#if ASA_TEMPLATE_ASA_OUT_PID
#define USER_ASA_OUT TRUE
#endif

#ifndef ASA_TEMPLATE_MULTIPLE
#define ASA_TEMPLATE_MULTIPLE FALSE
#endif
#if ASA_TEMPLATE_MULTIPLE
#define COST_FILE FALSE
#define USER_ASA_OUT TRUE
#define ASA_TEST TRUE
#define QUENCH_COST TRUE
#define QUENCH_PARAMETERS TRUE
#define OPTIONS_FILE FALSE
#endif

#ifndef ASA_TEMPLATE_SELFOPT
#define ASA_TEMPLATE_SELFOPT FALSE
#endif
#if ASA_TEMPLATE_SELFOPT
#define COST_FILE FALSE
#define SELF_OPTIMIZE TRUE
#define OPTIONAL_DATA_DBL TRUE
#define USER_ASA_OUT TRUE
#define ASA_TEST TRUE
#define OPTIONS_FILE FALSE
#endif

#ifndef ASA_TEMPLATE_SAMPLE
#define ASA_TEMPLATE_SAMPLE FALSE
#endif
#if ASA_TEMPLATE_SAMPLE
#define COST_FILE FALSE
#define ASA_SAMPLE TRUE
#define USER_ACCEPTANCE_TEST TRUE
#define USER_COST_SCHEDULE TRUE
#define OPTIONS_FILE_DATA FALSE
#define USER_ACCEPT_ASYMP_EXP TRUE
#endif

#ifndef ASA_TEMPLATE_PARALLEL
#define ASA_TEMPLATE_PARALLEL FALSE
#endif
#if ASA_TEMPLATE_PARALLEL
#define COST_FILE FALSE
#define ASA_TEST TRUE
#define ASA_PARALLEL TRUE
#endif

#ifndef ASA_TEMPLATE_SAVE
#define ASA_TEMPLATE_SAVE FALSE
#endif
#if ASA_TEMPLATE_SAVE
#define COST_FILE FALSE
#define ASA_TEST TRUE
#define ASA_SAVE TRUE
#define QUENCH_PARAMETERS TRUE
#define QUENCH_COST TRUE
#endif

#ifndef ASA_TEMPLATE_QUEUE
#define ASA_TEMPLATE_QUEUE FALSE
#endif
#if ASA_TEMPLATE_QUEUE
#define ASA_QUEUE TRUE
#define ASA_RESOLUTION FALSE
#define ASA_TEST TRUE
#define COST_FILE FALSE
#define ASA_PRINT_MORE TRUE
#endif

#ifndef ASA_TEST_POINT
#define ASA_TEST_POINT FALSE
#endif
#if ASA_TEST_POINT
#define ASA_TEST TRUE
#define COST_FILE FALSE
#define SMALL_FLOAT 1.0E-50
#define QUENCH_COST TRUE
#endif

#ifndef ASA_EXIT_ANYTIME
#define ASA_EXIT_ANYTIME FALSE
#endif

#ifndef ADAPTIVE_OPTIONS
#define ADAPTIVE_OPTIONS FALSE
#endif

#ifndef ASA_FUZZY
#define ASA_FUZZY FALSE
#endif

#ifndef ASA_FUZZY_PRINT
#define ASA_FUZZY_PRINT FALSE
#endif

#if ASA_FUZZY
  /* defaults */
#if QUENCH_COST
#else
#define QUENCH_COST TRUE
#endif
#if QUENCH_PARAMETERS
#else
#define QUENCH_PARAMETERS TRUE
#endif
#endif

  /* Standard Pre-Compile Options */

#ifndef USER_COST_FUNCTION
#define USER_COST_FUNCTION cost_function
#endif

#if SELF_OPTIMIZE
#ifndef RECUR_USER_COST_FUNCTION
#define RECUR_USER_COST_FUNCTION recur_cost_function
#endif
#ifndef INCL_STDOUT
#define INCL_STDOUT FALSE
#endif
#endif

#ifndef INCL_STDOUT
#define INCL_STDOUT TRUE
#endif
#if INCL_STDOUT
#ifndef TIME_CALC
#define TIME_CALC FALSE
#endif
#endif

#ifndef OPTIONS_FILE
#define OPTIONS_FILE TRUE
#endif

#if OPTIONS_FILE
#ifndef OPTIONS_FILE_DATA
#define OPTIONS_FILE_DATA TRUE
#endif
#else
#define OPTIONS_FILE_DATA FALSE
#endif

#ifndef RECUR_OPTIONS_FILE
#define RECUR_OPTIONS_FILE FALSE
#endif

#if RECUR_OPTIONS_FILE
#ifndef RECUR_OPTIONS_FILE_DATA
#define RECUR_OPTIONS_FILE_DATA FALSE
#endif
#else
#define RECUR_OPTIONS_FILE_DATA FALSE
#endif

#ifndef COST_FILE
#define COST_FILE TRUE
#endif

#ifndef ASA_LIB
#define ASA_LIB FALSE
#endif

#ifndef HAVE_ANSI
#define HAVE_ANSI TRUE
#endif

#ifndef IO_PROTOTYPES
#define IO_PROTOTYPES FALSE
#endif

#ifndef TIME_CALC
#define TIME_CALC FALSE
#endif

#ifndef INT_LONG
#define INT_LONG TRUE
#endif

#if INT_LONG
#define LONG_INT long int
#else
#define LONG_INT int
#endif

#ifndef INT_ALLOC
#define INT_ALLOC FALSE
#endif

#if INT_ALLOC
#define ALLOC_INT int
#else
#define ALLOC_INT LONG_INT
#endif

  /* You can define SMALL_FLOAT to better correlate to your machine's
     precision, i.e., as used in asa */
#ifndef SMALL_FLOAT
#define SMALL_FLOAT 1.0E-18
/* #define SMALL_FLOAT MINFLOAT */
#endif

  /* You can define your machine's maximum and minimum doubles here */
#ifndef MIN_DOUBLE
#define MIN_DOUBLE ((double) SMALL_FLOAT)
/* #define MIN_DOUBLE MINDOUBLE */
#endif

#ifndef MAX_DOUBLE
#define MAX_DOUBLE ((double) 1.0 / (double) SMALL_FLOAT)
/* #define MIN_DOUBLE MINDOUBLE */
#endif

#ifndef EPS_DOUBLE
#define EPS_DOUBLE ((double) SMALL_FLOAT)
/* #define EPS_DOUBLE DBL_EPSILON */
#endif

#ifndef CHECK_EXPONENT
#define CHECK_EXPONENT FALSE
#endif

#ifndef ASA_TEST
#define ASA_TEST FALSE
#endif

#ifndef ASA_TEMPLATE
#define ASA_TEMPLATE FALSE
#endif

#ifndef USER_INITIAL_COST_TEMP
#define USER_INITIAL_COST_TEMP FALSE
#endif

#ifndef RATIO_TEMPERATURE_SCALES
#define RATIO_TEMPERATURE_SCALES FALSE
#endif

#ifndef USER_INITIAL_PARAMETERS_TEMPS
#define USER_INITIAL_PARAMETERS_TEMPS FALSE
#endif

#ifndef DELTA_PARAMETERS
#define DELTA_PARAMETERS FALSE
#endif

#ifndef QUENCH_PARAMETERS
#define QUENCH_PARAMETERS FALSE
#endif

#ifndef QUENCH_COST
#define QUENCH_COST FALSE
#endif

#ifndef QUENCH_PARAMETERS_SCALE
#define QUENCH_PARAMETERS_SCALE TRUE
#endif

#ifndef QUENCH_COST_SCALE
#define QUENCH_COST_SCALE TRUE
#endif

#ifndef OPTIONAL_DATA_DBL
#define OPTIONAL_DATA_DBL FALSE
#endif

#ifndef OPTIONAL_DATA_INT
#define OPTIONAL_DATA_INT FALSE
#endif

#ifndef OPTIONAL_DATA_PTR
#define OPTIONAL_DATA_PTR FALSE
#endif
#if OPTIONAL_DATA_PTR
/* user must define USER_TYPE; if a struct, it must be declared above */
#ifndef OPTIONAL_PTR_TYPE
#define OPTIONAL_PTR_TYPE USER_TYPE
#endif
#endif                          /* OPTIONAL_DATA_PTR */

#ifndef USER_REANNEAL_COST
#define USER_REANNEAL_COST FALSE
#endif

#ifndef USER_REANNEAL_PARAMETERS
#define USER_REANNEAL_PARAMETERS FALSE
#endif

#ifndef MAXIMUM_REANNEAL_INDEX
#define MAXIMUM_REANNEAL_INDEX 50000
#endif

#ifndef REANNEAL_SCALE
#define REANNEAL_SCALE 10
#endif

#ifndef USER_COST_SCHEDULE
#define USER_COST_SCHEDULE FALSE
#endif

#ifndef USER_ACCEPT_ASYMP_EXP
#define USER_ACCEPT_ASYMP_EXP FALSE
#endif

#ifndef USER_ACCEPT_THRESHOLD
#define USER_ACCEPT_THRESHOLD FALSE
#endif

#ifndef USER_ACCEPTANCE_TEST
#define USER_ACCEPTANCE_TEST FALSE
#endif

#ifndef USER_GENERATING_FUNCTION
#define USER_GENERATING_FUNCTION FALSE
#endif

  /* in asa.c, field-width.precision = G_FIELD.G_PRECISION */
#ifndef G_FIELD
#define G_FIELD 12
#endif
#ifndef G_PRECISION
#define G_PRECISION 7
#endif

#define INTEGER_TYPE		((int) 1)
#define REAL_TYPE		((int) -1)
#define INTEGER_NO_REANNEAL	((int) 2)
#define REAL_NO_REANNEAL	((int) -2)

  /* Set this to TRUE to self-optimize the Program Options */
#ifndef SELF_OPTIMIZE
#define SELF_OPTIMIZE FALSE
#endif

#ifndef USER_ASA_OUT
#define USER_ASA_OUT FALSE
#endif

#ifndef USER_ASA_USR_OUT
#define USER_ASA_USR_OUT FALSE
#endif

#ifndef USER_OUT
#define USER_OUT "asa_usr_out"
#endif

#ifndef ASA_SAMPLE
#define ASA_SAMPLE FALSE
#endif

#ifndef ASA_QUEUE
#define ASA_QUEUE FALSE
#endif

#ifndef ASA_RESOLUTION
#define ASA_RESOLUTION FALSE
#endif

#ifndef ASA_PARALLEL
#define ASA_PARALLEL FALSE
#endif

#ifndef ASA_SAVE_OPT
#define ASA_SAVE_OPT FALSE
#endif
#if ASA_SAVE_OPT
#define ASA_SAVE TRUE
#endif

#ifndef ASA_SAVE_BACKUP
#define ASA_SAVE_BACKUP FALSE
#endif
#if ASA_SAVE_BACKUP
#define ASA_SAVE TRUE
#endif

#ifndef ASA_SAVE
#define ASA_SAVE FALSE
#endif

#ifndef ASA_PIPE
#define ASA_PIPE FALSE
#endif

#ifndef ASA_PIPE_FILE
#define ASA_PIPE_FILE FALSE
#endif

#ifndef FDLIBM_POW
#define FDLIBM_POW FALSE
#endif
#if FDLIBM_POW
#define F_POW s_pow
#else
#define F_POW pow
#endif

#ifndef FDLIBM_LOG
#define FDLIBM_LOG FALSE
#endif
#if FDLIBM_LOG
#define F_LOG s_log
#else
#define F_LOG log
#endif

#ifndef FDLIBM_EXP
#define FDLIBM_EXP FALSE
#endif
#if FDLIBM_EXP
#define F_EXP s_exp
#else
#define F_EXP exp
#endif

#ifndef FITLOC
#define FITLOC FALSE
#endif

#ifndef FITLOC_ROUND
#define FITLOC_ROUND TRUE
#endif

#ifndef FITLOC_PRINT
#define FITLOC_PRINT TRUE
#endif

#ifndef MULTI_MIN
#define MULTI_MIN FALSE
#endif

#if ASA_PARALLEL
#ifdef _OPENMP
/* may need specific path */
#include "omp.h"
#endif                          /* _OPENMP */
#endif                          /* ASA_PARALLEL */

  /* Program Options */

  typedef struct {
    LONG_INT Limit_Acceptances;
    LONG_INT Limit_Generated;
    int Limit_Invalid_Generated_States;
    double Accepted_To_Generated_Ratio;

    double Cost_Precision;
    int Maximum_Cost_Repeat;
    int Number_Cost_Samples;
    double Temperature_Ratio_Scale;
    double Cost_Parameter_Scale_Ratio;
    double Temperature_Anneal_Scale;
#if USER_INITIAL_COST_TEMP
    double *User_Cost_Temperature;
#endif

    int Include_Integer_Parameters;
    int User_Initial_Parameters;
    ALLOC_INT Sequential_Parameters;
    double Initial_Parameter_Temperature;
#if RATIO_TEMPERATURE_SCALES
    double *User_Temperature_Ratio;
#endif
#if USER_INITIAL_PARAMETERS_TEMPS
    double *User_Parameter_Temperature;
#endif

    int Acceptance_Frequency_Modulus;
    int Generated_Frequency_Modulus;
    int Reanneal_Cost;
    int Reanneal_Parameters;

    double Delta_X;
#if DELTA_PARAMETERS
    double *User_Delta_Parameter;
#endif
    int User_Tangents;
    int Curvature_0;

#if QUENCH_PARAMETERS
    double *User_Quench_Param_Scale;
#endif
#if QUENCH_COST
    double *User_Quench_Cost_Scale;
#endif

    LONG_INT N_Accepted;
    LONG_INT N_Generated;
    int Locate_Cost;
    int Immediate_Exit;

    double *Best_Cost;
    double *Best_Parameters;
    double *Last_Cost;
    double *Last_Parameters;

#if OPTIONAL_DATA_DBL
    ALLOC_INT Asa_Data_Dim_Dbl;
    double *Asa_Data_Dbl;
#endif
#if OPTIONAL_DATA_INT
    ALLOC_INT Asa_Data_Dim_Int;
    LONG_INT *Asa_Data_Int;
#endif
#if OPTIONAL_DATA_PTR
    ALLOC_INT Asa_Data_Dim_Ptr;
    OPTIONAL_PTR_TYPE *Asa_Data_Ptr;
#endif
#if USER_ASA_OUT
    char *Asa_Out_File;
#endif
#if USER_ASA_USR_OUT
    char *Asa_Usr_Out_File;
#endif
    /* Keep OPTIONS_TMP in parameter lists in asa_usr.[ch] as they are
     * needed if using recursively, e.g., with SELF_OPTIMIZE=TRUE.
     * Make (USER_DEFINE *) casts explicit within functions. */
#if USER_COST_SCHEDULE
#if HAVE_ANSI
    double (*Cost_Schedule) (double current_cost_temperature,
                             const void *OPTIONS_TMP);
#else                           /* HAVE_ANSI */
    double (*Cost_Schedule) ();
#endif                          /* HAVE_ANSI */
#endif
#if USER_ACCEPT_ASYMP_EXP
    double Asymp_Exp_Param;
#endif
#if USER_ACCEPTANCE_TEST
#if HAVE_ANSI
    void (*Acceptance_Test) (double cost,
                             double *parameter_minimum,
                             double *parameter_maximum,
                             ALLOC_INT * number_parameters,
                             const void *OPTIONS_TMP);
#else                           /* HAVE_ANSI */
    void (*Acceptance_Test) ();
#endif                          /* HAVE_ANSI */
    int User_Acceptance_Flag;
    int Cost_Acceptance_Flag;
    double Cost_Temp_Curr;
    double Cost_Temp_Init;
    double Cost_Temp_Scale;
    double Prob_Bias;
    LONG_INT *Random_Seed;
#endif
#if USER_GENERATING_FUNCTION
#if HAVE_ANSI
    double (*Generating_Distrib) (LONG_INT * seed,
                                  ALLOC_INT * parameter_dimension,
                                  ALLOC_INT index_v,
                                  double temperature_v,
                                  double init_param_temp_v,
                                  double temp_scale_params_v,
                                  double parameter_v,
                                  double parameter_range_v,
                                  double *last_saved_parameter,
                                  const void *OPTIONS_TMP);
#else                           /* HAVE_ANSI */
    double (*Generating_Distrib) ();
#endif                          /* HAVE_ANSI */
#endif
#if USER_REANNEAL_COST
#if HAVE_ANSI
    int (*Reanneal_Cost_Function) (double *cost_best,
                                   double *cost_last,
                                   double *initial_cost_temperature,
                                   double *current_cost_temperature,
                                   const void *OPTIONS_TMP);
#else                           /* HAVE_ANSI */
    int (*Reanneal_Cost_Function) ();
#endif                          /* HAVE_ANSI */
#endif
#if USER_REANNEAL_PARAMETERS
#if HAVE_ANSI
    double (*Reanneal_Params_Function) (double current_temp,
                                        double tangent,
                                        double max_tangent,
                                        const void *OPTIONS_TMP);
#else                           /* HAVE_ANSI */
    double (*Reanneal_Params_Function) ();
#endif                          /* HAVE_ANSI */
#endif
#if ASA_SAMPLE
    double Bias_Acceptance;
    double *Bias_Generated;
    double Average_Weights;
    double Limit_Weights;
#endif
#if ASA_QUEUE
    ALLOC_INT Queue_Size;
    double *Queue_Resolution;
#endif
#if ASA_RESOLUTION
    double *Coarse_Resolution;
#endif
#if FITLOC
    int Fit_Local;
    int Iter_Max;
    double Penalty;
#endif
#if MULTI_MIN
    int Multi_Number;
    double *Multi_Cost;
    double **Multi_Params;
    double *Multi_Grid;
    int Multi_Specify;
#endif
#if ASA_PARALLEL
    int parallel_id;
    int Gener_Mov_Avr;
    LONG_INT Gener_Block;
    LONG_INT Gener_Block_Max;
#endif
#if ASA_SAVE
    ALLOC_INT Random_Array_Dim;
    double *Random_Array;
#endif
    int Asa_Recursive_Level;
#if ASA_FUZZY
    int NoOfSamples;
    double ThresholdDeviation;
    double Threshold1;
    double Performance_Target;
    double Factor_a;
#endif
  } USER_DEFINES;

  /* system function prototypes */

#if HAVE_ANSI

/* This block gives trouble under some Ultrix */
#if FALSE
  int fprintf (FILE * fp, const char *string, ...);
  int sprintf (char *s, const char *format, ...);
  FILE *popen (const char *command, const char *mode);
  void exit (int code);
#endif

#if IO_PROTOTYPES
  int fprintf ();
  int sprintf ();
  int fflush (FILE * fp);
  int fclose (FILE * fp);
  void exit ();
  int fread ();
  int fwrite ();
  int pclose ();
#endif

  double
    asa (double (*user_cost_function)

          
         (double *, double *, double *, double *, double *, ALLOC_INT *,
          int *, int *, int *, USER_DEFINES *),
         double (*user_random_generator) (LONG_INT *), LONG_INT * rand_seed,
         double *parameter_initial_final, double *parameter_minimum,
         double *parameter_maximum, double *tangents, double *curvature,
         ALLOC_INT * number_parameters, int *parameter_type,
         int *valid_state_generated_flag, int *exit_status,
         USER_DEFINES * OPTIONS);

#if TIME_CALC
  void print_time (char *message, FILE * ptr_out);
#endif

#if FDLIBM_POW
  double s_pow (double x, double y);
#endif
#if FDLIBM_LOG
  double s_log (double x);
#endif
#if FDLIBM_EXP
  double s_exp (double x);
#endif

#else                           /* HAVE_ANSI */

#if IO_PROTOTYPES
  int fprintf ();
  int sprintf ();
  int fflush ();
  int fclose ();
  int fread ();
  int fwrite ();
  FILE *popen ();
  int pclose ();
#endif

  double asa ();

#if TIME_CALC
  void print_time ();
#endif

#if FDLIBM_POW
  double s_pow ();
#endif
#if FDLIBM_LOG
  double s_log ();
#endif
#if FDLIBM_EXP
  double s_exp ();
#endif

#endif                          /* HAVE_ANSI */

#ifdef __cplusplus
}
#endif
#endif                          /* _ASA_USER_ASA_H_ */
/***********************************************************************
* Adaptive Simulated Annealing (ASA)
* Lester Ingber <ingber@ingber.com>
* Copyright (c) 1987-2016 Lester Ingber.  All Rights Reserved.
* ASA-LICENSE file has the license that must be included with ASA code.
***********************************************************************/

 /* $Id: asa_usr_cst.c,v 30.21 2016/02/02 15:49:43 ingber Exp ingber $ */

 /* asa_usr_cst.c for Adaptive Simulated Annealing */

#include "asa_usr.h"

#if COST_FILE

 /* Note that this is a trimmed version of the ASA_TEST problem.
    A version of this cost_function with more documentation and hooks for
    various templates is in asa_usr.c. */

 /* If you use this file to define your cost_function (the default),
    insert the body of your cost function just above the line
    "#if ASA_TEST" below.  (The default of ASA_TEST is FALSE.)

    If you read in information via the asa_opt file (the default),
    define *parameter_dimension and
    parameter_lower_bound[.], parameter_upper_bound[.], parameter_int_real[.]
    for each parameter at the bottom of asa_opt.

    The minimum you need to do here is to use
    x[0], ..., x[*parameter_dimension-1]
    for your parameters and to return the value of your cost function.  */

#if HAVE_ANSI
double
cost_function (double *x,
               double *parameter_lower_bound,
               double *parameter_upper_bound,
               double *cost_tangents,
               double *cost_curvature,
               ALLOC_INT * parameter_dimension,
               int *parameter_int_real,
               int *cost_flag, int *exit_code, USER_DEFINES * USER_OPTIONS)
#else
double
cost_function (x,
               parameter_lower_bound,
               parameter_upper_bound,
               cost_tangents,
               cost_curvature,
               parameter_dimension,
               parameter_int_real, cost_flag, exit_code, USER_OPTIONS)
     double *x;
     double *parameter_lower_bound;
     double *parameter_upper_bound;
     double *cost_tangents;
     double *cost_curvature;
     ALLOC_INT *parameter_dimension;
     int *parameter_int_real;
     int *cost_flag;
     int *exit_code;
     USER_DEFINES *USER_OPTIONS;
#endif
{

  /* *** Insert the body of your cost function here, or warnings
   * may occur if COST_FILE = TRUE & ASA_TEST != TRUE ***
   * Include ADAPTIVE_OPTIONS below if required */
#if ASA_TEST
#else
#if ADAPTIVE_OPTIONS
  adaptive_options (USER_OPTIONS);
#endif
#endif

#if ASA_TEST
  double q_n, d_i, s_i, t_i, z_i, c_r;
  int k_i;
  ALLOC_INT i, j;
  static LONG_INT funevals = 0;

#if ADAPTIVE_OPTIONS
  adaptive_options (USER_OPTIONS);
#endif

  s_i = 0.2;
  t_i = 0.05;
  c_r = 0.15;

  q_n = 0.0;
  for (i = 0; i < *parameter_dimension; ++i) {
    j = i % 4;
    switch (j) {
    case 0:
      d_i = 1.0;
      break;
    case 1:
      d_i = 1000.0;
      break;
    case 2:
      d_i = 10.0;
      break;
    default:
      d_i = 100.0;
    }
    if (x[i] > 0.0) {
      k_i = (int) (x[i] / s_i + 0.5);
    } else if (x[i] < 0.0) {
      k_i = (int) (x[i] / s_i - 0.5);
    } else {
      k_i = 0;
    }

    if (fabs (k_i * s_i - x[i]) < t_i) {
      if (k_i < 0) {
        z_i = k_i * s_i + t_i;
      } else if (k_i > 0) {
        z_i = k_i * s_i - t_i;
      } else {
        z_i = 0.0;
      }
      q_n += c_r * d_i * z_i * z_i;
    } else {
      q_n += d_i * x[i] * x[i];
    }
  }
  funevals = funevals + 1;

  *cost_flag = TRUE;

#if FALSE                       /* may set to TRUE if printf() is active */
#if TIME_CALC
  if ((PRINT_FREQUENCY > 0) && ((funevals % PRINT_FREQUENCY) == 0)) {
    printf ("funevals = %ld  ", funevals);
    print_time ("", stdout);
  }
#endif
#endif

#if ASA_FUZZY
  if (*cost_flag == TRUE
      && (USER_OPTIONS->Locate_Cost == 2 || USER_OPTIONS->Locate_Cost == 3
          || USER_OPTIONS->Locate_Cost == 4)) {
    FuzzyControl (USER_OPTIONS, x, q_n, *parameter_dimension);
  }
#endif /* ASA_FUZZY */

  return (q_n);
#endif /* ASA_TEST */
}
#endif /* COST_FILE */
